<resources xmlns:tools="http://schemas.android.com/tools">
    <string name="app_name">OCA and OCP quizzes</string>

    <string name="bar">OCA &amp; OCP</string>
    <string name="select">Select a category to start the quiz</string>
    <string name="card1">OCA\t</string>
    <string name="card2">OCP\t</string>
    <string name="card3">OCA &amp; OCP\t</string>
    <string name="card4">Study Tips OCA</string>
    <string name="card5">Exit</string>
    <string name="next">Next</string>
    <string name="score">Score</string>
    <string name="backToHome">Back To Home</string>

    <string name="OCA1">1. Assessment Test</string>
    <string name="OCA2">2. Operators and Statements</string>
    <string name="OCA3">3. Core Java APIs</string>
    <string name="OCA4">4. Methods and Encapsulation</string>
    <string name="OCA5">5. Class Design</string>
    <string name="OCA6">6. Exceptions </string>
    <string name="OCA7">7. Answers to Review Questions </string>

    <string name="OSP1">1. Assessment Test</string>
    <string name="OCP2">2. Advanced Class Design</string>
    <string name="OCP3">3. Design Patterns and Principles</string>
    <string name="OCP4">4. Generics and Collections</string>
    <string name="OCP5">5. Functional Programming</string>
    <string name="OCP6">6. Dates Strings And Localization</string>



    <string-array name="AssessmentTest">
<!--        1-->
        <item>1. What is the result of the following code?
            \n1: String s1 = "Java";
            \n2: String s2 = "Java";
            \n3: StringBuilder sb1 = new StringBuilder();
            \n4: sb1.append("Ja").append("va");
            \n5: System.out.println(s1 == s2);
            \n6: System.out.println(s1.equals(s2));
            \n7: System.out.println(sb1.toString() == s1);
            \n8: System.out.println(sb1.toString().equals(s1));
        </item>
<!--        2-->
        <item>
            2. What is the output of the following program?
            \n1: public class FeedingSchedule {
            \n2: public static void main(String[] args) {
            \n3: boolean keepGoing = true;
            \n4: int count = 0;
            \n5: int x = 3;
            \n6: while(count++ &#60; 3) {
            \n7: int y = (1 + 2 * count) % 3;
            \n8: switch(y) {
            \n9: default:
            \n10: case 0: x -= 1; break;
            \n11: case 1: x += 5;
            \n12: }
            \n13: }
            \n14: System.out.println(x);
            \n15: } }
        </item>
        <!--        3-->
        <item>
            3. What is the output of the following code snippet?
\n13: System.out.print("a");
\n14: try {
\n15: System.out.print("b");
\n16: throw new IllegalArgumentException();
\n17: } catch (RuntimeException e) {
\n18: System.out.print("c");
\n19: } finally {
\n20: System.out.print("d");
\n21: }
\n22: System.out.print("e");
        </item>
        <!--        4-->
        <item>
            4. What is the result of the following program?
\n1: public class MathFunctions {
\n2: public static void addToInt(int x, int amountToAdd) {
\n3: x = x + amountToAdd;
\n4: }
\n5: public static void main(String[] args) {
\n6: int a = 15;
\n7: int b = 10;
\n8: MathFunctions.addToInt(a, b);
\n9: System.out.println(a); } }
        </item>
        <!--        5-->
        <item>
            5. What is the result of the following code?
\nint[] array = {6,9,8};
\nList&#60;Integer&#62; list = new ArrayList&#60;&#62;();
  \n          list.add(array[0]);
\nlist.add(array[2]);
\nlist.set(1, array[1]);
\nlist.remove(0);
\nSystem.out.println(list);
        </item>
        <!--        6-->
        <item>
            6. What is the output of the following code?
\n1: public class Deer {
\n2: public Deer() { System.out.print("Deer"); }
\n3: public Deer(int age) { System.out.print("DeerAge"); }
\n4: private boolean hasHorns() { return false; }
\n5: public static void main(String[] args) {
\n6: Deer deer = new Reindeer(5);
\n7: System.out.println(","+deer.hasHorns());
\n8: }
\n9: }
\n10: class Reindeer extends Deer {
\n11: public Reindeer(int age) { System.out.print("Reindeer"); }
\n12: public boolean hasHorns() { return true; }
\n13: }
        </item>
        <!--        7-->
        <item>
            7. What is the output of the following program?
\n1: public class FeedingSchedule {
\n2: public static void main(String[] args) {
\n3: int x = 5, j = 0;
\n4: OUTER: for(int i=0; i&#60;3; )
\n5: INNER: do {
\n6: i++; x++;
\n7: if(x > 10) break INNER;
\n8: x += 4;
\n9: j++;
\nn10: } while(j &#60;= 2);
\n11: System.out.println(x);
\n12: } }
        </item>
        <!--        8-->
        <item>
            8. What is the result of the following program?
\n1: public class Egret {
\n2: private String color;
\n3: public Egret() {
\n4: this("white");
\n5: }
\n6: public Egret(String color) {
\n7: color = color;
\n8: }
\n9: public static void main(String[] args) {
\n10: Egret e = new Egret();
\n11: System.out.println("Color:" + e.color);
\n12: }
\n13: }
        </item>
        <!--        9-->
        <item>
            9. What is the output of the following program?
\n1: public class BearOrShark {
\n2: public static void main(String[] args) {
\n3: int luck = 10;
\n4: if((luck>10 ? luck++: —luck)&#60;10) {
\n5: System.out.print("Bear");
\n6: } if(luck&#60;10) System.out.print("Shark");
\n7: } }
        </item>
<!--        10-->
        <item>
             10. Bytecode is in a file with which extension?
        </item>

    </string-array>


    <string-array name="correctAnswersForAssessmentTest">
        <!--1--><item>C. true is printed out exactly three times.</item>
        <!--2--><item>C. 6</item>
        <!--3--><item>D. abcde</item>
        <!--4--><item>B. 15</item>
        <!--5--><item>B. [9]</item>
        <!--6--><item>A. DeerReindeer,false</item>
        <!--7--><item>B. 12</item>
        <!--8--><item>B. Color:null</item>
        <!--9--><item>C. BearShark</item>
        <!--10--><item>C. .class</item>
    </string-array>

    <string-array name="keysAForAssessmentTest">
        <item>A. true is printed out exactly once</item>
        <item>A. 4</item>
        <item>A. abe</item>
        <item>A. 10</item>
        <item>A. [8]</item>
        <item>A. DeerReindeer,false</item>
        <item>A. 10</item>
        <item>A. Color:</item>
        <item>A. Bear</item>
        <item>A. .bytecode</item>
    </string-array>

    <string-array name="keysBForAssessmentTest">
        <item>B. true is printed out exactly twice.</item>
        <item>B. 5</item>
        <item>B. abce</item>
        <item>B. 15</item>
        <item>B. [9]</item>
        <item>B. DeerReindeer,true</item>
        <item>B. 12</item>
        <item>B. Color:null</item>
        <item>B. Shark</item>
        <item>B. .bytes</item>

    </string-array>

    <string-array name="keysCForAssessmentTest">
        <item>C. true is printed out exactly three times.</item>
        <item>C. 6</item>
        <item>C. abde</item>
        <item>C. 25</item>
        <item>C. Something like [Ljava.lang.String;@160bc7c0</item>
        <item>C. ReindeerDeer,false</item>
        <item>C. 13</item>
        <item>C. Color:White</item>
        <item>C. BearShark</item>
        <item>C. .class</item>

    </string-array>

    <string-array name="keysDForAssessmentTest">
        <item>D. true is printed out exactly four times.</item>
        <item>B. 7</item>
        <item>D. abcde</item>
        <item>D. Compiler error on line 3</item>
        <item>D. An exception is thrown</item>
        <item>D. ReindeerDeer,true</item>
        <item>D. 17</item>
        <item>D. Compiler error on line 4.</item>
        <item>D. The code will not compile because of line 4.</item>
        <item>D. .exe</item>

    </string-array>

    <string-array name="keysEForAssessmentTest">
        <item>E. The code does not compile.</item>
        <item>E. 13</item>
        <item>E. The code does not compile</item>
        <item>E. Compiler error on line 8</item>
        <item>E. The code does not compile.</item>
        <item>E. DeerAgeReindeer,false</item>
        <item>E. The code will not compile because of line 4.</item>
        <item>E. Compiler error on line 10.</item>
        <item>E. The code will not compile because of line 6.</item>
        <item>E. .javac</item>

    </string-array>

    <string-array name="keysFForAssessmentTest">
        <item>F. Runtime error</item>
        <item>F. The code will not compile because of line 7</item>
        <item>F. An uncaught exception is thrown.</item>
        <item>F. None of the above.</item>
        <item>F. None of the above.</item>
        <item>F. The code will not compile because of line 7.</item>
        <item>F. The code will not compile because of line 6.</item>
        <item>F. Compiler error on line 11.</item>
        <item>F. The code compiles without issue but does not produce any output.</item>
        <item>F. .java</item>

    </string-array>

    <integer-array name="qweert">
        <item>@drawable/image_cover</item>

    </integer-array>

    <string-array name="AnswerDefinitionForAssessmentTest">
        <item>\nAnswer C. \nString literals are used from the string pool. This means that s1 and s2 refer to the
same object and are equal. Therefore, the first two print statements print true. The
third print statement prints false because toString() uses a method to compute the
value and it is not from the string pool. The final print statement again prints true
because equals() looks at the values of String objects.
        </item>
<!--        ******************-->
        <item>
             \nAnswer C. \nThe code compiles and runs without issue; therefore, option F is incorrect. This type
of problem is best examined one loop iteration at a time:
 \n\n1. The loop continues as count loop expression evaluates to 0 &#60; 3, which is true,
\nwith y taking a new value of 1. The value of y is set to:
\ny = (1 + 2 * 1) % 3
 \n= (1 + 2) % 3
 \n= 3 % 3
 \n= 0
\n\n2. The first case block is called and the value of x is then set to:
\nx = 3 - 1 = 2
\n\n3. The loop continues as count loop expression evaluates to 1 &#60; 3, which is true,
\nwith y taking a new value of 2. The value of y is set to:
\ny = (1 + 2 * 2) % 3
 \n= (1 + 4) % 3
 \n= 4 % 3
 \n= 2
\n\n4. The default block is called and the value of x is set to:
\nx = 2 - 1 = 1
 \n\n5. The loop continues as the count loop expression evaluates to 2 &#60; 3, which is true,
\nwith y taking a new value of 3. The value of y is set to:
\ny = (1 + 2 * 3) % 3
 \n= (1 + 6) % 3
 \n= 7 % 3
 \n= 1
 \n\n6. The second case block is called and the value of x is then set to:
\nx = 1 + 5 = 6
 \n\n7. The loop ends as the count loop expression evaluates to 3 &#60; 3, with y also taking a
\nnew value of 4. The most recent value of x, 6, is output, so the answer is option C.
        </item>
<!--        **************-->
        <item>
            \nAnswer D. The code starts running and prints a and b on lines 13 and 15. Line 16 throws an
exception, which is caught on line 17. After line 18 prints c, the finally block is run
and d is printed. Then the try statement ends and e is printed on line 22.
        </item>
<!--        ****************-->
        <item>
             \nAnswer B. The code compiles successfully, so options D and E are incorrect. The value of a
        cannot be changed by the addToInt method, no matter what the method does, because
        only a copy of the variable is passed into the parameter x. Therefore, a does not change
        and the output on line 9 is 15.
        </item>

        <item>
            \nnAnswerB. The array is allowed to use an anonymous initializer because it is in the same line as
the declaration. The ArrayList uses the diamond operator allowed since Java 7. This
specifies the type matches the one on the left without having to re-type it. After adding
the two elements, list contains [6, 8]. We then replace the element at index 1 with 9,
resulting in [6, 9]. Finally, we remove the element at index 0, leaving [9]. Option C
is incorrect because arrays output something like that rather than an ArrayList.
        </item>

        <item>
            \nnAnswer A.First, the Reindeer object is instantiated using the constructor that takes an int value. Since
there is no explicit call to the parent constructor, the default no-argument super()
is inserted as the first line of the constructor. The output is then Deer, followed by
Reindeer in the child constructor, so only options A and B can be correct. Next,
the method hasHorns() looks like an overridden method, but it is actually a hidden
method since it is declared private in the parent class. Because the hidden method is
referenced in the parent class, the parent version is used, so the code outputs false,
and option A is the correct answer.
        </item>

        <item>
            \nnAnswer B. The code compiles and runs without issue; therefore, options E and F are incorrect.
This type of problem is best examined one loop iteration at a time:
\t On the first iteration of the outer loop i is 0, so the loop continues.
\t On the first iteration of the inner loop, i is updated to 1 and x to 6. The if-then
statement branch is not executed, and x is increased to 10 and j to 1.
\t On the second iteration of the inner loop (since j = 1 and 1 &#60;= 2), i is updated
to 2 and x to 11. At this point, the if-then branch will evaluate to true for the
remainder of the program run, which causes the flow to break out of the inner
loop each time it is reached.
\t On the second iteration of the outer loop (since i = 2), i is updated to 3 and x to
12. As before, the inner loop is broken since x is still greater than 10.
\t On the third iteration of the outer loop, the outer loop is broken, as i is already
not less than 3. The most recent value of x, 12, is output, so the answer is option B.
        </item>
<!--        **********-->
        <item>
             \nnAnswer B. Line 10 calls the constructor on lines 3–5. That constructor calls the other constructor. However, the constructor on lines 6–8 assigns the method parameter to itself,
which leaves the color instance variable on line 2 set to its default value of null.
        </item>
<!--        ************-->
        <item>
            \nnAnswer C. The code compiles and runs without issue, so options D and E are correct. Remember that only one of the right-hand ternary expressions will be evaluated at runtime.
Since luck is not less than 10, the second expression, -\-luck, will be evaluated, and
since the pre-increment operator was used, the value returned will be 9, which is less
than 10. So the first if-then statement will be visited and Bear will be output. Notice
there is no else statement on line 6. Since luck is still less than 10, the second if-then
statement will also be reached and Shark will be output; therefore, the correct answer
is option C.
        </item>
<!--        ****************-->
        <item>
            \nnAnswer C. Files with the .java extension contain the Java source code and are compiled to
files with the .class extension that contain the bytecode.
        </item>
    </string-array>



    <!--    Operators and Statements-->
    <string-array name="OperatorsAndStatements">
<!--        1-->
        <item>1. What is the output of the following application?
\n1: public class CompareValues {
\n2: public static void main(String[] args) {
\n3: int x = 0;
\n4: while(x++ &#60; 10) {}
\n5: String message = x > 10 ? "Greater than" : false;
\n6: System.out.println(message+","+x);
\n7: }
\n8: }</item>
<!--        2-->
        <item>
            2.  What is the output of the following code snippet?
\n3: java.util.List&#60;Integer&#62; list = new java.util.ArrayList&#60;Integer&#62;();
\n4: list.add(10);
\n5: list.add(14);
\n6: for(int x : list) {
\n7: System.out.print(x + ", ");
\n8: break;
\n9: }
        </item>
<!--        3-->
        <item>3. What is the output of the following code snippet?
\n3: int x = 4;
\n4: long y = x * 4 - x++;
\n5: if(y&#60;10) System.out.println("Too Low");
\n6: else System.out.println("Just right");
\n7: else System.out.println("Too High");
</item>
<!--        4-->
        <item>
            4. What is the output of the following code?
\n1: public class TernaryTester {
\n2: public static void main(String[] args) {
\n3: int x = 5;
\n4: System.out.println(x > 2 ? x &#60; 4 ? 10 : 8 : 7);
\n5: }}
        </item>
<!--        5-->
        <item>
            5. What is the output of the following code snippet?
\n3: boolean x = true, z = true;
\n4: int y = 20;
\n5: x = (y != 10) ^ (z=false);
\n6: System.out.println(x+", "+y+", "+z);
        </item>
<!--        6-->
        <item>
            6. How many times will the following code print "Hello World"?
\n3: for(int i=0; i&#60;10 ; ) {
\n4: i = i++;
\n5: System.out.println("Hello World");
\n6: }
        </item>
<!--        7-->
        <item>
             7. What is the output of the following code?
\n3: byte a = 40, b = 50;
\n4: byte sum = (byte) a + b;
\n5: System.out.println(sum);
        </item>
<!--        8-->
        <item>
            8. What is the output of the following code?
\n1: public class ArithmeticSample {
\n2: public static void main(String[] args) {
\n3: int x = 5 * 4 % 3;
\n4: System.out.println(x);
\n5: }}
        </item>
<!--        9-->
        <item>
            9. What is the output of the following code snippet?
\n3: int x = 0;
\n4: String s = null;
\n5: if(x == s) System.out.println("Success");
\n6: else System.out.println("Failure");
        </item>
<!--        10-->
        <item>
             10. What is the output of the following code snippet?
\n3: int x1 = 50, x2 = 75;
\n4: boolean b = x1 >= x2;
\n5: if(b = true) System.out.println("Success");
\n6: else System.out.println("Failure");
        </item>
<!--        11-->
        <item>
            11. What is the output of the following code snippet?
\n3: int c = 7;
\n4: int result = 4;
  \n          5: result += ++c;
\n6: System.out.println(result);
        </item>
<!--        12-->
        <item>
             12. What is the output of the following code snippet?
\n3: int x = 1, y = 15;
\n4: while x &#60; 10
\n5: y––;
\n6: x++;
\n7: System.out.println(x+", "+y);
        </item>
<!--        13-->
        <item>
             13. What is the output of the following code snippet?
\n3: do {
\n4: int y = 1;
\n5: System.out.print(
            \n6: } while(y &#60;= 10);
        </item>
<!--        14-->
        <item>
            14. What is the output of the following code snippet?
\n3: boolean keepGoing = true;
\n4: int result = 15, i = 10;
\n5: do {
\n6: i-\-;
\n7: if(i==8) keepGoing = false;
\n8: result -= 2;
\n9: } while(keepGoing);
            \n10: System.out.println(result);
        </item>
<!--        15-->
        <item>
             15. What is the output of the following code snippet?
\n3: int count = 0;
\n4: ROW_LOOP: for(int row = 1; row &#60;=3; row++)
\n5: for(int col = 1; col &#60;=2 ; col++) {
\n6: if(row * col % 2 == 0) continue ROW_LOOP;
\n7: count++;
\n8: }
\n9: System.out.println(count);
        </item>
<!--        16-->
        <item>
            16. What is the result of the following code snippet?
\n3: int m = 9, n = 1, x = 0;
\n4: while(m > n) {
\n5: m—;
\n6: n += 2;
\n7: x += m + n;
\n8: }
\n9: System.out.println(x);
        </item>
<!--        17-->
        <item>
            17. What is the result of the following code snippet?
\n3: final char a = \'A\', d = \'D\';
\n4: char grade = \'B\';
            \n5: switch(grade) {
\n6: case a:
\n7: case \'B\': System.out.print("great");
\n8: case \'C\': System.out.print("good"); break;
\n9: case d:
\n10: case \'F\': System.out.print("not good");
\n11: }
        </item>
<!--        18-->
        <item>
            18. What is the output of the following program?
\n\n1: public class WaterBottle {
\n2: private String brand;
\n3: private boolean empty;
\n4: public static void main(String[] args) {
\n5: WaterBottle wb = new WaterBottle();
\n6: System.out.print("Empty = " + wb.empty);
\n7: System.out.print(", Brand = " + wb.brand);
\n8: } }
        </item>
<!--        19-->
        <item> 19. Given the following classes, what is the maximum number of imports that can be removed
and have the code still compile?
\n\npackage aquarium; public class Water { }
\npackage aquarium;
\nimport java.lang.*;
\nimport java.lang.System;
\nimport aquarium.Water;
\nimport aquarium.*;
\npublic class Tank {
 \npublic void print(Water water) {
 \nSystem.out.println(water); } }</item>
<!--        20-->
        <item>20. What does the following code output?
\n\n1: public class Salmon {
\n2: int count;
\n3: public void Salmon() {
\n4: count = 4;
\n5: }
\n6: public static void main(String[] args) {
\n7: Salmon s = new Salmon();
\n8: System.out.println(s.count);
\n9: } }</item>
    </string-array>

    <string-array name="AnswerDefinitionForOperatorAndStatements">
<!--       1-->
        <item>
            \n\tAnswer F. In this example, the ternary operator has two expressions, one of them a String and
the other a boolean value. The ternary operator is permitted to have expressions that
don’t have matching types, but the key here is the assignment to the String reference.
The compiler knows how to assign the first expression value as a String, but the second boolean expression cannot be set as a String; therefore, this line will not compile.
        </item>
<!--2-->
        <item>
            \n\tAnswer C. This code does not contain any compilation errors or an infinite loop, so options D,
E, and F are incorrect. The break statement on line 8 causes the loop to execute once
and finish, so option C is the correct answer.
        </item>
<!--3-->
        <item>
            \n\tAnswer F. The code does not compile because two else statements cannot be chained together
without additional if-then statements, so the correct answer is option F. Option E is
incorrect as Line 6 by itself does not cause a problem, only when it is paired with Line
7. One way to fix this code so it compiles would be to add an if-then statement on
line 6. The other solution would be to remove line 7.
        </item>
<!--4-->
        <item>
            \n\tAnswer D. As you learned in the section “Ternary Operator,” although parentheses are not
required, they do greatly increase code readability, such as the following equivalent
statement:
System.out.println((x > 2) ? ((x &#60; 4) ? 10 : 8) : 7)
We apply the outside ternary operator fi rst, as it is possible the inner ternary expression
may never be evaluated. Since (x>2) is true, this reduces the problem to:
System.out.println((x &#60; 4) ? 10 : 8)
Since x is greater than 2, the answer is 8, or option D in this case.
        </item>
<!--5-->
        <item>
            \n\tAnswer B. This example is tricky because of the second assignment operator embedded in line
5. The expression (z=false) assigns the value false to z and returns false for the
entire expression. Since y does not equal 10, the left-hand side returns true; therefore,
the exclusive or (^) of the entire expression assigned to x is true. The output reflects
these assignments, with no change to y, so option B is the only correct answer. The
code compiles and runs without issue, so option F is not correct.
        </item>
<!--6-->
        <item>
            \n\tAnswer F. In this example, the update statement of the for loop is missing, which is fine as the
statement is optional, so option D is incorrect. The expression inside the loop increments i but then assigns i the old value. Therefore, i ends the loop with the same value that it starts with: 0. The loop will repeat infinitely, outputting the same statement over
and over again because i remains 0 after every iteration of the loop.
        </item>
<!--7-->
        <item>
             \n\t Answer D. Line 4 generates a possible loss of precision compiler error. The cast operator has
the highest precedence, so it is evaluated first, casting a to a byte. Then, the addition is
evaluated, causing both a and b to be promoted to int values. The value 90 is an int
and cannot be assigned to the byte sum without an explicit cast, so the code does not
compile. The code could be corrected with parentheses around (a + b), in which case
option C would be the correct answer.
        </item>
<!--8-->
        <item>
             \n\tAnswer A. The * and % have the same operator precedence, so the expression is evaluated
from left-to-right. The result of 5 * 4 is 20, and 20 % 3 is 2 (20 divided by 3 is 18, the
remainder is 2). The output is 2 and option A is the correct answer.
        </item>
<!--9-->
        <item>
             \n\tAnswer D. The variable x is an int and s is a reference to a String object. The two data types
are incomparable because neither variable can be converted to the other variable’s type.
The compiler error occurs on line 5 when the comparison is attempted, so the answer
is option D.
        </item>
<!--10-->
        <item>
             \n\tAnswer A. The code compiles successfully, so options C and D are incorrect. The value of b
after line 4 is false. However, the if-then statement on line 5 contains an assignment,
not a comparison. The variable b is assigned true on line 3, and the assignment operator returns true, so line 5 executes and displays Success, so the answer is option A.
        </item>
<!--11-->
        <item>
             \n\tAnswer C. The code compiles successfully, so option F is incorrect. On line 5, the pre-increment operator is used, so c is incremented to 4 and the new value is returned to the
expression. The value of result is computed by adding 4 to the original value of 8,
resulting in a new value of 12, which is output on line 6. Therefore, option C is the
correct answer
        </item>
<!--12-->
        <item>
            \n\tAnswer E. This is actually a much simpler problem than it appears to be. The while statement
on line 4 is missing parentheses, so the code will not compile, and option E is the correct answer. If the parentheses were added, though, option F would be the correct
answer since the loop does not use curly braces to include x++ and the boolean expression never changes. Finally, if curly braces were added around both expressions, the
output would be 10, 6 and option B would be correct.
        </item>
<!--13-->
        <item>\n\tAnswer D. The variable y is declared within the body of the do-while statement, so it is out of
scope on line 6. Line 6 generates a compiler error, so option D is the correct answer.
        </item>
<!--14-->
        <item>
            \n\tAnswer D. The code compiles without issue, so option F is incorrect. After the first execution of the loop, i is decremented to 9 and result to 13. Since i is not 8, keepGoing is
false, and the loop continues. On the next iteration, i is decremented to 8 and result
to 11. On the second execution, i does equal 8, so keepGoing is set to false. At the
conclusion of the loop, the loop terminates since keepGoing is no longer true. The
value of result is 11, and the correct answer is option D.
        </item>
<!--15-->
        <item>
            \n\tAnswer A. The expression on line 5 is true when row * col is an even number. On the first
iteration, row = 1 and col = 1, so the expression on line 6 is false, the continue is
skipped, and count is incremented to 1. On the second iteration, row = 1 and col = 2, so the expression on line 6 is true and the continue ends the outer loop with
count still at 1. On the third iteration, row = 2 and col = 1, so the expression on line
6 is true and the continue ends the outer loop with count still at 1. On the fourth
iteration, row = 3 and col = 1, so the expression on line 6 is false, the continue is
skipped, and count is incremented to 2. Finally, on the fifth and final iteration, row
= 3 and col = 2, so the expression on line 6 is true and the continue ends the outer
loop with count still at 2. The result of 2 is displayed, so the answer is option B.
        </item>
<!--16-->
        <item>
            \n\tAnswer D. Prior to the first iteration, m = 9, n = 1, and x = 0. After the iteration of the first
loop, m is updated to 8, n to 3, and x to the sum of the new values for m + n, 0 + 11 =
11. After the iteration of the second loop, m is updated to 7, n to 5, and x to the sum
of the new values for m + n, 11 + 12 = 23. After the iteration of the third loop, m is
updated to 6, n to 7, and x to the sum of the new values for m + n, 23 + 13 = 36. On
the fourth iteration of the loop, m > n evaluates to false, as 6 &#60; 7 is not true. The
loop ends and the most recent value of x, 36, is output, so the correct answer is option
D.
        </item>
<!--17-->
        <item>
             \n\tAnswer B. The code compiles and runs without issue, so options C, D, and E are not correct. The
value of grade is \'B\' and there is a matching case statement that will cause "great" to
be printed. There is no break statement after the case, though, so the next case statement will be reached, and "good" will be printed. There is a break after this case statement, though, so the switch statement will end. The correct answer is thus option B.
        </item>
<!--18-->
        <item>
            \n\tAnswer D. Boolean fields initialize to false and references initialize to null, so empty is false
and brand is null. Brand = null is output.
        </item>
<!--19-->
        <item>
            \n\tAnswer E. The first two imports can be removed because java.lang is automatically imported.
The second two imports can be removed because Tank and Water are in the same package, making the correct answer E. If Tank and Water were in different packages, one of
these two imports could be removed. In that case, the answer would be option D.
        </item>
<!--20-->
        <item>
            \n\tAnswer A. While the code on line 3 does compile, it is not a constructor because it has a return
type. It is a method that happens to have the same name as the class. When the code
runs, the default constructor is called and count has the default value (0) for an int.
        </item>
    </string-array>

    <string-array name="CorrectAnswersForOperatorsAndStatements">
        <!--    1--><item>F. The code will not compile because of line 5.</item>
        <!--    2--><item>C. 10,</item>
        <!--    3--><item>F. The code will not compile because of line 7</item>
        <!--    4--><item>D. 8</item>
        <!--    5--><item>B. true, 20, false</item>
        <!--    6--><item>F. The code contains an infinite loop and does not terminate.</item>
        <!--    7--><item>D. The code will not compile because of line 4.</item>
        <!--    8--><item>A. 2</item>
        <!--    9--><item>D. The code will not compile because of line 5.</item>
        <!--    10--><item>A. Success</item>
        <!--    11--><item>C. 12</item>
        <!--    12--><item>E. The code will not compile because of line 4.</item>
        <!--    13--><item>D. The code will not compile because of line 6.</item>
        <!--    14--><item>D. 11</item>
        <!--    15--><item>A. 1</item>
        <!--    16--><item>D. 36</item>
        <!--    17--><item>B. greatgood </item>
        <item>D. Empty = false, Brand = null</item>
        <item>E. 4</item>
        <item>A. 0</item>
    </string-array>

    <string-array name="keysAForOperatorsAndStatements">
        <item>A. Greater than,10</item>
        <item>A. 10, 14,</item>
        <item>A. Too Low</item>
        <item>A. 5</item>
        <item>A. true, 10, true</item>
        <item>A. 9</item>
        <item>A. 40</item>
        <item>A. 2</item>
        <item>A. Success</item>
        <item>A. Success</item>
        <item>A. 8</item>
        <item>A. 10, 5</item>
        <item>A. 1 2 3 4 5 6 7 8 9</item>
        <item>A. 7</item>
        <item>A. 1</item>
        <item>A. 11</item>
        <item>A. great</item>
        <item>A. Line 6 generates a compiler error. </item>
        <item>A. 0</item>
        <item>A. 0</item>

    </string-array>

    <string-array name="keysBForOperatorsAndStatements">
        <item>B. false,10</item>
        <item>B. 10, 14</item>
        <item>B. Just Right</item>
        <item>B. 4</item>
        <item>B. true, 20, false</item>
        <item>B. 10</item>
        <item>B. 50</item>
        <item>B. 3</item>
        <item>B. Failure</item>
        <item>B. Failure</item>
        <item>B. 11</item>
        <item>B. 10, 6</item>
        <item>B. 1 2 3 4 5 6 7 8 9 10</item>
        <item>B. 9</item>
        <item>B. 2</item>
        <item>B. 13</item>
        <item>B. greatgood </item>
        <item>B. Line 7 generates a compiler error.</item>
        <item>B. 1</item>
        <item>B. 4</item>

    </string-array>

    <string-array name="keysCForOperatorsAndStatements">
        <item>C. Greater than,11</item>
        <item>C. 10,</item>
        <item>C. Too High</item>
        <item>C. 10</item>
        <item>C. false, 20, true</item>
        <item>C. 11</item>
        <item>C. 90</item>
        <item>C. 5</item>
        <item>C. The code will not compile because of line 4.</item>
        <item>C. The code will not compile because of line 4.</item>
        <item>C. 12</item>
        <item>C. 11, 5</item>
        <item>C. 1 2 3 4 5 6 7 8 9 10 11</item>
        <item>C. 10</item>
        <item>C. 3</item>
        <item>C. 23</item>
        <item>C. The code will not compile because of line 3.</item>
        <item>C. There is no output.</item>
        <item>C. 2</item>
        <item>C. Compilation fails on line 3.</item>

    </string-array>

    <string-array name="keysDForOperatorsAndStatements">
        <item>D. false,11</item>
        <item>D. The code will not compile because of line 7</item>
        <item>D. Compiles but throws a NullPointerException.</item>
        <item>D. 8</item>
        <item>D. false, 20, false</item>
        <item>D. The code will not compile because of line 3.</item>
        <item>D. The code will not compile because of line 4.</item>
        <item>D. 6</item>
        <item>D. The code will not compile because of line 5.</item>
        <item>D. The code will not compile because of line 5.</item>
        <item>D. 15</item>
        <item>D. The code will not compile because of line 3.</item>
        <item>D. The code will not compile because of line 6.</item>
        <item>D. 11</item>
        <item>D. 4</item>
        <item>D. 36</item>
        <item>D. The code will not compile because of line 6.</item>
        <item>D. Empty = false, Brand = null</item>
        <item>D. 3</item>
        <item>D. Compilation fails on line 4.</item>

    </string-array>

    <string-array name="keysEForOperatorsAndStatements">
        <item>E. The code will not compile because of line 4.</item>
        <item>E. The code will not compile because of line 8.</item>
        <item>E. The code will not compile because of line 6.</item>
        <item>E. 7</item>
        <item>E. false, 20, true</item>
        <item>E. The code will not compile because of line 5.</item>
        <item>E. An undefined value</item>
        <item>E. The code will not compile because of line 3.</item>
        <item>E. The code will not compile because of line 3.</item>
        <item>E. The code will not compile because of line 3.</item>
        <item>E. 16</item>
        <item>E. The code will not compile because of line 4.</item>
        <item>E. The code contains an infinite loop and does not terminate.</item>
        <item>E. 15</item>
        <item>E. 6</item>
        <item>E. 50</item>
        <item>E. The code will not compile because of lines 6 and 9. </item>
        <item>E. Empty = false, Brand =</item>
        <item>E. 4</item>
        <item>E. Compilation fails on line 7.</item>

    </string-array>

    <string-array name="keysFForOperatorsAndStatements">
        <item>F. The code will not compile because of line 5.</item>
        <item>F. The code contains an infinite loop and does not terminate</item>
        <item>F. The code will not compile because of line 7</item>
        <item>F. The code will not compile because of line 4</item>
        <item>F. The code will not compile because of line 5.</item>
        <item>F. The code contains an infinite loop and does not terminate.</item>
        <item>F. 100</item>
        <item>F. 10</item>
        <item>F. The code will not compile because of line 6.</item>
        <item>F. The code will not compile because of line 6.</item>
        <item>F. The code will not compile because of line 5</item>
        <item>F. The code contains an infinite loop and does not terminate.</item>
        <item>F. The code will not compile because of line 4.</item>
        <item>F. The code will not compile because of line 8.</item>
        <item>F. The code will not compile because of line 6.</item>
        <item>F. The code will not compile because of line 7.</item>
        <item>F. The code will not compile because of lines 9. </item>
        <item>F. Empty = null, Brand = null</item>
        <item>F. Does not compile</item>
        <item>F. Compilation fails on line 8.</item>
    </string-array>


<!--    Core Java APIs-->
    <string-array name="CoreJavaAPIs">
<!--        1-->
        <item>
            1. What is the result of the following code?
\n7: StringBuilder sb = new StringBuilder();
\n8: sb.append("aaa").insert(1, "bb").insert(4, "ccc");
\n9: System.out.println(sb);
        </item>
<!--        2-->
        <item>
            2. What is the result of the following code?
\n2: String s1 = "java";
\n3: StringBuilder s2 = new StringBuilder("java");
\n4 if (s1 == s2)
\n5: System.out.print("1");
\n6: if (s1.equals(s2))
\n7: System.out.print("2");
        </item>
<!--        3-->
        <item>
            3. What is the result of the following code?
\npublic class Lion {
 \npublic void roar(String roar1, StringBuilder roar2) {
 \nroar1.concat("!!!");
 \nroar2.append("!!!");
 \n}
\npublic static void main(String[] args) {
 \nString roar1 = "roar";
 \nStringBuilder roar2 = new StringBuilder("roar");
 \nnew Lion().roar(roar1, roar2);
\n             System.out.println(roar1 + " " + roar2);
\n} }
        </item>
<!--        4-->
        <item>
            4. What is the result of the following code?
\n3: String s = "purr";
\n4: s.toUpperCase();
\n5: s.trim();
\n6: s.substring(1, 3);
            \n7: s += " two";
\n8: System.out.println(s.length());
        </item>
<!--        5-->
        <item>
            5. What is the result of the following code?
\n4: int total = 0;
\n5: StringBuilder letters = new StringBuilder("abcdefg");
\n6: total += letters.substring(1, 2).length();
\n7: total += letters.substring(6, 6).length();
\n8: total += letters.substring(6, 5).length();
\n9: System.out.println(total);
        </item>
<!--        6-->
        <item>
            6. What is the result of the following code?
\nStringBuilder b = "rumble";
\nb.append(4).deleteCharAt(3).delete(3, b.length() - 1);
\nSystem.out.println(b);
        </item>
<!--        7-->
        <item>
           7. What is the result of the following statements?
\n6: List&#60;String&#62; list = new ArrayList&#60;String&#62;();
\n7: list.add("one");
\n8: list.add("two");
\n9: list.add(7);
\n10: for(String s : list) System.out.print(s);
        </item>
<!--        8-->
        <item>
           8. What is the result of the following statements?
\n3: ArrayList&#60;Integer&#62; values = new ArrayList&#60;&#62;();
\n4: values.add(4);
\n5: values.add(5);
\n6: values.set(1, 6);
\n7: values.remove(0);
\n8: for (Integer v : values) System.out.print(v);
        </item>
<!--        9-->
        <item>
            9. What is the result of the following?
\nint[] random = { 6, -4, 12, 0, -10 };
\nint x = 12;
\nint y = Arrays.binarySearch(random, x);
\nSystem.out.println(y);
        </item>
<!--        10-->
        <item>
           10. What is the result of the following?
\n4: List&#60;Integer&#62; list = Arrays.asList(10, 4, -1, 5);
\n5: Collections.sort(list);
\n6: Integer array[] = list.toArray(new Integer[4]);
\n7: System.out.println(array[0]);
        </item>
<!--        11-->
        <item>
           11. What is the result of the following?
\n6: String [] names = {"Tom", "Dick", "Harry"};
\n7: List&#60;String&#62; list = names.asList();
\n8: list.set(0, "Sue");
\n9: System.out.println(names[0]);
        </item>
<!--        12-->
        <item>
            12. What is the result of the following?
\nList&#60;String&#62; hex = Arrays.asList("30", "8", "3A", "FF");
\nCollections.sort(hex);
\nint x = Collections.binarySearch(hex, "8");
\nint y = Collections.binarySearch(hex, "3A");
\nint z = Collections.binarySearch(hex, "4F");
\nSystem.out.println(x + " " + y + " " + z);
        </item>
<!--        13-->
        <item>
             13. What is the result of the following?
\nList&#60;String&#62; one = new ArrayList&#60;String>();
\none.add("abc");
\nList&#60;String> two = new ArrayList&#60;>();
\ntwo.add("abc");
\nif (one == two)
 \nSystem.out.println("A");
\nelse if (one.equals(two))
 \nSystem.out.println("B");
\nelse
 \nSystem.out.println("C");
        </item>
<!--        14-->
        <item>
            14. What is the output of the following code?
\nLocalDate date = LocalDate.parse("2018-04-30", DateTimeFormatter.ISO_LOCAL_
\nDATE);
\ndate.plusDays(2);
\ndate.plusHours(3);
\nSystem.out.println(date.getYear() + " " + date.getMonth() + " "
\n+ date.getDayOfMonth());
        </item>
<!--        15-->
        <item>
             15. What is the output of the following code?
\nLocalDate date = LocalDate.of(2018, Month.APRIL, 40);
\nSystem.out.println(date.getYear() + " " + date.getMonth() + " "
\n+ date.getDayOfMonth());
        </item>
<!--        16-->
        <item>
            16. What is the output of the following code?
\nLocalDate date = LocalDate.of(2018, Month.APRIL, 30);
\ndate.plusDays(2);
\ndate.plusYears(3);
\nSystem.out.println(date.getYear() + " " + date.getMonth() + " "
\n+ date.getDayOfMonth());
        </item>
<!--        17-->
        <item>
            17. What is the output of the following code?
\nLocalDateTime d = LocalDateTime.of(2015, 5, 10, 11, 22, 33);
\nPeriod p = Period.of(1, 2, 3);
\nd = d.minus(p);
\nDateTimeFormatter f = DateTimeFormatter.ofLocalizedTime(FormatStyle.SHORT);
\nSystem.out.println(d.format(f));
        </item>
<!--        18-->
        <item>
            18. What is the output of the following code?
\nLocalDateTime d = LocalDateTime.of(2015, 5, 10, 11, 22, 33);
\nPeriod p = Period.ofDays(1).ofYears(2);
\nd = d.minus(p);
\nDateTimeFormatter f = DateTimeFormatter.ofLocalizedDateTime(FormatStyle
\n.SHORT);
\nSystem.out.println(f.format(d));
        </item>
    </string-array>

    <string-array name="AnswerDefinitionForCoreJavaAPIs">
<!--        1-->
        <item>
            \n\tAnswer B. This example uses method chaining. After the call to append(), sb contains "aaa".
That result is passed to the first insert() call, which inserts at index 1. At this point
sb contains abbbaa. That result is passed to the final insert(), which inserts at index
4, resulting in abbaccca.
        </item>
<!--        2-->
        <item>
            \n\tAnswer F. The question is trying to distract you into paying attention to logical equality versus
object reference equality. It is hoping you will miss the fact that line 4 does not compile. Java does not allow you to compare String and StringBuilder using ==
        </item>
<!--        3-->
        <item>
            \n\tAnswer B. A String is immutable. Calling concat() returns a new String but does not change
the original. A StringBuilder is mutable. Calling append() adds characters to the
existing character sequence along with returning a reference to the same object.
        </item>
<!--        4-->
        <item>
             \n\tAnswer C. This question is trying to see if you know that String objects are immutable. Line
4 returns "PURR" but the result is ignored and not stored in s. Line 5 returns "purr"
since there is no whitespace present but the result is again ignored. Line 6 returns "ur"
because it starts with index 1 and ends before index 3 using zero-based indexes. The
result is ignored again. Finally, on line 6 something happens. We concatenate four new
characters to s and now have a String of length 8.
        </item>
<!--        5-->
        <item>
             \n\tAnswer E. Line 6 adds 1 to total because substring() includes the starting index but not
the ending index. Line 7 adds 0 to total. Line 8 is a problem: Java does not allow the
indexes to be specified in reverse order and the code throws a StringIndexOutOfBoundsException
        </item>
<!--        6-->
        <item>
            \n\tAnswer F. This is a trick question. The first line does not compile because you cannot
assign a String to a StringBuilder. If that line were StringBuilder b = new
StringBuilder("rumble"), the code would compile and print rum4. Watch out for this
sort of trick on the exam. You could easily spend a minute working out the character
positions for no reason at all.
        </item>
<!--        7-->
        <item>
             \n\tAnswer D. The code does not compile because list is instantiated using generics. Only String
objects can be added to list and 7 is an int.
        </item>
<!--        8-->
        <item>
            \n\tAnswer C. After line 4, values has one element (4). After line 5, values has two elements (4,
5). After line 6, values has two elements (4, 6) because set() does a replace. After line
7, values has only one element (6).
        </item>
<!--        9-->
        <item>
             \n\tAnswer D. The code compiles and runs fine. However, an array must be sorted for binarySearch() to return a meaningful result.
        </item>
<!--        10-->
        <item>
             \n\tAnswer A. Line 4 creates a fixed size array of size 4. Line 5 sorts it. Line 6 converts it back to
an array. The brackets are not in the traditional place, but they are still legal. Line 7
prints the first element, which is now –1.
        </item>
<!--        11-->
        <item>
            \n\tAnswer C. Converting from an array to an ArrayList uses Arrays.asList(names). There is
no asList() method on an array instance. If this code were corrected to compile, the
answer would be option A.
        </item>
<!--        12-->
        <item>
            \n\tAnswer D. After sorting, hex contains [30, 3A, 8, FF]. Remember that numbers sort before
letters and strings sort alphabetically. This makes 30 come before 8. A binary search
correctly finds 8 at index 2 and 3A at index 1. It cannot find 4F but notices it should
be at index 2. The rule when an item isn’t found is to negate that index and subtract 1.
Therefore, we get –2–1, which is –3.
        </item>
<!--        13-->
        <item>
            \n\tAnswer B. The first if statement is false because the variables do not point to the same object.
The second if statement is true because ArrayList implements equality to mean the
same elements in the same order.
        </item>
<!--        14-->
        <item>
             \n\tAnswer D. A LocalDate does not have a time element. Therefore, it has no method to add
hours and the code does not compile.
        </item>
<!--        15-->
        <item>
            \n\tAnswer F. Java throws an exception if invalid date values are passed. There is no 40th day in
April—or any other month for that matter.
        </item>
<!--        16-->
        <item>
             \n\tAnswer B. The date starts out as April 30, 2018. Since dates are immutable and the plus methods have their return values ignored, the result is unchanged. Therefore, option B is
correct.
        </item>
<!--        17-->
        <item>
            \n\tAnswer E. Even though d has both date and time, the formatter only outputs time.
        </item>
<!--        18-->
        <item>
             \n\tAnswer B. Period does not allow chaining. Only the last Period method called counts, so only
the two years are subtracted.
        </item>
    </string-array>

    <string-array name="CorrectAnswersForCoreJavaAPIs">
        <!--    1--><item>B. abbaccca</item>
        <!--    2--><item>F. The code does not compile.</item>
        <!--    3--><item>B. roar roar!!!</item>
        <!--    4--><item>C. 8</item>
        <!--    5--><item>E. An exception is thrown.</item>
        <!--    6--><item>F. The code does not compile.</item>
        <!--    7--><item>D. Compiler error on line 9.</item>
        <!--    8--><item>C. 6</item>
        <!--    9--><item>D. The result is undefined.</item>
        <!--    10--><item>A. –1</item>
        <!--    11--><item>C. Compiler error on line 7.</item>
        <!--    12--><item>D. 2 1 –3</item>
        <!--    13--><item>B. B</item>
        <!--    14--><item>D. The code does not compile.</item>
        <!--    15--><item>F. A runtime exception is thrown.</item>
        <!--    16--><item>B. 2018 APRIL 30</item>
        <!--    17--><item>E. 11:22 AM</item>
        <!--    18--><item>B. 5/10/13 11:22 AM</item>
    </string-array>

    <string-array name="keysAForCoreJavaAPIs">
        <item>A. abbaaccc</item>
        <item>A. 1</item>
        <item>A. roar roar</item>
        <item>A. 2</item>
        <item>A. 1</item>
        <item>A. rum</item>
        <item>A. onetwo</item>
        <item>A. 4</item>
        <item>A. 2</item>
        <item>A. –1</item>
        <item>A. Sue</item>
        <item>A 0 1 –2</item>
        <item>A. A</item>
        <item>A. 2018 APRIL 2</item>
        <item>A. 2018 APRIL 4</item>
        <item>A. 2018 APRIL 2</item>
        <item>A. 3/7/14 11:22 AM</item>
        <item>A. 5/9/13 11:22 AM</item>
    </string-array>

    <string-array name="keysBForCoreJavaAPIs">
        <item>B. abbaccca</item>
        <item>B. 2</item>
        <item>B. roar roar!!!</item>
        <item>B. 4</item>
        <item>B. 2</item>
        <item>B. rum4</item>
        <item>B. onetwo7</item>
        <item>B. 5</item>
        <item>B. 4</item>
        <item>B. 10</item>
        <item>B. Tom</item>
        <item>B. 0 1 –3</item>
        <item>B. B</item>
        <item>B. 2018 APRIL 30</item>
        <item>B. 2018 APRIL 30</item>
        <item>B. 2018 APRIL 30</item>
        <item>B. 5/10/15 11:22 AM</item>
        <item>B. 5/10/13 11:22 AM</item>
    </string-array>

    <string-array name="keysCForCoreJavaAPIs">
        <item>C. bbaaaccc</item>
        <item>C. 12</item>
        <item>C. roar!!! roar</item>
        <item>C. 8</item>
        <item>C. 3</item>
        <item>C. rumb4</item>
        <item>C. onetwo followed by an exception</item>
        <item>C. 6</item>
        <item>C. 6</item>
        <item>C. Compiler error on line 4.</item>
        <item>C. Compiler error on line 7.</item>
        <item>C. 2 1 –2</item>
        <item>C. C</item>
        <item>C. 2018 MAY 2</item>
        <item>C. 2018 MAY 10</item>
        <item>C. 2018 MAY 2</item>
        <item>C. 3/7/14</item>
        <item>C. 5/9/14</item>
    </string-array>

    <string-array name="keysDForCoreJavaAPIs">
        <item>D. bbaaccca</item>
        <item>D. No output is printed.</item>
        <item>D. roar!!! roar!!!</item>
        <item>D. 10</item>
        <item>D. 7</item>
        <item>D. rumble4</item>
        <item>D. Compiler error on line 9.</item>
        <item>D. 46</item>
        <item>D. The result is undefined.</item>
        <item>D. Compiler error on line 5.</item>
        <item>D. Compiler error on line 8.</item>
        <item>D. 2 1 –3</item>
        <item>D. An exception is thrown.</item>
        <item>D. The code does not compile.</item>
        <item>D. Another date.</item>
        <item>D. 2021 APRIL 2</item>
        <item>D. 5/10/15</item>
        <item>D. 5/10/14</item>
    </string-array>

    <string-array name="keysEForCoreJavaAPIs">
        <item>E. An exception is thrown.</item>
        <item>E. An exception is thrown.</item>
        <item>E. An exception is thrown.</item>
        <item>E. An exception is thrown.</item>
        <item>E. An exception is thrown.</item>
        <item>E. An exception is thrown.</item>
        <item>E. Compiler error on line 10.</item>
        <item>E. 45</item>
        <item>E. An exception is thrown.</item>
        <item>E. Compiler error on line 6.</item>
        <item>E. An exception is thrown.</item>
        <item>E. None of the above.</item>
        <item>E. The code does not compile.</item>
        <item>E. A runtime exception is thrown.</item>
        <item>E. The code does not compile.</item>
        <item>E. 2021 APRIL 30</item>
        <item>E. 11:22 AM</item>
        <item>E. The code does not compile</item>
    </string-array>

    <string-array name="keysFForCoreJavaAPIs">
        <item>F. The code does not compile.</item>
        <item>F. The code does not compile.</item>
        <item>F. The code does not compile.</item>
        <item>F. The code does not compile.</item>
        <item>F. The code does not compile.</item>
        <item>F. The code does not compile.</item>
        <item>F. The code does not compile.</item>
        <item>F. An exception is thrown.</item>
        <item>F. The code does not compile.</item>
        <item>F. An exception is thrown.</item>
        <item>F. Compiler error on line 6.</item>
        <item>F. The code doesn’t compile.</item>
        <item>F. ABC </item>
        <item>F. 2018 MAY 30</item>
        <item>F. A runtime exception is thrown.</item>
        <item>F. 2021 MAY 2</item>
        <item>F. The code does not compile.</item>
        <item>F. A runtime exception is thrown.</item>
    </string-array>
    
    
<!--   Methods and Encapsulation -->
    <string-array name="MethodsAndEncapsulation">
<!--        1-->
        <item> 1. What is the output of the following code?
\n1: package rope;
\n2: public class Rope {
\n3: public static int LENGTH = 5;
\n4: static {
\n5: LENGTH = 10;
\n6: }
\n7: public static void swing() {
\n8: System.out.print("swing ");
\n9: }
\n1n0: }\n
            \n1: import rope.*;
\n2: import static rope.Rope.*;
\n3: public class Chimp {
\n4: public static void main(String[] args) {
\n5: Rope.swing();
\n6: new Rope().swing();
\n7: System.out.println(LENGTH);
\n8: }
\n9: }
        </item>
<!--        2-->
        <item>
             2. What is the output of the following code?
\nimport rope.*;
\nimport static rope.Rope.*;
\npublic class RopeSwing {
 \nprivate static Rope rope1 = new Rope();
 \nprivate static Rope rope2 = new Rope();
 \n{
 \nSystem.out.println(rope1.length);
 \n}
 \npublic static void main(String[] args) {
 \nrope1.length = 2;
 \nrope2.length = 8;
 \nSystem.out.println(rope1.length);
 \n}
\n}
\npackage rope;
\npublic class Rope {
 \npublic static int length = 0;
            \n}
        </item>
<!--        3-->
        <item>
            3. How many compiler errors are in the following code?
\n1: public class RopeSwing {
\n2: private static final String leftRope;
\n3: private static final String rightRope;
\n4: private static final String bench;
\n5: private static final String name = "name";
\n6: static {
\n7: leftRope = "left";
\n8: rightRope = "right";
\n9: }
\n10: static {
\n11: name = "name";
\n12: rightRope = "right";
\n13: }
\n14: public static void main(String[] args) {
\n15: bench = "bench";
\n16: }
\n17: }
        </item>
<!--        4-->
        <item>
            4. What is the result of the following statements?
\n1: public class Test {
\n2: public void print(byte x) {
\n3: System.out.print("byte");
\n4: }
\n5: public void print(int x) {
\n6: System.out.print("int");
\n7: }
\n8: public void print(float x) {
\n9: System.out.print("float");
\n10: }
\n11: public void print(Object x) {
\n12: System.out.print("Object");
\n13: }
\n14: public static void main(String[] args) {
\n15: Test t = new Test();
\n16: short s = 123;
\n17: t.print(s);
\n18: t.print(true);
\n19: t.print(6.789);
\n20: }
\n21: }
        </item>
<!--        5-->
        <item>
            5. What is the result of the following program?
\n1: public class Squares {
\n2: public static long square(int x) {
\n3: long y = x * (long) x;
\n4: x = -1;
\n5: return y;
\n6: }
\n7: public static void main(String[] args) {
\n8: int value = 9;
\n9: long result = square(value);
\n10: System.out.println(value);
\n11: } }
        </item>
<!--        6-->
        <item>
             6. Which code can be inserted to have the code print 2?
\npublic class BirdSeed {
 \nprivate int numberBags;
 \nboolean call;
 \npublic BirdSeed() {
 \n// LINE 1
 \ncall = false;
 \n// LINE 2
 \n}
 \npublic BirdSeed(int numberBags) {
 \nthis.numberBags = numberBags;
 \n}
 \npublic static void main(String[] args) {
 \nBirdSeed seed = new BirdSeed();
 \nSystem.out.println(seed.numberBags);
 \n} }
        </item>
<!--        7-->
        <item>
           7. What is the result of the following?
\n1: public class Order {
\n2: static String result = "";
\n3: { result += "c"; }
\n4: static
\n5: { result += "u"; }
\n6: { result += "r"; }
\n7: }
            \n
\n1: public class OrderDriver {
\n2: public static void main(String[] args) {
\n3: System.out.print(Order.result + " ");
\n4: System.out.print(Order.result + " ");
\n5: new Order();
\n6: new Order();
\n7: System.out.print(Order.result + " ");
\n8: }
\n9: }
        </item>
<!--        8-->
        <item>
            8. What is the result of the following?
\n1: public class Order {
\n2: String value = "t";
\n3: { value += "a"; }
\n4: { value += "c"; }
\n5: public Order() {
\n6: value += "b";
\n7: }
\n8: public Order(String s) {
\n9: value += s;
\n10: }
\n11: public static void main(String[] args) {
\n12: Order order = new Order("f");
\n13: order = new Order();
\n14: System.out.println(order.value);
\n15: } }
        </item>
<!--        9-->
        <item>
            9. What is the result of the following class?
\n1: import java.util.function.*;
\n2:
\n3: public class Panda {
\n4: int age;
\n5: public static void main(String[] args) {
\n6: Panda p1 = new Panda();
\n7: p1.age = 1;
\n8: check(p1, p -> p.age &#60; 5);
\n9: }
\n10: private static void check(Panda panda, Predicate&#60;Panda> pred) {
\n11: String result = pred.test(panda) ? "match" : "not match";
\n12: System.out.print(result);
\n13: } }
        </item>
<!--        10-->
        <item>
            10. What is the result of the following code?
\n1: interface Climb {
\n2: boolean isTooHigh(int height, int limit);
\n3: }
\n4:
\n5: public class Climber {
\n6: public static void main(String[] args) {
\n7: check((h, l) -> h.append(l).isEmpty(), 5);
\n8: }
\n9: private static void check(Climb climb, int height) {
\n10: if (climb.isTooHigh(height, 10))
\n11: System.out.println("too high");
\n12: else
\n13: System.out.println("ok");
\n14: }
\n15: }
        </item>

    </string-array>

    <string-array name="AnswerDefinitionForMethodsAndEncapsulations">
<!--        1-->
        <item>
            \n\tAnswer B. Rope runs line 3, setting LENGTH to 5, then immediately after runs the static initializer, which sets it to 10. Line 5 calls the static method normally and prints swing.
Line 6 also calls the static method. Java allows calling a static method through an
instance variable. Line 7 uses the static import on line 2 to reference LENGTH.
        </item>
<!--        2-->
        <item>
            \n\tAnswer D. There are two details to notice in this code. First, note that RopeSwing has an
instance initializer and not a static initializer. Since RopeSwing is never constructed,
the instance initializer does not run. The other detail is that length is static. Changes
from one object update this common static variable.
        </item>
<!--        3-->
        <item>
             \n\tAnswer E. static final variables must be set exactly once, and it must be in the declaration
line or in a static initialization block. Line 4 doesn’t compile because bench is not set
in either of these locations. Line 15 doesn’t compile because final variables are not
allowed to be set after that point. Line 11 doesn’t compile because name is set twice:
once in the declaration and again in the static block. Line 12 doesn’t compile because
rightRope is set twice as well. Both are in static initialization blocks.
        </item>
<!--        4-->
        <item>
             \n\tAnswer E. The argument on line 17 is a short. It can be promoted to an int, so print() on
line 5 is invoked. The argument on line 18 is a boolean. It can be autoboxed to a boolean, so print() on line 11 is invoked. The argument on line 19 is a double. It can
be autoboxed to a double, so print() on line 11 is invoked. Therefore, the output is
intObjectObject and the correct answer is option E.
        </item>
<!--        5-->
        <item>
            \n\tAnswer B. Since Java is pass-by-value and the variable on line 8 never gets reassigned, it stays
as 9. In the method square, x starts as 9. y becomes 81 and then x gets set to –1. Line 9
does set result to 81. However, we are printing out value and that is still 9.
        </item>
<!--        6-->
        <item>
            \n\tAnswer E. Options A and B will not compile because constructors cannot be called without
new. Options C and D will compile but will create a new object rather than setting the
fields in this one. Option F will not compile because this() must be the first line of a
constructor. Option E is correct.
        </item>
<!--        7-->
        <item>
            \n\tAnswer  E. On line 3 of OrderDriver, we refer to Order for the first time. At this point the statics in Order get initialized. In this case, the statics are the static declaration of result
and the static initializer. result is u at this point. On line 4, result is the same
because the static initialization is only run once. On line 5, we create a new Order,
which triggers the instance initializers in the order they appear in the file. Now result
is ucr. Line 6 creates another Order, triggering another set of initializers. Now result
is ucrcr. Notice how the static is on a different line than the initialization code in
lines 4–5 of Order. The exam may try to trick you by formatting the code like this to
confuse you.
        </item>
<!--        8-->
        <item>
            \n\tAnswer A. Line 4 instantiates an Order. Java runs the declarations and instance initializers first
in the order they appear. This sets value to tacf. Line 5 creates another Order and
initializes value to tacb. The object on line 5 is stored in the same variable line 4 used.
This makes the object created on line 4 unreachable. When value is printed, it is the
instance variable in the object created on line 5.
        </item>
<!--        9-->
        <item>
             \n\tAnswer A. This code is correct. Line 8 creates a lambda expression that checks if the age is less
than 5. Since there is only one parameter and it does not specify a type, the parentheses
around the type parameter are optional. Line 10 uses the Predicate interface, which
declares a test() method.
        </item>
<!--        10-->
        <item>
            \n\tAnswer C. The interface takes two int parameters. The code on line 7 attempts to use them as
if one is a StringBuilder. It is tricky to use types in a lambda when they are implicitly
specified. Remember to check the interface for the real type.
        </item>
    </string-array>


    <string-array name="CorrectAnswersForMethodsAndEncapsulation">
        <item>B. swing swing 10</item>
        <item>D. 8</item>
        <item>E. 4</item>
        <item>E. intObjectObject</item>
        <item>B. 9</item>
        <item>E. Replace line 1 with this(2);</item>
        <item>E. u u ucrcr</item>
        <item>A. tacb</item>
        <item>A. match</item>
        <item>C. Compiler error on line 7.</item>
    </string-array>

    <string-array name="keysAForMethodsAndEncapsulation">
        <item>A. swing swing 5</item>
        <item>A. 02</item>
        <item>A. 0</item>
        <item>A. bytefloatObject</item>
        <item>A. -1</item>
        <item>A. Replace line 1 with BirdSeed(2);</item>
        <item>A. curur</item>
        <item>A. tacb</item>
        <item>A. match</item>
        <item>A. ok</item>
    </string-array>

    <string-array name="keysBForMethodsAndEncapsulation">
        <item>B. swing swing 10</item>
        <item>B. 08</item>
        <item>B. 1</item>
        <item>B. intfloatObject</item>
        <item>B. 9</item>
        <item>B. Replace line 2 with BirdSeed(2);</item>
        <item>B. ucrcr</item>
        <item>B. tacf</item>
        <item>B. not match</item>
        <item>B. too high</item>
    </string-array>

    <string-array name="keysCForMethodsAndEncapsulation">
        <item>C. Compiler error on line 2 of Chimp.</item>
        <item>C. 2</item>
        <item>C. 2</item>
        <item>C. byteObjectfloat</item>
        <item>C. 81</item>
        <item>C. Replace line 1 with new BirdSeed(2);</item>
        <item>C. u ucrcr</item>
        <item>C. tacbf</item>
        <item>C. Compiler error on line 8.</item>
        <item>C. Compiler error on line 7.</item>
    </string-array>

    <string-array name="keysDForMethodsAndEncapsulation">
        <item>D. Compiler error on line 5 of Chimp.</item>
        <item>D. 8</item>
        <item>D. 3</item>
        <item>D. intObjectfloat</item>
        <item>D. Compiler error on line 9.</item>
        <item>D. Replace line 2 with new BirdSeed(2);</item>
        <item>D. u u curcur</item>
        <item>D. tacfb</item>
        <item>D. Compiler error on line 10.</item>
        <item>D. Compiler error on line 10.</item>
    </string-array>

    <string-array name="keysEForMethodsAndEncapsulation">
        <item>E. Compiler error on line 6 of Chimp.</item>
        <item>E. The code does not compile.</item>
        <item>E. 4</item>
        <item>E. intObjectObject</item>
        <item>E. Compiler error on a different line.</item>
        <item>E. Replace line 1 with this(2);</item>
        <item>E. u u ucrcr</item>
        <item>E. tacftacb</item>
        <item>E. Compiler error on line 11.</item>
        <item>E. Compiler error on a different line.</item>
    </string-array>

    <string-array name="keysFForMethodsAndEncapsulation">
        <item>F. Compiler error on line 7 of Chimp.</item>
        <item>F. An exception is thrown.</item>
        <item>F. 5</item>
        <item>F. byteObjectObject</item>
        <item>F. does not compile</item>
        <item>F. Replace line 2 with this(2);</item>
        <item>F. ur ur urc</item>
        <item>F. The code does not compile.</item>
        <item>F. A runtime exception is thrown.</item>
        <item>F. A runtime exception is thrown.</item>
    </string-array>


    <!--   Class Design -->
    <string-array name="ClassDesign">
    <!--        1-->
        <item>
            1. What is the output of the following code?
\n1: class Mammal {
\n2: public Mammal(int age) {
\n3: System.out.print("Mammal");
\n4: }
\n5: }
\n6: public class Platypus extends Mammal {
\n7: public Platypus() {
\n8: System.out.print("Platypus");
\n9: }
\n10: public static void main(String[] args) {
\n11: new Mammal(5);
\n12: }
\n13: }
        </item>
<!--        2-->
        <item>
            2. Choose the correct statement about the following code:
\n1: interface HasExoskeleton {
\n2: abstract int getNumberOfSections();
\n3: }
\n4: abstract class Insect implements HasExoskeleton {
\n5: abstract int getNumberOfLegs();
\n6: }
\n7: public class Beetle extends Insect {
\n8: int getNumberOfLegs() { return 6; }
\n9: }
        </item>
<!--        3-->
        <item>
            3. Choose the correct statement about the following code:
\n1: public interface Herbivore {
\n2: int amount = 10;
\n3: public static void eatGrass();
\n4: public int chew() {
\n5: return 13;
\n6: }
\n7: }
        </item>
<!--        4-->
        <item>
           4. Choose the correct statement about the following code:
\n1: public interface CanFly {
\n2: void fly();
\n3: }
\n4: interface HasWings {
\n5: public abstract Object getWindSpan();
\n6: }
\n7: abstract class Falcon implements CanFly, HasWings {
\n8: }
        </item>
<!--        5-->
        <item>
            5. What is the output of the following code?
\n1: interface Nocturnal {
\n2: default boolean isBlind() { return true; }
\n3: }
\n4: public class Owl implements Nocturnal {
\n5: public boolean isBlind() { return false; }
\n6: public static void main(String[] args) {
\n7: Nocturnal nocturnal = (Nocturnal)new Owl();
\n8: System.out.println(nocturnal.isBlind());
\n9: }
\n10: }
        </item>
<!--        6-->
        <item>
           6. What is the output of the following code?
\n1: class Arthropod
\n2: public void printName(double input) { System.out
 .print("Arthropod"); }
\n3: }
\n4: public class Spider extends Arthropod {
\n5: public void printName(int input) { System.out.print("Spider"); }
\n6: public static void main(String[] args) {
\n7: Spider spider = new Spider();
\n8: spider.printName(4);
\n9: spider.printName(9.0);
\n10: }
\n11: }
        </item>
<!--        7-->
        <item>
            7. What is the output of the following code?
\n1: abstract class Reptile {
\n2: public final void layEggs() { System.out.println("Reptile laying eggs");
 \n}
\n3: public static void main(String[] args) {
\n4: Reptile reptile = new Lizard();
\n5: reptile.layEggs();
\n6: }
\n7: }
\n8: public class Lizard extends Reptile {
\n9: public void layEggs() { System.out.println("Lizard laying eggs"); }
\n10: }
        </item>
<!--        8-->
        <item>
            8. What is the output of the following code?
\n1: public abstract class Whale {
\n2: public abstract void dive() {};
\n3: public static void main(String[] args) {
\n4: Whale whale = new Orca();
\n5: whale.dive();
\n6: }
\n7: }
\n8: class Orca extends Whale {
\n9: public void dive(int depth) { System.out.println("Orca diving"); }
\n10: }
        </item>
<!--        9-->
        <item>
             9. What is the result of the following code?
\n1: public abstract class Bird {
\n2: private void fly() { System.out.println("Bird is flying"); }
\n3: public static void main(String[] args) {
\n4: Bird bird = new Pelican();
\n5: bird.fly();
\n6: }
\n7: }
\n8: class Pelican extends Bird {
\n9: protected void fly() { System.out.println("Pelican is flying"); }
\n10: }
        </item>
    </string-array>

    <string-array name="AnswerDefinitionForClassDesign">
<!--        1-->
        <item>
            \n\tAnswer  E. The code will not compile because the parent class Mammal doesn’t define a no-argument constructor, so the first line of a Platypus constructor should be an explicit call
to super(int age). If there was such a call, then the output would be MammalPlatypus,
since the super constructor is executed before the child constructor.
        </item>
<!--        2-->
        <item>
            \n\tAnswer D. The code fails to compile because Beetle, the first concrete subclass, doesn’t implement getNumberOfSections(), which is inherited as an abstract method; therefore,
option D is correct. Option B is incorrect because there is nothing wrong with this
interface method definition. Option C is incorrect because an abstract class is not
required to implement any abstract methods, including those inherited from an interface. Option E is incorrect because the code fails at compilation-time.
        </item>
<!--        3-->
        <item>
            \n\tAnswer F. The interface variable amount is correctly declared, with public and static being
assumed and automatically inserted by the compiler, so option B is incorrect. The
method declaration for eatGrass() on line 3 is incorrect because the method has been
marked as static but no method body has been provided. The method declaration for
chew() on line 4 is also incorrect, since an interface method that provides a body must
be marked as default or static explicitly. Therefore, option F is the correct answer
since this code contains two compile-time errors.
        </item>
<!--        4-->
        <item>
            \n\tAnswer A. Although the definition of methods on lines 2 and 5 vary, both will be converted to
public abstract by the compiler. Line 4 is fine, because an interface can have public or default access. Finally, the class Falcon doesn’t need to implement the interface
methods because it is marked as abstract. Therefore, the code will compile without
issue.
        </item>
<!--        5-->
        <item>
            \n\tAnswer B. This code compiles and runs without issue, outputting false, so option B is the
correct answer. The first declaration of isBlind() is as a default interface method,
assumed public. The second declaration of isBlind() correctly overrides the default
interface method. Finally, the newly created Owl instance may be automatically cast to
a Nocturnal reference without an explicit cast, although adding it doesn’t break the
code.
        </item>
<!--        6-->
        <item>
             \n\tAnswer A. The code compiles and runs without issue, so options E and F are incorrect. The
printName() method is an overload in Spider, not an override, so both methods may
be called. The call on line 8 references the version that takes an int as input defined
in the Spider class, and the call on line 9 references the version in the Arthropod class
that takes a double. Therefore, SpiderArthropod is output and option A is the correct
answer.
        </item>
<!--        7-->
        <item>
             \n\tAnswer E. The code does not compile, so options A and B are incorrect. The issue with line 9 is
that layEggs() is marked as final in the superclass Reptile, which means it cannot be
overridden. There are no errors on any other lines, so options C and D are incorrect.
        </item>
<!--        8-->
        <item>
            \n\tAnswer B. This may look like a complex question, but it is actually quite easy. Line 2 contains
an invalid definition of an abstract method. Abstract methods cannot contain a body,
so the code will not compile and option B is the correct answer. If the body {} was
removed from line 2, the code would still not compile, although it would be line 8 that
would throw the compilation error. Since dive() in Whale is abstract and Orca extends
Whale, then it must implement an overridden version of dive(). The method on line
9 is an overloaded version of dive(), not an overridden version, so Orca is an invalid
subclass and will not compile.
        </item>
<!--        9-->
        <item>
            \n\tAnswer A. The code compiles and runs without issue, so options C, D, and E are incorrect.
The trick here is that the method fly() is marked as private in the parent class Bird,
which means it may only be hidden, not overridden. With hidden methods, the specific
method used depends on where it is referenced. Since it is referenced within the Bird
class, the method declared on line 2 was used, and option A is correct. Alternatively,
if the method was referenced within the Pelican class, or if the method in the parent
class was marked as protected and overridden in the subclass, then the method on line
9 would have been used.
        </item>
    </string-array>

    <string-array name="CorrectAnswersForForClassDesign">
        <item>E. The code will not compile because of line 8.</item>
        <item>D. The code will not compile because of line 7.</item>
        <item>F. The code will not compile because of lines 3 and 4.</item>
        <item>A. It compiles without issue.</item>
        <item>B. false</item>
        <item>A. SpiderArthropod</item>
        <item>E. The code will not compile because of line 9.</item>
        <item>B. The code will not compile because of line 2.</item>
        <item>A. Bird is flying</item>
    </string-array>


    <string-array name="keysAForClassDesign">
        <item>A. Platypus</item>
        <item>A. It compiles and runs without issue.</item>
        <item>A. It compiles and runs without issue.</item>
        <item>A. It compiles without issue.</item>
        <item>A. true</item>
        <item>A. SpiderArthropod</item>
        <item>A. Reptile laying eggs</item>
        <item>A. Orca diving</item>
        <item>A. Bird is flying</item>

    </string-array>

    <string-array name="keysBForClassDesign">
        <item>B. Mammal</item>
        <item>B. The code will not compile because of line 2.</item>
        <item>B. The code will not compile because of line 2.</item>
        <item>B. The code will not compile because of line 2.</item>
        <item>B. false</item>
        <item>B. ArthropodSpider</item>
        <item>B. Lizard laying eggs</item>
        <item>B. The code will not compile because of line 2.</item>
        <item>B. Pelican is flying </item>

    </string-array>


    <string-array name="keysCForClassDesign">
        <item>C. PlatypusMammal</item>
        <item>C. The code will not compile because of line 4.</item>
        <item>C. The code will not compile because of line 3.</item>
        <item>C. The code will not compile because of line 4.</item>
        <item>C. The code will not compile because of line 2.</item>
        <item>C. SpiderSpider</item>
        <item>C. The code will not compile because of line 4.</item>
        <item>C. The code will not compile because of line 8.</item>
        <item>C. The code will not compile because of line 4.</item>

    </string-array>


    <string-array name="keysDForClassDesign">
        <item>D. MammalPlatypus</item>
        <item>D. The code will not compile because of line 7.</item>
        <item>D. The code will not compile because of line 4.</item>
        <item>D. The code will not compile because of line 5.</item>
        <item>D. The code will not compile because of line 5.</item>
        <item>D. ArthropodArthropod</item>
        <item>D. The code will not compile because of line 5.</item>
        <item>D. The code will not compile because of line 9.</item>
        <item>D. The code will not compile because of line 5.</item>
    </string-array>


    <string-array name="keysEForClassDesign">
        <item>E. The code will not compile because of line 8.</item>
        <item>E. It compiles but throws an exception at runtime.</item>
        <item>E. The code will not compile because of lines 2 and 3.</item>
        <item>E. The code will not compile because of lines 2 and 5.</item>
        <item>E. The code will not compile because of line 7.</item>
        <item>E. The code will not compile because of line 5.</item>
        <item>E. The code will not compile because of line 9.</item>
        <item>E. The output cannot be determined from the code provided.</item>
        <item>E. The code will not compile because of line 9. </item>
    </string-array>


    <string-array name="keysFForClassDesign">
        <item>F. The code will not compile because of line 11</item>
        <item>F. The code will not compile because of line 8</item>
        <item>F. The code will not compile because of lines 3 and 4.</item>
        <item>F. The code will not compile because of lines 7.</item>
        <item>F. The code will not compile because of line 8.</item>
        <item>F. The code will not compile because of line 9.</item>
        <item>F. The code will not compile because of line 2.</item>
        <item>F. The code will not compile because of line 4.</item>
        <item>F. The code will not compile because of line 2.</item>

    </string-array>

    <!--   Exceptions -->
    <string-array name="Exceptions">
    <!--        1-->
        <item>
           1. When are you required to use a finally block in a regular try statement (not a try-with-resources)?
        </item>
<!--        2-->
        <item>
             2. Which exception will the following throw?
\nObject obj = new Integer(3);
\nString str = (String) obj;
\nSystem.out.println(str);
        </item>
<!--        3-->
        <item>
            3. What will happen if you add the statement System.out.println(5 / 0); to a working
main() method?
        </item>
<!--        4-->
        <item>
            4. What is printed besides the stack trace caused by the NullPointerException from line 16?
            \n\n1: public class DoSomething {
\n2: public void go() {
\n3: System.out.print("A");
\n4: try {
\n5: stop();
\n6: } catch (ArithmeticException e) {
\n7: System.out.print("B");
\n8: } finally {
\n9: System.out.print("C");
\n10: }
\n11: System.out.print("D");
\n12: }
\n13: public void stop() {
\n14: System.out.print("E");
\n15: Object x = null;
\n16: x.toString();
\n17: System.out.print("F");
\n18: }
\n19: public static void main(String[] args) {
\n20: new DoSomething().go();
\n21: }
\n22: }
        </item>
<!--        5-->
        <item>
           5. What is the output of the following snippet, assuming a and b are both 0?
\n3: try {
\n4: return a / b;
\n5: } catch (RuntimeException e) {
\n6: return -1;
\n7: } catch (ArithmeticException e) {
\n8: return 0;
\n9: } finally {
\n10: System.out.print("done");
\n11: }
        </item>
<!--        6-->
        <item>
           6. What is the output of the following program?
\n1: public class Laptop {
\n2: public void start() {
\n3: try {
\n4: System.out.print("Starting up ");
\n5: throw new Exception();
\n6: } catch (Exception e) {
\n7: System.out.print("Problem ");
\n8: System.exit(0);
\n9: } finally {
\n10: System.out.print("Shutting down ");
\n11: }
\n12: }
\n13: public static void main(String[] args) {
\n14: new Laptop().start();
\n15: } }
        </item>
<!--        7-->
        <item>
            7. What is the output of the following program?
\n1: public class Dog {
\n2: public String name;
\n3: public void parseName() {
\n4: System.out.print("1");
\n5: try {
\n6: System.out.print("2");
\n7: int x = Integer.parseInt(name);
\n8: System.out.print("3");
\n9: } catch (NumberFormatException e) {
\n10: System.out.print("4");
\n11: }
\n12: }
\n13: public static void main(String[] args) {
\n14: Dog leroy = new Dog();
\n15: leroy.name = "Leroy";
\n16: leroy.parseName();
\n17: System.out.print("5");
\n18: } }
        </item>
<!--        8-->
        <item>
            8. What is the output of the following program?
\n1: public class Cat {
\n2: public String name;
\n3: public void parseName() {
\n4: System.out.print("1");
\n5: try {
\n6: System.out.print("2");
\n7: int x = Integer.parseInt(name);
\n8: System.out.print("3");
\n9: } catch (NullPointerException e) {
\n10: System.out.print("4");
\n11: }
\n12: System.out.print("5");
\n13: }
\n14: public static void main(String[] args) {
\n15: Cat leo = new Cat();
\n16: leo.name = "Leo";
\n17: leo.parseName();
\n18: System.out.print("6");
\n19: }
\n20: }
        </item>
<!--        9-->
        <item>
            9. Which scenario is the best use of an exception?
        </item>

    </string-array>

    
    <string-array name="AnswerDefinitionForExceptions">
<!--        1-->
        <item>
            \n\tAnswer C. A try statement is required to have a catch clause and/or finally clause. If it goes
the catch route, it is allowed to have multiple catch clauses.
        </item>
<!--        2-->
        <item>
            \n\tAnswer B. The second line tries to cast an Integer to a String. Since String does not extend
Integer, this is not allowed and a ClassCastException is thrown.
        </item>
<!--        3-->
        <item>
            \n\tAnswer C. The compiler tests the operation for a valid type but not a valid result, so the code
will still compile and run. At runtime, evaluation of the parameter takes place before
passing it to the print() method, so an ArithmeticException object is raised.
        </item>
<!--        4-->
        <item>
            \n\tAnswer C. The main() method invokes go and A is printed on line 3. The stop method is
invoked and E is printed on line 14. Line 16 throws a NullPointerException, so stop
immediately ends and line 17 doesn’t execute. The exception isn’t caught in go, so the
go method ends as well, but not before its finally block executes and C is printed on
line 9. Because main() doesn’t catch the exception, the stack trace displays and no further output occurs, so AEC was the output printed before the stack trace.
        </item>
<!--        5-->
        <item>
            \n\tAnswer E. The order of catch blocks is important because they’re checked in the order they
appear after the try block. Because ArithmeticException is a child class of RuntimeException, the catch block on line 7 is unreachable. (If an ArithmeticException is
thrown in try try block, it will be caught on line 5.) Line 7 generates a compiler error
because it is unreachable code.
        </item>
<!--        6-->
        <item>
            \n\tAnswer B. The main() method invokes start on a new Laptop object. Line 4 prints Starting
up; then line 5 throws an Exception. Line 6 catches the exception, line 7 prints
Problem, and then line 8 calls System.exit, which terminates the JVM. The finally
block does not execute because the JVM is no longer running.
        </item>
<!--        7-->
        <item>
            \n\tAnswer E. The parseName method is invoked within main() on a new Dog object. Line 4 prints
1. The try block executes and 2 is printed. Line 7 throws a NumberFormatException, so
line 8 does not execute. The exception is caught on line 9, and line 10 prints 4. Because the
exception is handled, execution resumes normally. parseName runs to completion, and
line 17 executes, printing 5. That’s the end of the program, so the output is 1245.
        </item>
<!--        8-->
        <item>
            \n\tAnswer A. The parseName method is invoked on a new Cat object. Line 4 prints 1. The try
block is entered, and line 6 prints 2. Line 7 throws a NumberFormatException. It isn’t
caught, so parseName ends. main() doesn’t catch the exception either, so the program
terminates and the stack trace for the NumberFormatException is printed.
        </item>
<!--        9-->
        <item>
             \n\tAnswer B. IllegalArgumentException is used when an unexpected parameter is passed into a
method. Option A is incorrect because returning null or -1 is a common return value
for this scenario. Option D is incorrect because a for loop is typically used for this
scenario. Option E is incorrect because you should find out how to code the method
and not leave it for the unsuspecting programmer who calls your method. Option C is
incorrect because you should run!
        </item>
    </string-array>

    <string-array name="CorrectAnswersForForExceptions">
        <!--1--> <item>C. When there are no catch blocks in a try statement.</item>
        <!--2--> <item>B. ClassCastException</item>
        <!--3--> <item>C. It will run and throw an ArithmeticException.</item>
        <!--4--> <item>C. AEC</item>
        <!--5--> <item>E. The code does not compile.</item>
        <!--6--> <item>B. Starting up Problem</item>
        <!--7--> <item>E. 1245</item>
        <!--8--> <item>A. 12, followed by a stack trace for a NumberFormatException</item>
        <!--9--> <item>B. An unexpected parameter is passed into a method.</item>
    </string-array>

    <string-array name="keysAForExceptions">
        <item>A. Never</item>
        <item>A. ArrayIndexOutOfBoundsException</item>
        <item>A. It will not compile</item>
        <item>A. AE</item>
        <item>A. -1</item>
        <item>A. Starting up</item>
        <item>A. 12</item>
        <item>A. 12, followed by a stack trace for a NumberFormatException</item>
        <item>A. An element is not found when searching a list.</item>
    </string-array>

    <string-array name="keysBForExceptions">
        <item>B. When the program code does not terminate on its own.</item>
        <item>B. ClassCastException</item>
        <item>B. It will not run.</item>
        <item>B. AEBCD</item>
        <item>B. 0</item>
        <item>B. Starting up Problem</item>
        <item>B. 1234</item>
        <item>B. 124, followed by a stack trace for a NumberFormatException</item>
        <item>B. An unexpected parameter is passed into a method.</item>
    </string-array>

    <string-array name="keysCForExceptions">
        <item>C. When there are no catch blocks in a try statement.</item>
        <item>C. IllegalArgumentException</item>
        <item>C. It will run and throw an ArithmeticException.</item>
        <item>C. AEC</item>
        <item>C. done-1</item>
        <item>C. Starting up Problem Shutting down</item>
        <item>C. 1235</item>
        <item>C. 12456</item>
        <item>C. The computer caught fire.</item>
    </string-array>

    <string-array name="keysDForExceptions">
        <item>D. When there is exactly one catch block in a try statement.</item>
        <item>D. NumberFormatException</item>
        <item>D. It will run and throw an IllegalArgumentException.</item>
        <item>D. AECD</item>
        <item>D. done0</item>
        <item>D. Starting up Shutting down.</item>
        <item>D. 124</item>
        <item>D. An uncaught exception is thrown.</item>
        <item>D. You want to loop through a list</item>
    </string-array>

    <string-array name="keysEForExceptions">
        <item>E. When there are two or more catch blocks in a try statement.</item>
        <item>E. None of the above.</item>
        <item>E. None of the above.</item>
        <item>E. No output appears other than the stack trace</item>
        <item>E. The code does not compile.</item>
        <item>E. The code does not compile</item>
        <item>E. 1245</item>
        <item>E. 1256, followed by a stack trace for a NumberFormatException</item>
        <item>E. You don’t know how to code a method.</item>
    </string-array>

    <string-array name="keysFForExceptions">
        <item>F. ~ ~</item>
        <item>F. ~ ~</item>
        <item>F. ~ ~</item>
        <item>F. ~ ~</item>
        <item>F. An uncaught exception is thrown.</item>
        <item>F. An uncaught exception is thrown.</item>
        <item>F. The code does not compile.</item>
        <item>F. The code does not compile.</item>
        <item>F. ~ ~</item>
    </string-array>



<!--*************************** OCP *******************************-->

    <string-array name="AssessmentTestOSP">
<!--        1-->
        <item>
            1. What is the result of the following program?
\n\n1: public abstract class Message {
\n2: public String recipient;
\n3: public abstract final void sendMessage();
\n4: public static void main(String[] args) {
\n5: Message m = new TextMessage();
\n6: m.recipient = "1234567890";
\n7: m.sendMessage();
\n8: }
\n9: static class TextMessage extends Message {
\n10: public final void sendMessage() {
\n11: System.out.println("Text message to " + recipient);
\n12: } } }
        </item>
<!--        2-->
        <item>
            2. What is the result of the following class?
\n\n1: public class Box&#60;T> {
\n2: T value;
\n3:
\n4: public Box(T value) {
\n5: this.value = value;
\n6: }
\n7: public T getValue() {
\n8: return value;
\n9: }
\n10: public static void main(String[] args) {
\n11: Box&#60;String> one = new Box&#60;String>("a string");
\n12: Box&#60;Integer> two = new Box&#60;>(123);
\n13: System.out.print(one.getValue());
\n14: System.out.print(two.getValue());
\n15: } }
        </item>
<!--        3-->
        <item>
            3. What is the result of executing the following code snippet?
\n\nList&#60;Integer> source = new ArrayList&#60;>(Arrays.asList(1,2,3,4));
\nList&#60;Integer> fish = new CopyOnWriteArrayList&#60;>(source);
\nList&#60;Integer> mammals = Collections.synchronizedList(source);
\nSet&#60;Integer> birds = new ConcurrentSkipListSet&#60;>();
\nbirds.addAll(source);
\nsynchronized(new Integer(10)) {
 \nfor(Integer f: fish) fish.add(4); // c1
\nfor(Integer m: mammals) mammals.add(4); // c2
 \nfor(Integer b: birds) birds.add(5); // c3
 \nSystem.out.println(fish.size()+" "+mammals.size()+" "+birds.size());
\n}
        </item>
<!--        4-->
        <item>
            4. Assuming the current directory /bats/day and all of the files and directories referenced
here exist and are available within the file system, what is the result of executing the following code?
\n\nPath path1 = Paths.get("/bats/night","../").resolve(Paths.get(
"./sleep.txt")).normalize();
\n\nPath path2 = new File("../sleep.txt").toPath().toRealPath();
\n\nSystem.out.print(Files.isSameFile(path1,path2));
\nSystem.out.print(" "+path1.equals(path2));
        </item>
<!--        5-->
        <item>
            5. Which of the following statements is true when the code is run with java AssertDemo?
\n\n1: public class AssertDemo {
\n2: public static void main(String [] args) {
\n3: Integer x = 10;
\n4: x++;
\n5: assert x == null &amp;&amp; x >= 0;
\n6: System.out.println(x);
\n7: }
\n8: }
        </item>
<!--        6-->
        <item>
            6. Suppose that we have the following property files and code. Which bundle is used on lines 7 and 8, respectively?
\n\nDolphins.properties
\nname=The Dolphin
\nage=0
\nDolphins_fr.properties
\nname=Dolly
\nDolphins_fr_CA.properties
\nname=Dolly
\nage=4
\n\n5: Locale fr = new Locale("fr");
\n6: ResourceBundle b = ResourceBundle.getBundle("Dolphins", fr);
\n7: b.getString("name");
\n8: b.getString("age");
        </item>
<!--        7-->
        <item>
            7. How many compilation issues are in the following code?
\n\n1: public class Compiles {
\n2: class RainException extends Exception {}
\n3:
\n4: public static void main(String[] args) {
\n5: try(Scanner s = new Scanner("rain"); String line = "";) {
\n6: if (s.nextLine().equals("rain"))
\n7: throw new RainException();
\n8: } finally {
\n9: s.close();
\n10: } } }
        </item>
<!--        8-->
        <item>
            8. What is the result of the following code?
\n\n1: public class VisitPark {
\n2: enum AnimalsInPark {
\n3: SQUIRREL, CHIPMUNK, SPARROW;
\n4: }
\n5: public static void main(String[] args) {
\n6: AnimalsInPark[] animals = AnimalsInPark.values();
\n7: System.out.println(animals[1]);
\n8: } }
        </item>
<!--        9-->
        <item>
            9. Which of the answer choices is printed out by the following code?
\n\nString d = Duration.ofDays(1).toString();
\nString p = Period.ofDays(1).toString();
\nboolean b1 = d == p;
\nboolean b2 = d.equals(p);
\nSystem.out.println(b1 + " " + b2);
        </item>
<!--        10-->
        <item>
            10. Assume that today is June 1, 2016. What is the result of the following?
\n\nStream&#60;LocalDate> s = Stream.of(LocalDate.now());
\nUnaryOperator&#60;LocalDate> u = l -> l;
\ns.filter(l -> l != null).map(u).peek(System.out::println);
        </item>
    </string-array>


    <string-array name="AnswerDefinitionForAssessmentTestOSP">
<!--        1-->
        <item>
            \n\tAnswer D. The code does not compile because a method is not allowed to be both abstract and
final. If final were removed, the answer would be B. An abstract class may contain an
abstract method. A static nested class may extend other classes.
        </item>
<!--        2-->
        <item>
            2. E. This class is a proper use of generics. Box uses a generic type named T. On line 11, the
generic type is String. On line 12 the generic type is Integer. Line 12 also uses the diamond operator.
        </item>
<!--        3-->
        <item>
            \n\tAnswer F. The code compiles without issue, so D is incorrect. The code throws a
ConcurrentModificationException at runtime on line c2, because mammals is a synchronized list and not a concurrent one. Therefore, it is not safe to be used inside an iterator,
and F is the correct answer. Note that if line c2 were removed, the rest of the code would
run without throwing an exception, outputting 8 4 5.
        </item>
<!--        4-->
        <item>
            \n\tAnswer A. The code compiles and runs without issue, so E and F are incorrect. For this question,
it helps if you resolve each path to a simplified form component before answering it. The
path1 variable simplifies to /bats/sleep.txt after the Path operations have been applied.
The path2 variable using the current directory of /bats/day is assigned a path value of /
bats/sleep.txt. Since the file Path objects represent the same path within the file system,
they will return true for both equals() and isSameFile(), so A is the correct answer and
B, C, and D are incorrect.
        </item>
<!--        5-->
        <item>
            \n\tAnswer F. The code compiles due to autoboxing. The command line does not enable assertions, so
D cannot happen. Line 6 executes and prints out 11, so the answer is F.
        </item>
<!--        6-->
        <item>
            \n\tAnswer D. Java will use Dolphins_fr.properties as the matching resource bundle on line 6
because it is an exact match on the language. Line 7 finds a matching key in this file. Line 8
does not find a match in that file, and therefore it has to look higher up in the hierarchy.
        </item>
<!--        7-->
        <item>
           \n\tAnswer D. Line 5 is incorrect because String does not implement AutoCloseable. Not all
objects can be declared in a try-with-resources try clause. Line 7 is incorrect because
RainException is a checked exception and is not declared or handled. Line 9 is incorrect
because s is declared in the try clause and is therefore out of scope for the finally block.
        </item>
<!--        8-->
        <item>
            \n\tAnswer A. The code compiles. An enum may be an inner class. The values() method returns an
array with the enum values in the order in which they were declared in the code. Since Java
uses 0-based indexes, the answer is A.
        </item>
<!--        9-->
        <item>
            \n\tAnswer A. d is the String P1D and p is the String PT24H. They are neither the same object nor the same value. Remember that Duration uses hours/minutes/seconds and Period uses
years/months/days for measures.
        </item>
<!--        10-->
        <item>
            \n\tAnswer C. There is no terminal operation. Since the intermediate operations use lazy evaluation,
they wait for a terminal operation to run. Since there is no terminal operation, peek()
never runs.
        </item>
    </string-array>


    <string-array name="CorrectAnswersForAssessmentTestOSP">
        <item>D. A compiler error occurs on line 3.</item>
        <item>E. a string123</item>
        <item>F. It compiles but throws an exception at runtime on line c2</item>
        <item>A. true true</item>
        <item>F. The output is 11.</item>
        <item>D. Dolphins_fr.properties and Dolphins.properties</item>
        <item>D. 3</item>
        <item>A. CHIPMUNK</item>
        <item>A. false false</item>
        <item>C. There is no output</item>
    </string-array>

    <string-array name="keysAForAssessmentTestOSP">
        <item>A. Text message to null.</item>
        <item>A. Compiler error on line 1.</item>
        <item>A. It outputs 4 8 5.</item>
        <item>A. true true</item>
        <item>A. Line 3 generates a compiler error.</item>
        <item>A. Dolphins.properties and Dolphins.properties</item>
        <item>A. 0</item>
        <item>A. CHIPMUNK</item>
        <item>A. false false</item>
        <item>A. 2016–05–01</item>
    </string-array>


    <string-array name="keysBForAssessmentTestOSP">
        <item>B. Text message to 1234567890.</item>
        <item>B. Compiler error on line 2.</item>
        <item>B. It outputs 8 4 5.</item>
        <item>B. false false</item>
        <item>B. Line 4 generates a compiler error</item>
        <item>B. Dolphins.properties and Dolphins_fr.properties</item>
        <item>B. 1</item>
        <item>B. SQUIRREL</item>
        <item>B. false true</item>
        <item>B. B. 2016–06–01</item>
    </string-array>


    <string-array name="keysCForAssessmentTestOSP">
        <item>C. A compiler error occurs on line 1.</item>
        <item>C. Compiler error on line 11.</item>
        <item>C. It outputs 8 8 8</item>
        <item>C. true false</item>
        <item>C. Line 5 generates a compiler error.</item>
        <item>C. Dolphins_fr.properties and Dolphins_fr.properties</item>
        <item>C. 2</item>
        <item>C. The code compiles, but the output is indeterminate.</item>
        <item>C. true false</item>
        <item>C. There is no output</item>
    </string-array>


    <string-array name="keysDForAssessmentTestOSP">
        <item>D. A compiler error occurs on line 3.</item>
        <item>D. Compiler error on line 12.</item>
        <item>D. The code does not compile.</item>
        <item>D. false true</item>
        <item>D. Line 5 throws an AssertionError at runtime.</item>
        <item>D. Dolphins_fr.properties and Dolphins.properties</item>
        <item>D. 3</item>
        <item>D. A compiler error occurs on line 2.</item>
        <item>D. true true</item>
        <item>D. The output is something other than 2016–05–01 or 2016–06–01.</item>
    </string-array>


    <string-array name="keysEForAssessmentTestOSP">
        <item>E. A compiler error occurs on line 7.</item>
        <item>E. a string123</item>
        <item>E. It compiles but throws an exception at runtime on line c1.</item>
        <item>E. The code does not compile</item>
        <item>E. The output is 10.</item>
        <item>E. Dolphins_fr.properties and Dolphins_fr_CA.properties</item>
        <item>E. 4</item>
        <item>E. A compiler error occurs on line 6.</item>
        <item>E. The code does not compile.</item>
        <item>E. The code does not compile.</item>
    </string-array>


    <string-array name="keysFForAssessmentTestOSP">
        <item>F. A compiler error occurs on another line.</item>
        <item>F. An exception is thrown.</item>
        <item>F. It compiles but throws an exception at runtime on line c2</item>
        <item>F. The code compiles but throws an exception at runtime.</item>
        <item>F. The output is 11.</item>
        <item>F. Dolphins_fr_CA.properties and Dolphins_fr.properties</item>
        <item>F. 5</item>
        <item>F. A compiler error occurs on line 7.</item>
        <item>F. A runtime exception is thrown.</item>
        <item>F. An exception is thrown.</item>
    </string-array>






    <string-array name="AdvancedClassDesign">
<!--        1-->
        <item>
            1. What is the result of the following code?
\n1: public class Employee {
\n2: public int employeeId;
\n3: public String firstName, lastName;
\n4: public int yearStarted;
\n5: @Override public int hashCode() {
\n6: return employeeId;
\n7: }
\n8: public boolean equals(Employee e) {
\n9: return this.employeeId == e.employeeId;
\n10: }
\n11: public static void main(String[] args) {
\n12: Employee one = new Employee();
\n13: one.employeeId = 101;
\n14: Employee two = new Employee();
\n15: two.employeeId = 101;
\n16: if (one.equals(two)) System.out.println("Success");
\n17: else System.out.println("Failure");
\n18: } }
        </item>
<!--        2-->
        <item>
            2. What is the result of compiling the following class?
\n\npublic class Book {
 \nprivate int ISBN;
 \nprivate String title, author;
 \nprivate int pageCount;
 \npublic int hashCode() {
 \nreturn ISBN;
 \n}
 \n@Override public boolean equals(Object obj) {
 \nif ( !(obj instanceof Book)) {
\nreturn false;
 \n}
 \nBook other = (Book) obj;
 \nreturn this.ISBN == other.ISBN;
 \n}
\n// imagine getters and setters are here
\n}
        </item>
<!--        3-->
        <item>
            3. What is the result of the following code?
\n\nString s1 = "Canada";
\nString s2 = new String(s1);
\nif(s1 == s2) System.out.println("s1 == s2");
\nif(s1.equals(s2)) System.out.println("s1.equals(s2)");
        </item>
<!--        4-->
        <item>
            4. What is true about the following code? You may assume city and mascot are never null.
\n\npublic class BaseballTeam {
 \nprivate String city, mascot;
 \nprivate int numberOfPlayers;
 \npublic boolean equals(Object obj) {
 \nif ( !(obj instanceof BaseballTeam))
 \nreturn false;
 \nBaseballTeam other = (BaseballTeam) obj;
 \nreturn (city.equals(other.city) &amp;&amp; mascot.equals(other.mascot));
 \n}
\npublic int hashCode() {
 \nreturn numberOfPlayers;
 \n}
\n// imagine getters and setters are here
\n}
        </item>
<!--        5-->
        <item>
            5. What is the result of the following code?
\n\npublic class FlavorsEnum {
 \nenum Flavors {
 \nVANILLA, CHOCOLATE, STRAWBERRY
 \n}
 \npublic static void main(String[] args) {
 \nSystem.out.println(Flavors.CHOCOLATE.ordinal());
 \n}
\n}
        </item>
<!--        6-->
        <item>
            6. What is the result of the following code?
\n\n1: public class Outer {
\n2: private int x = 5;
\n3: protected class Inner {
\n4: public static int x = 10;
\n5: public void go() { System.out.println(x); }
\n6: }
\n7: public static void main(String[] args) {
\n8: Outer out = new Outer();
\n9: Outer.Inner in = out.new Inner();
\n10: in.go();
\n11: } }
        </item>
<!--        7-->
        <item>
            7. What is the result of the following code?
\n\n1: public class Outer {
\n2: private int x = 24;
\n3: public int getX() {
\n4: String message = "x is ";
\n5: class Inner {
\n6: private int x = Outer.this.x;
\n7: public void printX() {
\n8: System.out.println(message + x);
\n9: }
\n10: }
\n11: Inner in = new Inner();
\n12: in.printX();
\n13: return x;
\n14: }
\n15: public static void main(String[] args) {
\n16: new Outer().getX();
\n17: } }
        </item>
<!--        8-->
        <item>
           8. The following code appears in a file named Book.java. What is the result of compiling the
source file?
\n\n1: public class Book {
\n2: private int pageNumber;
\n3: private class BookReader {
\n4: public int getPage() {
\n5: return pageNumber;
\n6: } } }
        </item>
<!--        9-->
        <item>
            9. Which of the following statements can be inserted to make FootballGame compile?
\n\npackage my.sports;
\npublic class Football {
\n             public static final int TEAM_SIZE = 11;
\n}
\npackage my.apps;
\n// INSERT CODE HERE
\npublic class FootballGame {
 \npublic int getTeamSize() { return TEAM_SIZE; }
\n}
        </item>
<!--        10-->
        <item>
            10 What is the result of the following code?
\n\npublic class Browsers {
 \nstatic class Browser {
 \npublic void go() {
 \nSystem.out.println("Inside Browser");
 \n}
 \n}
 \nstatic class Firefox extends Browser {
 \npublic void go() {
 \nSystem.out.println("Inside Firefox");
 \n}
 \n}
 \nstatic class IE extends Browser {
 \n@Override public void go() {
 \nSystem.out.println("Inside IE");
 \n}
 \n}
 \npublic static void main(String[] args) {
 \nBrowser b = new Firefox();
 \nIE e = (IE) b;
 \ne.go();
 \n}
\n}
        </item>
<!--        11-->
        <item>
            11. Which is a true statement about the following code?
\n\npublic class IsItFurry {
 \nstatic interface Mammal { }
 \nstatic class Furry implements Mammal { }
 \nstatic class Chipmunk extends Furry { }
 \npublic static void main(String[] args) {
 \nChipmunk c = new Chipmunk();
 \nMammal m = c;
 \nFurry f = c;
 \nint result = 0;
 \nif (c instanceof Mammal) result += 1;
 \nif (c instanceof Furry) result += 2;
 \nif (null instanceof Chipmunk) result += 4;
 \nSystem.out.println(result);
 \n} }
        </item>
<!--        12-->
        <item>
            12. Which of the following can be inserted in main?
\n\npublic class Outer {
 \nclass Inner { }
\n
 \npublic static void main(String[] args) {
 \n// INSERT CODE HERE
 \n} }
        </item>
<!--        13-->
        <item>
            13. What is the result of the following code?
\n\npublic class FourLegged {
 \nString walk = "walk,";
 \nstatic class BabyRhino extends FourLegged {
 \nString walk = "toddle,";
 \n}
 \npublic static void main(String[] args) {
 \nFourLegged f = new BabyRhino();
 \nBabyRhino b = new BabyRhino();
 \nSystem.out.println(f.walk);
 \nSystem.out.println(b.walk);
 \n} }
        </item>
    </string-array>


    <string-array name="AnswerDefinitionForAdvancedClassDesign">
<!--       1-->
        <item>
            \n\tAnswer A. Based on the equals() method in the code, objects are equal if they have the same
employeeId. The hashCode() method correctly overrides the one from Object. The
equals() method is an overload of the one from Object and not an override. It would be
better to pass Object since an override would be better to use here. It is odd to override
hashCode() and not equals().
        </item>
<!--        2-->
        <item>
            \n\tAnswer A. hashCode() is correct and perfectly reasonable given that equals() also checks that
field. ClassCastException is a runtime exception and therefore does not need to be handled or declared. The override in equals() is correct. It is common for equals() to refer
to a private instance variable. This is legal because it is within the same class, even if it is
referring to a different object of the same class.
        </item>
<!--        3-->
        <item>
            \n\tAnswer C. s1 points to the string pool. s2 points to an object on the heap, since it is created
at runtime. == checks for reference equality. These are different references, making
B incorrect. String overrides equals() so the actual values are the same, making C
correct. And yes, this question could have appeared on the OCA. Remember that the
OCP is cumulative. A question may appear to be about one thing and actually be about a
simpler concept.
        </item>
<!--        4-->
        <item>
            \n\tAnswer C. The equals() method is correct. You are allowed to use any business logic that you
want in determining equality. The hashCode() method is not correct. It violates the rule
that two objects that return true for equals() must return the same hashCode(). It is also
a bad idea for the hash code to contain values that could change.
        </item>
<!--        5-->
        <item>
            \n\tAnswer B. The ordinal() method of an enum returns its corresponding int value. Like arrays,
enums are zero based. Remember that the index of an enum may change when you recompile
the code and should not be used for comparison.
        </item>
<!--        6-->
        <item>
            \n\tAnswer C. Inner is a member inner class. Inner classes are not allowed to contain static methods
or static variables. Only nested static classes are permitted to contain statics.
        </item>
<!--        7-->
        <item>
            \n\tAnswer B. Outer.this.x is the correct way to refer to x in the Outer class. In Java 7, the answer
would have been D because you used to have to declare variables as final to use them in a
local inner class. In Java 8, this requirement was dropped and the variables only need to be
effectively final, which means that the code would still compile if final were added.
        </item>
<!--        8-->
        <item>
            \n\tAnswer C. The code compiles fine. A member inner class is allowed to be private, and it is
allowed to refer to instance variables from the outer class. Two .class files are generated.
Book.class matches the name of the outer class. The inner class does not compile
to BookReader.class. That would introduce the possibility of a naming conflict.
Book$BookReader.class is correct because it shows the scope of the class is limited to
Book. You don’t need to know that $ is the syntax, but you do need to know the number of
classes and that BookReader is not a top-level class.
        </item>
<!--        9-->
        <item>
            \n\tAnswer D. FootballGame is trying to refer to a static variable in another class. It needs a static
import to do so. The correct syntax is import static and not static import. B is incorrect
because * does not import classes in a package. C is incorrect because it does not refer to a
static member.
        </item>
<!--        10-->
        <item>
            \n\tAnswer E. The main method tries to cast a Firefox instance to IE. Since IE is not a subclass of
Firefox, this throws a ClassCastException.
        </item>
<!--        11-->
        <item>
            \n\tAnswer B. c is an instance of Chipmunk. It is an instance of any superclasses or interfaces it implements. In this case, those are Furry, Mammal, and Object. null is not an instance of any
type. Therefore, the first two if statements execute and result is 3.
        </item>
<!--        12-->
        <item>
            \n\tAnswer E. This is a member inner class. It needs to be created using an instance of the outer class.
The syntax looks weird, but it creates an object of the outer class and then an object of the
inner class from it.
        </item>
<!--        13-->
        <item>
            \n\tAnswer C. Both objects are BabyRhino objects. Virtual method invocation says that the subclass
method gets called at runtime rather than the type in the variable reference. However, we are not calling methods here. We are referring to instance variables. With instance variables, the reference type does matter.
        </item>
    </string-array>


    <string-array name="CorrectAnswersForAdvancedClassDesign">
<!--        1--><item>A. Success</item>
<!--        2--><item>A. The code compiles.</item>
<!--        3--><item>C. s1.equals(s2)</item>
<!--        4--><item>C. The class compiles but has an improper hashCode() method.</item>
<!--        5--><item>B. 1</item>
<!--        6--><item>C. Line 4 generates a compiler error</item>
<!--        7--><item>B. x is 24.</item>
<!--        8--><item>C. The code compiles successfully, and two bytecode files are generated: Book.class and Book$BookReader.class.</item>
<!--        9--><item>D. import static my.sports.Football.*;</item>
<!--        10--><item>E. A runtime exception is thrown.</item>
<!--        11--><item>B. The output is 3.</item>
<!--        12--><item>E. Outer.Inner in = new Outer().new Inner();</item>
<!--        13--><item>C. walk,toddle,</item>
    </string-array>

    <string-array name="keysAForAdvancedClassDesign">
        <item>A. Success</item>
        <item>A. The code compiles.</item>
        <item>A. There is no output.</item>
        <item>A. The class does not compile</item>
        <item>A. 0</item>
        <item>A. The output is 5.</item>
        <item>A. x is 0.</item>
        <item>A. The code compiles successfully, and one bytecode file is generated: Book.class</item>
        <item>A. import my.sports.Football;</item>
        <item>A. Inside Browser</item>
        <item>A. The output is 0.</item>
        <item>A. Inner in = new Inner();</item>
        <item>A. toddle,toddle,</item>
    </string-array>

    <string-array name="keysBForAdvancedClassDesign">
        <item>B. Failure</item>
        <item>B. The code does not compile because hashCode() is incorrect.</item>
        <item>B. s1 == s2</item>
        <item>B. The class compiles but has an improper equals() method.</item>
        <item>B. 1</item>
        <item>B. The output is 10.</item>
        <item>B. x is 24.</item>
        <item>B. The code compiles successfully, and two bytecode files are generated: Book.class and BookReader.class</item>
        <item>B. import static my.sports.*;</item>
        <item>B. Inside Firefox</item>
        <item>B. The output is 3.</item>
        <item>B. Inner in = Outer.new Inner();</item>
        <item>B. toddle,walk,</item>
    </string-array>

    <string-array name="keysCForAdvancedClassDesign">
        <item>C. The hashCode() method fails to compile.</item>
        <item>C. The code does not compile because equals() does not override the parent method correctly.</item>
        <item>C. s1.equals(s2)</item>
        <item>C. The class compiles but has an improper hashCode() method.</item>
        <item>C. 9</item>
        <item>C. Line 4 generates a compiler error.</item>
        <item>C. Line 6 generates a compiler error</item>
        <item>C. The code compiles successfully, and two bytecode files are generated: Book.class and Book$BookReader.class.</item>
        <item>C. import static my.sports.Football;</item>
        <item>C. Inside IE</item>
        <item>C. The output is 7.</item>
        <item>C. Outer.Inner in = new Outer.Inner();</item>
        <item>C. walk,toddle,</item>
    </string-array>

    <string-array name="keysDForAdvancedClassDesign">
        <item>D. The equals() method fails to compile.</item>
        <item>D. The code does not compile because equals() tries to refer to a private field</item>
        <item>D. Both B and C.</item>
        <item>D. The class compiles and has proper equals() and hashCode() methods.</item>
        <item>D. CHOCOLATE</item>
        <item>D. Line 8 generates a compiler error.</item>
        <item>D. Line 8 generates a compiler error</item>
        <item>D. A compiler error occurs on line 3.</item>
        <item>D. import static my.sports.Football.*;</item>
        <item>D. The code does not compile.</item>
        <item>D. c instanceof Mammal does not compile</item>
        <item>D. Outer.Inner in = new Outer().Inner();</item>
        <item>D. walk,walk,</item>
    </string-array>

    <string-array name="keysEForAdvancedClassDesign">
        <item>E. Another line of code fails to compile.</item>
        <item>E. The code does not compile because the ClassCastException is not handled or declared.</item>
        <item>E. The code does not compile</item>
        <item>E. ~ ~</item>
        <item>E. The code does not compile due to a missing semicolon</item>
        <item>E. Line 9 generates a compiler error</item>
        <item>E. Line 11 generates a compiler error</item>
        <item>E. A compiler error occurs on line 5.</item>
        <item>E. static import my.sports.*;</item>
        <item>E. A runtime exception is thrown.</item>
        <item>E. c instanceof Furry does not compile.</item>
        <item>E. Outer.Inner in = new Outer().new Inner();</item>
        <item>E. The code does not compile.</item>
    </string-array>

    <string-array name="keysFForAdvancedClassDesign">
        <item>F. A runtime exception is thrown</item>
        <item>F. The code does not compile for another reason.</item>
        <item>F. The code throws a runtime exception.</item>
        <item>F. ~ ~</item>
        <item>F. The code does not compile for a different reason</item>
        <item>F. An exception is thrown.</item>
        <item>F. An exception is thrown</item>
        <item>F. ~ ~</item>
        <item>F. static import my.sports.Football;</item>
        <item>F. ~ ~</item>
        <item>F. null instanceof Chipmunk does not compile.</item>
        <item>F. Outer.Inner in = Outer.new Inner();</item>
        <item>F. A runtime exception is thrown.</item>
    </string-array>



    <string-array name="DesignPatternAndPrinciples">
<!--        1-->
        <item>
            1. What is the result of the following code?
\n\n1: public interface CanClimb {
\n2: public abstract void climb();
\n3: }
\n4: public interface CanClimbTrees extends CanClimb {}
\n5: public abstract class Chipmunk implements CanClimbTrees {
\n6: public abstract void chew();
\n7: }
\n8: public class EasternChipmunk extends Chipmunk {
\n9: public void chew() { System.out.println("Eastern Chipmunk is Chewing"); }
\n10: }
        </item>
<!--        2-->
        <item>
            2 What is the result of the following class?
\n\nimport java.util.function.*;
\npublic class Panda {
 \nint age;
 \npublic static void main(String[] args) {
 \nPanda p1 = new Panda();
 \np1.age = 1;
 \ncheck(p1, p -> p.age &#60; 5); // h1
 \n}
 \nprivate static void check(Panda panda, Predicate&#60;Panda> pred) { // h2
 \nString result = pred.test(panda) ? "match": "not match"; // h3
 \nSystem.out.print(result);
\n} }
        </item>
<!--        3-->
        <item>
            3. What is the result of the following code?
\n\n1: public interface CanWalk {
\n2: default void walk() { System.out.println("Walking"); }
\n3: }
\n4: public interface CanRun {
\n5: public default void walk() { System.out.println("Walking"); }
\n6: public abstract void run();
\n7: }
\n8: public interface CanSprint extends CanWalk, CanRun {
\n9: void sprint();
\n10: }
        </item>
<!--        4-->
        <item>
            4. What is the result of the following code?
\n\npublic interface Climb {
 \nboolean isTooHigh(int height, int limit);
\n}
\npublic class Climber {
 \npublic static void main(String[] args) {
 \ncheck((h, l) -> h.toString(), 5); // x1
 \n}
 \nprivate static void check(Climb climb, int height) {
 \nif (climb.isTooHigh(height, 10)) // x2
 \nSystem.out.println("too high");
 \nelse System.out.println("ok");
\n} }
        </item>
<!--        5-->
        <item>
            5. Choose the correct statement about the following code:
\n\n1: public interface Herbivore {
\n2: int amount = 10;
\n3: public static void eatGrass();
\n4: public int chew() {
\n5: return 13;
\n6: }
\n7: }
        </item>
<!--        6-->
        <item>
            6. Choose the correct statement about the following code:
\n\n1: public interface CanFly {
\n2: void fly();
\n3: }
\n4: interface HasWings {
\n5: public abstract Object getWingSpan();
\n6: }
\n7: abstract class Falcon implements CanFly, HasWings {
\n8: }
        </item>

    </string-array>

    <string-array name="AnswerDefinitionForDesignPatternAndPrinciples">
<!--        1-->
        <item>
            \n\tAnswer E. The code does not compile because EasternChipmunk inherits the abstract method
climb() but does not implement it, therefore the correct answer is E. B, C, and D are
incorrect as they compile for various reasons. Line 2 compiles, as non-static and nondefault interface methods are assumed to have the abstract modifier. Line 4 compiles
without issue as an interface can extend another interface. Line 5 compiles without issue as
an abstract class can implement an interface without implementing any of the abstract
methods. F is incorrect, as Line 8 does not compile.
        </item>
<!--        2-->
        <item>
            \n\tAnswer A. This code compiles and runs without issue so C, D, E, and F are incorrect. Line h1 creates a lambda expression that checks if the age is less than 5. Since there is only one parameter and it does not specify a type, the parentheses around the type parameter are optional.
Line h2 uses the Predicate interface, which declares a test() method. Since test()
returns true on the expression, match is output and A is correct.
        </item>
<!--        3-->
        <item>
            \n\tAnswer D. While Java supports multiple inheritance through interfaces, it does not support method
overriding in interfaces, since it’s not clear which parent method should be used. In this
example, CanWalk and CanRun both implement a default walk() method. The definition of
CanSprint extends these two interfaces and therefore won’t compile as two default methods with the same signature from parent classes are detected, therefore the answer is D. None
of the other lines of code cause problems, so the rest of the answers are not correct.
        </item>
<!--        4-->
        <item>
            \n\tAnswer C. The functional interface takes two int parameters. The code on line x1 attempts to use
them as if one is an Object, resulting in a compiler error making C the correct answer. It
also tries to return String even though the data type for the functional interface method is
boolean. It is tricky to use types in a lambda when they are implicitly specified. Remember
to check the interface for the real type.
        </item>
<!--        5-->
        <item>
            \n\tAnswer F. The interface variable amount is correctly declared, with public, static, and final
being assumed and automatically inserted by the compiler, so B is incorrect. The method
declaration for eatGrass() on line 3 is incorrect because the method has been marked as
static but no method body has been provided. The method declaration for chew() on
line 4 is also incorrect, since an interface method that provides a body must be marked as
default or static explicitly. Therefore, F is the correct answer since this code contains
two compile-time errors.
        </item>
<!--        6-->
        <item>
            6. A. Although the definition of methods on lines 2 and 5 vary, both will be converted to
public abstract by the compiler. Line 4 is fine, because an interface can have public or
default access. Finally, the class Falcon doesn’t need to implement the interface methods
because it is marked as abstract. Therefore, the code will compile without issue.
        </item>
    </string-array>

    <string-array name="CorrectAnswersForDesignPatternAndPrinciples">
<!--        1--><item>E. The code will not compile because of line 8.</item>
<!--        2--><item>A. match</item>
<!--        3--><item>D. The code will not compile because of line 8.</item>
<!--        4--><item>C. Compiler error on line x1.</item>
<!--        5--><item>F. The code will not compile because of lines 3 and 4.</item>
<!--        6--><item>A. It compiles without issue</item>
    </string-array>

    <string-array name="keysAForAdvancedDesignPatternAndPrinciples">
        <item>A. It compiles and runs without issue</item>
        <item>A. match</item>
        <item>A. The code compiles without issue.</item>
        <item>A. ok</item>
        <item>A. It compiles and runs without issue.</item>
        <item>A. It compiles without issue</item>
    </string-array>

    <string-array name="keysBForAdvancedDesignPatternAndPrinciples">
        <item>B. The code will not compile because of line 2.</item>
        <item>B. not match</item>
        <item>B. The code will not compile because of line 5.</item>
        <item>B. too high</item>
        <item>B. The code will not compile because of line 2.</item>
        <item>B. The code will not compile because of line 2.</item>
    </string-array>

    <string-array name="keysCForAdvancedDesignPatternAndPrinciples">
        <item>C. The code will not compile because of line 4.</item>
        <item>C. Compiler error on line h1.</item>
        <item>C. The code will not compile because of line 6.</item>
        <item>C. Compiler error on line x1.</item>
        <item>C. The code will not compile because of line 3</item>
        <item>C. The code will not compile because of line 4.</item>
    </string-array>

    <string-array name="keysDForAdvancedDesignPatternAndPrinciples">
        <item>D. The code will not compile because of line 5.</item>
        <item>D. Compiler error on line h2.</item>
        <item>D. The code will not compile because of line 8.</item>
        <item>D. Compiler error on line x2.</item>
        <item>D. The code will not compile because of line 4.</item>
        <item>D. The code will not compile because of line 5.</item>
    </string-array>

    <string-array name="keysEForAdvancedDesignPatternAndPrinciples">
        <item>E. The code will not compile because of line 8.</item>
        <item>E. Compile error on line h3.</item>
        <item>E. The code will not compile because of line 9.</item>
        <item>E. Compiler error on a different line.</item>
        <item>E. The code will not compile because of lines 2 and 3.</item>
        <item>E. The code will not compile because of lines 2 and 5.</item>
    </string-array>

    <string-array name="keysFForAdvancedDesignPatternAndPrinciples">
        <item>F. It compiles but throws an exception at runtime.</item>
        <item>F. A runtime exception is thrown.</item>
        <item>F. ~~</item>
        <item>F. A runtime exception is thrown.</item>
        <item>F. The code will not compile because of lines 3 and 4.</item>
        <item>F. The code will not compile because the class Falcon doesn’t implement the interface methods.</item>
    </string-array>




    <string-array name="GenericsAndCollections">
<!--        1-->
        <item>
            1. Suppose that you have a collection of products for sale in a database and you need to
display those products. The products are not unique. Which of the following collections
classes in the java.util package best suit your needs for this scenario?
        </item>
<!--        2-->
        <item>
            2. Suppose that you need to work with a collection of elements that need to be sorted in their
natural order, and each element has a unique string associated with its value. Which of the
following collections classes in the java.util package best suit your needs for this scenario?
        </item>
<!--        3-->
        <item>
            3. What is the result of the following statements?
            \n\n3: List list = new ArrayList();
\n4: list.add("one");
\n5: list.add("two");
\n6: list.add(7);
\n7: for (String s: list)
\n8: System.out.print(s);
        </item>
<!--        4-->
        <item>
            4. What is the result of the following statements?
\n\n3: ArrayDeque&#60;String> greetings = new ArrayDeque&#60;String>();
\n4: greetings.push("hello");
\n5: greetings.push("hi");
\n6: greetings.push("ola");
\n7: greetings.pop();
\n8: greetings.peek();
\n9: while (greetings.peek() != null)
\n10: System.out.print(greetings.pop());
        </item>
<!--        5-->
        <item>
            5. What is the result of the following code?
\n\n1: public class Hello&#60;T> {
\n2: T t;
\n3: public Hello(T t) { this.t = t; }
\n4: public String toString() { return t.toString(); }
\n5: public static void main(String[] args) {
\n6: System.out.print(new Hello&#60;String>("hi"));
\n7: System.out.print(new Hello("there"));
\n8: } }
        </item>
<!--        6-->
        <item>
            6. What is the result of the following code?
\n\nTreeSet&#60;String> tree = new TreeSet&#60;String>();
\ntree.add("one");
\ntree.add("One");
\ntree.add("ONE");
\nSystem.out.println(tree.ceiling("On"));
        </item>
<!--        7-->
        <item>
            7. Which of the answer choices are valid given the following declaration?
\n\nMap&#60;String, Double> map = new HashMap&#60;>();
        </item>
<!--        8-->
        <item>
            8. What is the result of the following program?
\n\nimport java.util.*;
\npublic class MyComparator implements Comparator&#60;String> {
 \npublic int compare(String a, String b) {
 \nreturn b.toLowerCase().compareTo(a.toLowerCase());
 \n}
 \npublic static void main(String[] args) {
 \nString[] values = { "123", "Abb", "aab" };
 \nArrays.sort(values, new MyComparator());
 \nfor (String s: values)
 \nSystem.out.print(s + " ");
 \n}
\n}
        </item>
<!--        9-->
        <item>
            9. What is the result of the following code?
3: Map&#60;Integer, Integer> map = new HashMap&#60;w>(10);
4: for (int i = 1; i &#60;= 10; i++) {
5: map.put(i, i * i);
6: }
7: System.out.println(map.get(4));
        </item>
<!--        10-->
        <item>
            10. What is the result of the following program?
\n\nimport java.util.*;
\npublic class Sorted implements Comparable&#60;Sorted>, Comparator&#60;Sorted> {
 \nprivate int num;
 \nprivate String text;
 \nSorted(int n, String t) {
 \nthis.num = n;
 \nthis.text = t;
 \n}
 \npublic String toString() { return "" + num; }
 \npublic int compareTo(Sorted s) { return text.compareTo(s.text); }
 \npublic int compare(Sorted s1, Sorted s2) { return s1.num – s2.num; }
\n\npublic static void main(String[] args) {
 \nSorted s1 = new Sorted(88, "a");
 \nSorted s2 = new Sorted(55, "b");
 \nTreeSet&#60;Sorted> t1 = new TreeSet&#60;>();
 \nt1.add(s1); t1.add(s2);
 \nTreeSet&#60;Sorted> t2 = new TreeSet&#60;>(s1);
 \nt2.add(s1); t2.add(s2);
 \nSystem.out.println(t1 + " " + t2);
 \n} }
        </item>
<!--        11-->
        <item>
            11. What is the result of the following code?
\n\nComparator&#60;Integer> c = (o1, o2) -> o2—o1;
\nList&#60;Integer> list = Arrays.asList(5, 4, 7, 1);
\nCollections.sort(list, c);
\nSystem.out.println(Collections.binarySearch(list, 1));
        </item>
<!--        12-->
        <item>
            12. What is the result of the following code?
\n\n4: Map m = new HashMap();
\n5: m.put(123, "456");
\n6: m.put("abc", "def");
\n7: System.out.println(m.contains("123"));
        </item>
<!--        13-->
        <item>
            13. What code change is needed to make the method compile?
\n\npublic static T identity(T t) {
 \nreturn t;
\n}
        </item>
<!--        14-->
        <item>
            14. What is the result of the following?
\n\nMap&#60;Integer, Integer> map = new HashMap&#60;>();
\nmap.put(1, 10);
\nmap.put(2, 20);
\nmap.put(3, null);
\n\nmap.merge(1, 3, (a,b) -> a + b);
\nmap.merge(3, 3, (a,b) -> a + b);
\n\nSystem.out.println(map);
        </item>
    </string-array>


    <string-array name="AnswerDefinitionForGenericsAndCollections">
<!--        1-->
        <item>
            \n\tAnswer B. The answer needs to implement List because the scenario allows duplicates. Since you
need a List, you can eliminate C, D, and E immediately. HashMap is a Map and HashSet is a
Set. LinkedList is both a List and a Queue. You want a regular List. Option A, Arrays,
is trying to distract you. It is a utility class rather than a Collection. An array is not a collection. By process of elimination, the answer is B.
        </item>
<!--        2-->
        <item>
            \n\tAnswer D. The answer needs to implement Map because you are dealing with key/value pairs per the
unique string text. You can eliminate A, C, E, and F immediately. ArrayList and Vector
are Lists. HashSet and TreeSet are Sets. Now it is between HashMap and TreeMap. Since
the question talks about ordering, you need the TreeMap. Therefore, the answer is E.
        </item>
<!--        3-->
        <item>.
            \n\tAnswer E. The code does not compile. It attempts to mix generics and legacy code. Lines 3 through
7 create an ArrayList without generics. This means that we can put any objects in it.
Line 7 should be looping through a list of Objects rather than Strings since we didn’t use
generics.
        </item>
<!--        4-->
        <item>
            \n\tAnswer E. Since we call push() rather than offer(), we are treating the ArrayDeque as a LIFO
(last-in, first-out) stack. On line 7, we remove the last element added, which is "ola". On
line 8, we look at the new last element ("hi"), but don’t remove it. Lines 9 and 10, we
remove each element in turn until none are left. Note that we don’t use an Iterator to loop
through the ArrayDeque. The order in which the elements are stored internally is not part
of the API contract.
        </item>
<!--        5-->
        <item>
            \n\tAnswer C. Line 7 gives a compiler warning for not using generics but not a compiler error. Line 4
compiles fine because toString() is defined on the Object class and is therefore always
available to call. Line 6 creates the Hello class with the generic type String. Line 7 creates
the Hello class with the generic type Object since no type is specified
        </item>
<!--        6-->
        <item>
            \n\tAnswer C. TreeSet sorts the elements. Since uppercase letters sort before lowercase letters, the
ordering is "ONE", "One", "one". The ceiling() method returns the smallest element
greater than the specified one. "On" appears between "ONE" and "One". Therefore, the
smallest element that is larger than the specified value is "One".
        </item>
<!--        7-->
        <item>
            \n\tAnswer E. Trick question! The Map interface uses put() rather than add() to add elements to the
map. If these examples used put(), the answer would be A and C. B is no good because a
long cannot be shoved into a Double. D is no good because a char is not the same thing as
a String.
        </item>
<!--        8-->
        <item>
            \n\tAnswer A. The array is sorted using MyComparator, which sorts the elements in reverse alphabetical order in a case-insensitive fashion. Normally, numbers sort before letters. This code
reverses that by calling the compareTo() method on b instead of a.
        </item>
<!--        9-->
        <item>
            \n\tAnswer A. Line 3 uses the diamond operator to create the map. Lines 5 and 7 use autoboxing to
convert between the int primitive and the Integer wrapper class. The keys map to their
squared value. 1 maps to 1, 2 maps to 4, 3 maps to 9, 4 maps to 16, and so on.
        </item>
<!--        10-->
        <item>
            \n\tAnswer C. This question is hard because it defines both Comparable and Comparator on the same
object. t1 doesn’t specify a Comparator so it uses the Comparable object’s compareTo()
method. This sorts by the text instance variable. t2 did specify a Comparator when calling
the constructor, so it uses the compare() method, which sorts by the int.
        </item>
<!--        11-->
        <item>
            \n\tAnswer D. The list is sorted in descending order. However, it is searched using the default order,
which is sorted in ascending order. binarySearch() requires both to use the same sort
order. Therefore, the precondition for binarySearch() is not met and the result is undefined.
        </item>
<!--        12-->
        <item>
            \n\tAnswer E. This question looks like it is about generics, but it’s not. It is trying to see if
you noticed that Map does not have a contains() method. It has containsKey() and
containsValue() instead. If containsKey() was called, the answer would be false
because the 123 in the list is an Integer rather than a String.
        </item>
<!--        13-->
        <item>
            \n\tAnswer B. When using generic types in a static method, the generic specification goes before the return type.
        </item>
<!--        14-->
        <item>
            \n\tAnswer F. The first call to merge() calls the mapping function and adds the two numbers to get 13.
It then updates the map. The second call to merge() sees that the map currently has a null
value for that key. It does not call the mapping function but instead replaces it with the new
value of 3. Therefore choice F is correct.
        </item>
    </string-array>

    <string-array name="CorrectAnswersForGenericsAndCollections">
<!--        1--><item>B. ArrayList</item>
<!--        2--><item>D. TreeMap</item>
<!--        3--><item>E. Compiler error on line 7</item>
<!--        4--><item>E. hihello</item>
<!--        5--><item>C. hithere</item>
<!--        6--><item>C. One</item>
<!--        7--><item>E. None of the above</item>
<!--        8--><item>A. Abb aab 123</item>
<!--        9--><item>A. 16</item>
<!--        10--><item>C. [88. 55] [55, 88]</item>
<!--        11--><item>D. The result is undefined.</item>
<!--        12--><item>E. Compiler error on line 7.</item>
<!--        13--><item>B. Add &#60;T> after the static keyword.</item>
<!--        14--><item>F. {1=13, 2=20, 3=3}</item>
    </string-array>


    <string-array name="keysAForGenericsAndCollections">
        <item>A. Arrays</item>
        <item>A. ArrayList</item>
        <item>A. onetwo</item>
        <item>A. hello</item>
        <item>A. hi</item>
        <item>A. On</item>
        <item>A. map.add("pi", 3.14159);</item>
        <item>A. Abb aab 123</item>
        <item>A. 16</item>
        <item>A. [55. 88] [55, 88]</item>
        <item>A. 0</item>
        <item>A. false</item>
        <item>A. Add &#60;T> after the public keyword</item>
        <item>A. {1=10, 2=20}</item>
    </string-array>

    <string-array name="keysBForGenericsAndCollections">
        <item>B. ArrayList</item>
        <item>B. HashMap</item>
        <item>B. onetwo7</item>
        <item>B. hellohi</item>
        <item>B. hi followed by a runtime exception</item>
        <item>B. one</item>
        <item>B. map.add("e", 2L);</item>
        <item>B. aab Abb 123</item>
        <item>B. 25</item>
        <item>B. [55. 88] [88, 55]</item>
        <item>B. 1</item>
        <item>B. true</item>
        <item>B. Add &#60;T> after the static keyword.</item>
        <item>B. {1=10, 2=20, 3=null}</item>
    </string-array>

    <string-array name="keysCForGenericsAndCollections">
        <item>C. HashMap</item>
        <item>C. HashSet</item>
        <item>C. onetwo followed by an exception</item>
        <item>C. hellohiola</item>
        <item>C. hithere</item>
        <item>C. One</item>
        <item>C. map.add("log(1)", new Double(0.0));</item>
        <item>C. 123 Abb aab</item>
        <item>C. Compiler error on line 3.</item>
        <item>C. [88. 55] [55, 88]</item>
        <item>C. 2</item>
        <item>C. Compiler error on line 4</item>
        <item>C. Add &#60;T> after T.</item>
        <item>C. {1=10, 2=20, 3=3}</item>
    </string-array>

    <string-array name="keysDForGenericsAndCollections">
        <item>D. HashSet</item>
        <item>D. TreeMap</item>
        <item>D. Compiler error on line 6</item>
        <item>D. hi</item>
        <item>D. Compiler error on line 4</item>
        <item>D. ONE</item>
        <item>D. map.add(\'x\', new Double(123.4));</item>
        <item>D. 123 aab Abb</item>
        <item>D. Compiler error on line 5.</item>
        <item>D. [88. 55] [88, 55]</item>
        <item>D. The result is undefined.</item>
        <item>D. Compiler error on line 5.</item>
        <item>D. Add &#60;?> after the public keyword</item>
        <item>D. {1=13, 2=20}</item>
    </string-array>

    <string-array name="keysEForGenericsAndCollections">
        <item>E. LinkedList</item>
        <item>E. TreeSet </item>
        <item>E. Compiler error on line 7</item>
        <item>E. hihello</item>
        <item>E. Compiler error on line 6</item>
        <item>E. The code does not compile.</item>
        <item>E. None of the above</item>
        <item>E. The code does not compile.</item>
        <item>E. Compiler error on line 7.</item>
        <item>E. The code does not compile.</item>
        <item>E. The code does not compile.</item>
        <item>E. Compiler error on line 7.</item>
        <item>E. Add &#60;?> after the static keyword.</item>
        <item>E. {1=13, 2=20, 3=null}</item>
    </string-array>

    <string-array name="keysFForGenericsAndCollections">
        <item>F. ~</item>
        <item>F. Vector</item>
        <item>F. ~</item>
        <item>F. The code does not compile</item>
        <item>F. Compiler error on line 7</item>
        <item>F. An exception is thrown</item>
        <item>F. ~</item>
        <item>F. A runtime exception is thrown.</item>
        <item>F. A runtime exception is thrown.</item>
        <item>F. A runtime exception is thrown.</item>
        <item>F. A runtime exception is thrown.</item>
        <item>F. A runtime exception is thrown.</item>
        <item>F. No change required. The code already compiles.</item>
        <item>F. {1=13, 2=20, 3=3}</item>
    </string-array>



    <string-array name="FunctionalProgramming">
<!--       1-->
        <item>
             1. What is the output of the following?
        \n\nStream&#60;String> stream = Stream.iterate("", (s) -> s + "1");
        System.out.println(stream.limit(2).map(x -> x + "2"));
        </item>
<!--        2-->
        <item>
            2. What is the output of the following?
\n\nPredicate&#60;? super String> predicate = s -> s.startsWith("g");
\nStream&#60;String> stream1 = Stream.generate(() -> "growl! ");
\nStream&#60;String> stream2 = Stream.generate(() -> "growl! ");
\nboolean b1 = stream1.anyMatch(predicate);
\nboolean b2 = stream2.allMatch(predicate);
\nSystem.out.println(b1 + " " + b2);
        </item>
<!--        3-->
        <item>
            3. What is the output of the following?
\n\nPredicate&#60;? super String> predicate = s -> s.length() > 3;
\nStream&#60;String> stream = Stream.iterate("-", (s) -> s + s);
\nboolean b1 = stream.noneMatch(predicate);
\nboolean b2 = stream.anyMatch(predicate);
\nSystem.out.println(b1 + " " + b2);
        </item>
<!--        4-->
        <item>
             4. Select from the following statements and indicate the order in which they would appear to
output 10 lines:
            \n\n
            Stream.generate(() -> "1")
\nL: .filter(x -> x.length() > 1)
\nM: .forEach(System.out::println)
\nN: .limit(10)
\nO: .peek(System.out::println)
\n;
        </item>
<!--        5-->
        <item>
            5. Which of the following is true?
\n\nList&#60;Integer> l1 = Arrays.asList(1, 2, 3);
\nList&#60;Integer> l2 = Arrays.asList(4, 5, 6);
\nList&#60;Integer> l3 = Arrays.asList();
\nStream.of(l1, l2, l3).map(x -> x + 1)
 \n.flatMap(x -> x.stream()).forEach(System.out::print);
        </item>
<!--        6-->
        <item>
            6. Which of the following is true?
\n\n\t4: Stream&#60;Integer> s = Stream.of(1);
\n\t5: IntStream is = s.mapToInt(x -> x);
\n\t6: DoubleStream ds = s.mapToDouble(x -> x);
\n\t7: Stream&#60;Integer> s2 = ds.mapToInt(x -> x);
\n\t8: s2.forEach(System.out::print);
        </item>
<!--        7-->
        <item>
            7. What is the output of the following?
\n\nStream&#60;String> s = Stream.empty();
\nStream&#60;String> s2 = Stream.empty();
\nMap&#60;Boolean, List&#60;String>> p = s.collect(
 \nCollectors.partitioningBy(b -> b.startsWith("c")));
\nMap&#60;Boolean, List&#60;String>> g = s2.collect(
 \nCollectors.groupingBy(b -> b.startsWith("c")));
\nSystem.out.println(p + " " + g);
        </item>
<!--        8-->
        <item>
            8. Which of the following is equivalent to this code?
\n\n\tUnaryOperator&#60;Integer> u = x -> x * x;
        </item>
<!--        9-->
        <item>
            9. What is the result of the following?
DoubleStream s = DoubleStream.of(1.2, 2.4);
s.peek(System.out::println).filter(x -> x > 2).count();
        </item>
    </string-array>


    <string-array name="AnswerDefinitionForFunctionalProgramming">
<!--        1-->
        <item>
            \n\tAnswer D. No terminal operation is called, so the stream never executes. The methods chain to
create a stream that would contain “2” and “12.” The first line creates an infinite stream.
The second line would get the first two elements from that infinite stream and map each
element to add an extra character.
        </item>
<!--        2-->
        <item>
            \n\tAnswer F. b1 is set to true since anyMatch() terminates. Even though the stream is infinite, Java
finds a match on the first element and stops looking. However, when allMatch() runs,
it needs to keep going until the end of the stream since it keeps finding matches. Since all
elements continue to match, the program hangs.
        </item>
<!--        3-->
        <item>
            \n\tAnswer E. An infinite stream is generated where each element is twice as long as the previous
one. b1 is set to false because Java finds an element that doesn’t match when it gets to
the element of length 4. However, the next line tries to operate on the same stream. Since
streams can be used only once, this throws an exception that the “stream has already been
operated upon or closed.” If two different streams were used, the result would be option A.
        </item>
<!--        4-->
        <item>
            \n\tAnswer F. The terminal operation must be right before the semicolon, which is line M. Remember
that forEach() is a terminal operation while peek() is an intermediate operation. This
eliminates all but choices C, E, and F. Choice E is incorrect because there is no limit()
operation, which means that the code would run infinitely. Choice C is incorrect because
filter() is called before limit(). No elements make it through the filter, so the code also
runs infinitely. Choice F is correct.
        </item>
<!--        5-->
        <item>
            \n\tAnswer F. If the map() and flatMap() calls were reversed, choice B would be correct. In this case,
the Stream created from the source is of type Stream&#60;List&#60;Integer>>. The Function in
map expects an Integer rather than a List&#60;Integer>, so the code does not compile.
        </item>
<!--        6-->
        <item>
            \n\tAnswer D. Line 4 should obviously look OK. It creates a Stream and uses autoboxing to put the
Integer 1 inside. Line 5 converts to a primitive, again using autoboxing. Line 6 converts
to a double primitive, which works since double d = 1; would work. Line 7 is where it
all falls apart. Converting from a double to an int would require a cast inside the lambda.
        </item>
<!--        7-->
        <item>
            \n\tAnswer C. The partitioningBy() operation always returns a map with two Boolean keys, even
if there are no corresponding values. By contrast, groupingBy() returns only keys that are
actually needed.
        </item>
<!--        8-->
        <item>
            \n\tAnswer E. A UnaryOperator is a special type of function where the parameter and return type
are the same. Therefore, option E is correct. Notice that other options don’t even compile
because they have the wrong number of generic types for the functional interface provided.
        </item>
<!--        9-->
        <item>
            \n\tAnswer D. The terminal operation is count(). Since there is a terminal operation, the intermediate
operations run. The peek() operation comes before the filter, so both numbers are printed.
The count happens to be 1 since the other number is filtered. However, the result of the
stream pipeline isn’t stored in a variable, and that result is ignored.
        </item>
    </string-array>


    <string-array name="CorrectAnswersForFunctionalProgramming">
<!--        1--><item>D. java.util.stream.ReferencePipeline$3@4517d9a3</item>
<!--        2--><item>B. true true</item>
<!--        3--><item>E. An exception is thrown.</item>
<!--        4--><item>F. N, M</item>
<!--        5--><item>F. The code does not compile</item>
<!--        6--><item>D. Line 7 does not compile.</item>
<!--        7--><item>C. {false=[], true=[]} {}</item>
<!--        8--><item>E. Function&#60;Integer, Integer> f = x -> x*x;</item>
<!--        9--><item>D. 1.2 and 2.4</item>
    </string-array>


    <string-array name="keysAForFunctionalProgramming">
        <item>A. 12112</item>
        <item>A. true false</item>
        <item>A. false true</item>
        <item>A. L, N</item>
        <item>A. The code compiles and prints 123456.</item>
        <item>A. Line 4 does not compile.</item>
        <item>A. {} {}</item>
        <item>A. BiFunction&#60;Integer> f = x -> x*x;</item>
        <item>A. 1</item>
    </string-array>


    <string-array name="keysBForFunctionalProgramming">
        <item>B. 212</item>
        <item>B. true true</item>
        <item>B. false false</item>
        <item>B. L, N, O</item>
        <item>B. The code compiles and prints 234567.</item>
        <item>B. Line 5 does not compile</item>
        <item>B. {} {false=[], true=[]}</item>
        <item>B. BiFunction&#60;Integer, Integer> f = x -> x*x;</item>
        <item>B. 2</item>

    </string-array>


    <string-array name="keysCForFunctionalProgramming">
        <item>C. 212112</item>
        <item>C. java.util.stream.ReferencePipeline$3@4517d9a3</item>
        <item>C. java.util.stream.ReferencePipeline$3@4517d9a3</item>
        <item>C. L, N, M</item>
        <item>C. The code compiles but does not print anything</item>
        <item>C. Line 6 does not compile.</item>
        <item>C. {false=[], true=[]} {}</item>
        <item>C. BinaryOperator&#60;Integer, Integer> f = x -> x*x;</item>
        <item>C. 2.4</item>

    </string-array>


    <string-array name="keysDForFunctionalProgramming">
        <item>D. java.util.stream.ReferencePipeline$3@4517d9a3</item>
        <item>D. The code does not compile.</item>
        <item>D. The code does not compile.</item>
        <item>D. L, N, M, O</item>
        <item>D. The code compiles but prints stream references.</item>
        <item>D. Line 7 does not compile.</item>
        <item>D. {false=[], true=[]} {false=[], true=[]}</item>
        <item>D. Function&#60;Integer> f = x -> x*x;</item>
        <item>D. 1.2 and 2.4</item>

    </string-array>


    <string-array name="keysEForFunctionalProgramming">
        <item>E. The code does not compile.</item>
        <item>E. An exception is thrown.</item>
        <item>E. An exception is thrown.</item>
        <item>E. L, O, M</item>
        <item>E. The code runs infinitely.</item>
        <item>E. Line 8 does not compile.</item>
        <item>E. The code does not compile.</item>
        <item>E. Function&#60;Integer, Integer> f = x -> x*x;</item>
        <item>E. There is no output.</item>
    </string-array>


    <string-array name="keysFForFunctionalProgramming">
        <item>F. An exception is thrown.</item>
        <item>F. The code hangs.</item>
        <item>F. The code hangs.</item>
        <item>F. N, M</item>
        <item>F. The code does not compile</item>
        <item>F. The code throws an exception.</item>
        <item>F. An exception is thrown.</item>
        <item>F. None of the above</item>
        <item>F. The code does not compile.</item>

    </string-array>



    <string-array name="DatesStringsAndLocalization">
<!--        1-->
        <item>
            1. Assume that all bundles mentioned in the answers exist and define the same keys. Which
one will be used to find the key in line 8?
\n\n\t6: Locale.setDefault(new Locale("en", "US"));
\n\t7: ResourceBundle b = ResourceBundle.getBundle("Dolphins");
\n\t8: b.getString("name");
        </item>
<!--        2-->
        <item>
            2. Suppose that we have the following property files and code. Which bundles are used on lines 8 and 9 respectively?
\n\nDolphins.properties
\nname=The Dolphin
\nage=0
\n\nDolphins_en.properties
\nname=Dolly
\nage=4
\n\nDolphins_fr.properties
\nname=Dolly
\n\n\n5: Locale fr = new Locale("fr");
\n6: Locale.setDefault(new Locale("en", "US"));
\n7: ResourceBundle b = ResourceBundle.getBundle("Dolphins", fr);
\n8: b.getString("name");
\n9: b.getString("age");
        </item>
<!--        3-->
        <item>
            3. What is the output of the following code?
\n\nLocalDate date = LocalDate.parse(
\n"2018–04–30", DateTimeFormatter.ISO_LOCAL_DATE);
\ndate.plusDays(2);
\ndate.plusHours(3);
\nSystem.out.println(date.getYear() + " "
 \n+ date.getMonth() + " "+ date.getDayOfMonth());
        </item>
<!--        4-->
        <item>
            4. What is the output of the following code?
\n\nLocalDate date = LocalDate.of(2018, Month.APRIL, 40);
\nSystem.out.println(date.getYear() + " " + date.getMonth()
 \n+ " "+ date.getDayOfMonth());
        </item>
<!--        5-->
        <item>
            5. What is the output of the following code?
\n\nLocalDate date = LocalDate.of(2018, Month.APRIL, 30);
\ndate.plusDays(2);
\ndate.plusYears(3);
\nSystem.out.println(date.getYear() + " "
 \n+ date.getMonth() + " "+ date.getDayOfMonth());
        </item>
<!--        6-->
        <item>
            6. What is the output of the following code?
\n\nLocalDateTime d = LocalDateTime.of(2015, 5, 10, 11, 22, 33);
\nPeriod p = Period.of(1, 2, 3);
\nd = d.minus(p);
\nDateTimeFormatter f = DateTimeFormatter.
 \nofLocalizedTime(FormatStyle.SHORT);
\nSystem.out.println(d.format(f));
        </item>
<!--        7-->
        <item>
            7. What is the output of the following code?
\n\nLocalDateTime d = LocalDateTime.of(2015, 5, 10, 11, 22, 33);
\nPeriod p = Period.ofDays(1).ofYears(2);
\nd = d.minus(p);
\nDateTimeFormatter f = DateTimeFormatter.
 \nofLocalizedDateTime(FormatStyle.SHORT);
\nSystem.out.println(f.format(d));
        </item>
<!--        8-->
        <item>
            8. Note that March 13, 2016, is the weekend that clocks spring ahead for daylight savings time. What is the output of the following?
\n\nLocalDate date = LocalDate.of(2016, Month.MARCH, 13);
\nLocalTime time = LocalTime.of(1, 30);
\nZoneId zone = ZoneId.of("US/Eastern");
\nZonedDateTime dateTime1 = ZonedDateTime.of(date, time, zone);
\nZonedDateTime dateTime2 = dateTime1.plus(1, ChronoUnit.HOURS);
\n\nlong hours = ChronoUnit.HOURS.between(dateTime1, dateTime2);
\nint clock1 = dateTime1.getHour();
\nint clock2 = dateTime2.getHour();
\nSystem.out.println(hours + "," + clock1 + "," + clock2);
        </item>
<!--        9-->
        <item>
            9. What is the output of the following method if props contains {veggies=brontosaurus,
meat=velociraptor}?
\n\n\nprivate static void print(Properties props) {
 \nSystem.out.println(props.get("veggies", "none")
 \n+ " " + props.get("omni", "none"));
\n}
        </item>
    </string-array>


    <string-array name="AnswerDefinitionForDatesStringsAndLocalization">
<!--        1-->
        <item>
            \n\tAnswer B. Java will first look for the most specific matches it can find, starting with Dolphins_en_
US.java and then Dolphins_en_US.properties. Since neither is found, it drops the country and looks for Dolphins_en.java. Since a match is found, there is no reason to go on to
the next one, which is Dolphins_en.properties.
        </item>
<!--        2-->
        <item>
            \n\tAnswer D. Java will use Dolphins_fr.properties as the matching resource bundle on line 7
because it is an exact match on the language of the requested locale. Line 8 finds a matching key in this file. Line 9 does not find a match in that file, and therefore it has to look
higher up in the hierarchy. Once a bundle is chosen, only resources in that hierarchy are
allowed.
        </item>
<!--        3-->
        <item>
            \n\tAnswer D. A LocalDate does not have a time element. Therefore, it has no method to add hours,
and the code does not compile.
        </item>
<!--        4-->
        <item>
            \n\tAnswer F. Java throws an exception if invalid date values are passed. There is no 40th day in
April—or any other month for that matter.
        </item>
<!--        5-->
        <item>
            \n\tAnswer B. The date starts out as April 30, 2018. Since dates are immutable and the plus methods
have their return values ignored, the result is unchanged. Therefore, Option B is correct.
        </item>
<!--        6-->
        <item>
            \n\tAnswer E. Even though d has both date and time, the formatter only outputs time.
        </item>
<!--        7-->
        <item>
            \n\tAnswer B. Period does not allow chaining. Only the last Period method called counts, so only the
two years are subtracted.
        </item>
<!--        8-->
        <item>
            \n\tAnswer B. dateTime1 is 2016–03–13T01:30–05:00[US/Eastern] and dateTime2 is
2016–03–13T03:30–04:00[US/Eastern]. While the values are two hours apart, the time
zone offset changes as well, making it only change from 6:30 GMT to 7:30 GMT.
        </item>
<!--        9-->
        <item>
            \n\tAnswer E. The Properties class defines a get() method that does not allow for a default value.
It also has a getProperty() method, which returns the default value if the key is not provided.
        </item>
    </string-array>


    <string-array name="CorrectAnswersForDatesStringsAndLocalization">
<!--        1--><item>B. Dolphins_en.java</item>
<!--        2--><item>D. Dolphins_fr.properties and Dolphins.properties</item>
<!--        3--><item>D. The code does not compile.</item>
<!--        4--><item>F. A runtime exception is thrown</item>
<!--        5--><item>B. 2018 APRIL 30</item>
<!--        6--><item>E. 11:22 AM</item>
<!--        7--><item>B. 5/10/13 11:22 AM</item>
<!--        8--><item>B. 1,1,3</item>
<!--        9--><item>E. The code does not compile</item>
    </string-array>


    <string-array name="keysAForDatesStringsAndLocalization">
        <item>A. Dolphins.properties</item>
        <item>A. Dolphins.properties and Dolphins.properties</item>
        <item>A. 2018 APRIL 2</item>
        <item>A. 2018 APRIL 4</item>
        <item>A. 2018 APRIL 2</item>
        <item>A. 3/7/14 11:22 AM</item>
        <item>A. 5/9/13 11:22 AM</item>
        <item>A. 1,1,2</item>
        <item>A. brontosaurus none</item>
    </string-array>


    <string-array name="keysBForDatesStringsAndLocalization">
        <item>B. Dolphins_en.java</item>
        <item>B. Dolphins.properties and Dolphins_en.properties</item>
        <item>B. 2018 APRIL 30</item>
        <item>B. 2018 APRIL 30</item>
        <item>B. 2018 APRIL 30</item>
        <item>B. 5/10/15 11:22 AM</item>
        <item>B. 5/10/13 11:22 AM</item>
        <item>B. 1,1,3</item>
        <item>B. brontosaurus null</item>
    </string-array>


    <string-array name="keysCForDatesStringsAndLocalization">
        <item>C. Dolphins_en.properties</item>
        <item>C. Dolphins_en.properties and Dolphins_en.properties</item>
        <item>C. 2018 MAY 2</item>
        <item>C. 2018 MAY 10</item>
        <item>C. 2018 MAY 2</item>
        <item>C. 3/7/14</item>
        <item>C. 5/9/14</item>
        <item>C. 2,1,2</item>
        <item>C. none none</item>
    </string-array>


    <string-array name="keysDForDatesStringsAndLocalization">
        <item>D. Whales.properties</item>
        <item>D. Dolphins_fr.properties and Dolphins.properties</item>
        <item>D. The code does not compile.</item>
        <item>D. Another date</item>
        <item>D. 2021 APRIL 2</item>
        <item>D. 5/10/15</item>
        <item>D. 5/10/14</item>
        <item>D. 2,1,3</item>
        <item>D. none null</item>
    </string-array>


    <string-array name="keysEForDatesStringsAndLocalization">
        <item>E. Whales_en_US.properties</item>
        <item>E. Dolphins_fr.properties and Dolphins_en.properties</item>
        <item>E. A runtime exception is thrown</item>
        <item>E. The code does not compile.</item>
        <item>E. 2021 APRIL 30</item>
        <item>E. 11:22 AM</item>
        <item>E. The code does not compile.</item>
        <item>E. The code does not compile.</item>
        <item>E. The code does not compile</item>
    </string-array>


    <string-array name="keysFForDatesStringsAndLocalization">
        <item>F. The code does not compile.</item>
        <item>F. The code does not compile.</item>
        <item>F. ~</item>
        <item>F. A runtime exception is thrown</item>
        <item>F. 2021 MAY 2</item>
        <item>F. The code does not compile.</item>
        <item>G. A runtime exception is thrown</item>
        <item>F. A runtime exception is thrown.</item>
        <item>F. A runtime exception is thrown.</item>
    </string-array>




<!--    qwertyuiop-->


    <string-array name="OCAOCP">
        <!--        1-->
        <item> What is the result of the following code?
            \n1: String s1 = "Java";
            \n2: String s2 = "Java";
            \n3: StringBuilder sb1 = new StringBuilder();
            \n4: sb1.append("Ja").append("va");
            \n5: System.out.println(s1 == s2);
            \n6: System.out.println(s1.equals(s2));
            \n7: System.out.println(sb1.toString() == s1);
            \n8: System.out.println(sb1.toString().equals(s1));
        </item>
        <!--        2-->
        <item>
             What is the output of the following program?
            \n1: public class FeedingSchedule {
            \n2: public static void main(String[] args) {
            \n3: boolean keepGoing = true;
            \n4: int count = 0;
            \n5: int x = 3;
            \n6: while(count++ &#60; 3) {
            \n7: int y = (1 + 2 * count) % 3;
            \n8: switch(y) {
            \n9: default:
            \n10: case 0: x -= 1; break;
            \n11: case 1: x += 5;
            \n12: }
            \n13: }
            \n14: System.out.println(x);
            \n15: } }
        </item>
        <!--        3-->
        <item>
             What is the output of the following code snippet?
\n13: System.out.print("a");
\n14: try {
\n15: System.out.print("b");
\n16: throw new IllegalArgumentException();
\n17: } catch (RuntimeException e) {
\n18: System.out.print("c");
\n19: } finally {
\n20: System.out.print("d");
\n21: }
\n22: System.out.print("e");
        </item>
        <!--        4-->
        <item>
            What is the result of the following program?
\n1: public class MathFunctions {
\n2: public static void addToInt(int x, int amountToAdd) {
\n3: x = x + amountToAdd;
\n4: }
\n5: public static void main(String[] args) {
\n6: int a = 15;
\n7: int b = 10;
\n8: MathFunctions.addToInt(a, b);
\n9: System.out.println(a); } }
        </item>
        <!--        5-->
        <item>
             What is the result of the following code?
\nint[] array = {6,9,8};
\nList&#60;Integer&#62; list = new ArrayList&#60;&#62;();
  \n          list.add(array[0]);
\nlist.add(array[2]);
\nlist.set(1, array[1]);
\nlist.remove(0);
\nSystem.out.println(list);
        </item>
        <!--        6-->
        <item>
             What is the output of the following code?
\n1: public class Deer {
\n2: public Deer() { System.out.print("Deer"); }
\n3: public Deer(int age) { System.out.print("DeerAge"); }
\n4: private boolean hasHorns() { return false; }
\n5: public static void main(String[] args) {
\n6: Deer deer = new Reindeer(5);
\n7: System.out.println(","+deer.hasHorns());
\n8: }
\n9: }
\n10: class Reindeer extends Deer {
\n11: public Reindeer(int age) { System.out.print("Reindeer"); }
\n12: public boolean hasHorns() { return true; }
\n13: }
        </item>
        <!--        7-->
        <item>
             What is the output of the following program?
\n1: public class FeedingSchedule {
\n2: public static void main(String[] args) {
\n3: int x = 5, j = 0;
\n4: OUTER: for(int i=0; i&#60;3; )
\n5: INNER: do {
\n6: i++; x++;
\n7: if(x > 10) break INNER;
\n8: x += 4;
\n9: j++;
\nn10: } while(j &#60;= 2);
\n11: System.out.println(x);
\n12: } }
        </item>
        <!--        8-->
        <item>
             What is the result of the following program?
\n1: public class Egret {
\n2: private String color;
\n3: public Egret() {
\n4: this("white");
\n5: }
\n6: public Egret(String color) {
\n7: color = color;
\n8: }
\n9: public static void main(String[] args) {
\n10: Egret e = new Egret();
\n11: System.out.println("Color:" + e.color);
\n12: }
\n13: }
        </item>
        <!--        9-->
        <item>
             What is the output of the following program?
\n1: public class BearOrShark {
\n2: public static void main(String[] args) {
\n3: int luck = 10;
\n4: if((luck>10 ? luck++: —luck)&#60;10) {
\n5: System.out.print("Bear");
\n6: } if(luck&#60;10) System.out.print("Shark");
\n7: } }
        </item>
        <!--        10-->
        <item>
              Bytecode is in a file with which extension?
        </item>


        <!--        1-->
        <item>What is the output of the following application?
\n1: public class CompareValues {
\n2: public static void main(String[] args) {
\n3: int x = 0;
\n4: while(x++ &#60; 10) {}
\n5: String message = x > 10 ? "Greater than" : false;
\n6: System.out.println(message+","+x);
\n7: }
\n8: }</item>
        <!--        2-->
        <item>
              What is the output of the following code snippet?
\n3: java.util.List&#60;Integer&#62; list = new java.util.ArrayList&#60;Integer&#62;();
\n4: list.add(10);
\n5: list.add(14);
\n6: for(int x : list) {
\n7: System.out.print(x + ", ");
\n8: break;
\n9: }
        </item>
        <!--        3-->
        <item> What is the output of the following code snippet?
\n3: int x = 4;
\n4: long y = x * 4 - x++;
\n5: if(y&#60;10) System.out.println("Too Low");
\n6: else System.out.println("Just right");
\n7: else System.out.println("Too High");
</item>
        <!--        4-->
        <item>
             What is the output of the following code?
\n1: public class TernaryTester {
\n2: public static void main(String[] args) {
\n3: int x = 5;
\n4: System.out.println(x > 2 ? x &#60; 4 ? 10 : 8 : 7);
\n5: }}
        </item>
        <!--        5-->
        <item>
             What is the output of the following code snippet?
\n3: boolean x = true, z = true;
\n4: int y = 20;
\n5: x = (y != 10) ^ (z=false);
\n6: System.out.println(x+", "+y+", "+z);
        </item>
        <!--        6-->
        <item>
             How many times will the following code print "Hello World"?
\n3: for(int i=0; i&#60;10 ; ) {
\n4: i = i++;
\n5: System.out.println("Hello World");
\n6: }
        </item>
        <!--        7-->
        <item>
              What is the output of the following code?
\n3: byte a = 40, b = 50;
\n4: byte sum = (byte) a + b;
\n5: System.out.println(sum);
        </item>
        <!--        8-->
        <item>
             What is the output of the following code?
\n1: public class ArithmeticSample {
\n2: public static void main(String[] args) {
\n3: int x = 5 * 4 % 3;
\n4: System.out.println(x);
\n5: }}
        </item>
        <!--        9-->
        <item>
             What is the output of the following code snippet?
\n3: int x = 0;
\n4: String s = null;
\n5: if(x == s) System.out.println("Success");
\n6: else System.out.println("Failure");
        </item>
        <!--        10-->
        <item>
              What is the output of the following code snippet?
\n3: int x1 = 50, x2 = 75;
\n4: boolean b = x1 >= x2;
\n5: if(b = true) System.out.println("Success");
\n6: else System.out.println("Failure");
        </item>
        <!--        11-->
        <item>
             What is the output of the following code snippet?
\n3: int c = 7;
\n4: int result = 4;
  \n          5: result += ++c;
\n6: System.out.println(result);
        </item>
        <!--        12-->
        <item>
              What is the output of the following code snippet?
\n3: int x = 1, y = 15;
\n4: while x &#60; 10
\n5: y––;
\n6: x++;
\n7: System.out.println(x+", "+y);
        </item>
        <!--        13-->
        <item>
              What is the output of the following code snippet?
\n3: do {
\n4: int y = 1;
\n5: System.out.print(
            \n6: } while(y &#60;= 10);
        </item>
        <!--        14-->
        <item>
            What is the output of the following code snippet?
\n3: boolean keepGoing = true;
\n4: int result = 15, i = 10;
\n5: do {
\n6: i-\-;
\n7: if(i==8) keepGoing = false;
\n8: result -= 2;
\n9: } while(keepGoing);
            \n10: System.out.println(result);
        </item>
        <!--        15-->
        <item>
              What is the output of the following code snippet?
\n3: int count = 0;
\n4: ROW_LOOP: for(int row = 1; row &#60;=3; row++)
\n5: for(int col = 1; col &#60;=2 ; col++) {
\n6: if(row * col % 2 == 0) continue ROW_LOOP;
\n7: count++;
\n8: }
\n9: System.out.println(count);
        </item>
        <!--        16-->
        <item>
             What is the result of the following code snippet?
\n3: int m = 9, n = 1, x = 0;
\n4: while(m > n) {
\n5: m—;
\n6: n += 2;
\n7: x += m + n;
\n8: }
\n9: System.out.println(x);
        </item>
        <!--        17-->
        <item>
             What is the result of the following code snippet?
\n3: final char a = \'A\', d = \'D\';
\n4: char grade = \'B\';
            \n5: switch(grade) {
\n6: case a:
\n7: case \'B\': System.out.print("great");
\n8: case \'C\': System.out.print("good"); break;
\n9: case d:
\n10: case \'F\': System.out.print("not good");
\n11: }
        </item>
        <!--        18-->
        <item>
             What is the output of the following program?
\n\n1: public class WaterBottle {
\n2: private String brand;
\n3: private boolean empty;
\n4: public static void main(String[] args) {
\n5: WaterBottle wb = new WaterBottle();
\n6: System.out.print("Empty = " + wb.empty);
\n7: System.out.print(", Brand = " + wb.brand);
\n8: } }
        </item>
        <!--        19-->
        <item> Given the following classes, what is the maximum number of imports that can be removed
and have the code still compile?
\n\npackage aquarium; public class Water { }
\npackage aquarium;
\nimport java.lang.*;
\nimport java.lang.System;
\nimport aquarium.Water;
\nimport aquarium.*;
\npublic class Tank {
 \npublic void print(Water water) {
 \nSystem.out.println(water); } }</item>
        <!--        20-->
        <item> What does the following code output?
\n\n1: public class Salmon {
\n2: int count;
\n3: public void Salmon() {
\n4: count = 4;
\n5: }
\n6: public static void main(String[] args) {
\n7: Salmon s = new Salmon();
\n8: System.out.println(s.count);
\n9: } }</item>

        <!--        1-->
        <item>
            What is the result of the following code?
\n7: StringBuilder sb = new StringBuilder();
\n8: sb.append("aaa").insert(1, "bb").insert(4, "ccc");
\n9: System.out.println(sb);
        </item>
        <!--        2-->
        <item>
             What is the result of the following code?
\n2: String s1 = "java";
\n3: StringBuilder s2 = new StringBuilder("java");
\n4 if (s1 == s2)
\n5: System.out.print("1");
\n6: if (s1.equals(s2))
\n7: System.out.print("2");
        </item>
        <!--        3-->
        <item>
             What is the result of the following code?
\npublic class Lion {
 \npublic void roar(String roar1, StringBuilder roar2) {
 \nroar1.concat("!!!");
 \nroar2.append("!!!");
 \n}
\npublic static void main(String[] args) {
 \nString roar1 = "roar";
 \nStringBuilder roar2 = new StringBuilder("roar");
 \nnew Lion().roar(roar1, roar2);
\n             System.out.println(roar1 + " " + roar2);
\n} }
        </item>
        <!--        4-->
        <item>
             What is the result of the following code?
\n3: String s = "purr";
\n4: s.toUpperCase();
\n5: s.trim();
\n6: s.substring(1, 3);
            \n7: s += " two";
\n8: System.out.println(s.length());
        </item>
        <!--        5-->
        <item>
             What is the result of the following code?
\n4: int total = 0;
\n5: StringBuilder letters = new StringBuilder("abcdefg");
\n6: total += letters.substring(1, 2).length();
\n7: total += letters.substring(6, 6).length();
\n8: total += letters.substring(6, 5).length();
\n9: System.out.println(total);
        </item>
        <!--        6-->
        <item>
             What is the result of the following code?
\nStringBuilder b = "rumble";
\nb.append(4).deleteCharAt(3).delete(3, b.length() - 1);
\nSystem.out.println(b);
        </item>
        <!--        7-->
        <item>
            What is the result of the following statements?
\n6: List&#60;String&#62; list = new ArrayList&#60;String&#62;();
\n7: list.add("one");
\n8: list.add("two");
\n9: list.add(7);
\n10: for(String s : list) System.out.print(s);
        </item>
        <!--        8-->
        <item>
            What is the result of the following statements?
\n3: ArrayList&#60;Integer&#62; values = new ArrayList&#60;&#62;();
\n4: values.add(4);
\n5: values.add(5);
\n6: values.set(1, 6);
\n7: values.remove(0);
\n8: for (Integer v : values) System.out.print(v);
        </item>
        <!--        9-->
        <item>
             What is the result of the following?
\nint[] random = { 6, -4, 12, 0, -10 };
\nint x = 12;
\nint y = Arrays.binarySearch(random, x);
\nSystem.out.println(y);
        </item>
        <!--        10-->
        <item>
            What is the result of the following?
\n4: List&#60;Integer&#62; list = Arrays.asList(10, 4, -1, 5);
\n5: Collections.sort(list);
\n6: Integer array[] = list.toArray(new Integer[4]);
\n7: System.out.println(array[0]);
        </item>
        <!--        11-->
        <item>
            What is the result of the following?
\n6: String [] names = {"Tom", "Dick", "Harry"};
\n7: List&#60;String&#62; list = names.asList();
\n8: list.set(0, "Sue");
\n9: System.out.println(names[0]);
        </item>
        <!--        12-->
        <item>
             What is the result of the following?
\nList&#60;String&#62; hex = Arrays.asList("30", "8", "3A", "FF");
\nCollections.sort(hex);
\nint x = Collections.binarySearch(hex, "8");
\nint y = Collections.binarySearch(hex, "3A");
\nint z = Collections.binarySearch(hex, "4F");
\nSystem.out.println(x + " " + y + " " + z);
        </item>
        <!--        13-->
        <item>
              What is the result of the following?
\nList&#60;String&#62; one = new ArrayList&#60;String>();
\none.add("abc");
\nList&#60;String> two = new ArrayList&#60;>();
\ntwo.add("abc");
\nif (one == two)
 \nSystem.out.println("A");
\nelse if (one.equals(two))
 \nSystem.out.println("B");
\nelse
 \nSystem.out.println("C");
        </item>
        <!--        14-->
        <item>
             What is the output of the following code?
\nLocalDate date = LocalDate.parse("2018-04-30", DateTimeFormatter.ISO_LOCAL_
\nDATE);
\ndate.plusDays(2);
\ndate.plusHours(3);
\nSystem.out.println(date.getYear() + " " + date.getMonth() + " "
\n+ date.getDayOfMonth());
        </item>
        <!--        15-->
        <item>
              What is the output of the following code?
\nLocalDate date = LocalDate.of(2018, Month.APRIL, 40);
\nSystem.out.println(date.getYear() + " " + date.getMonth() + " "
\n+ date.getDayOfMonth());
        </item>
        <!--        16-->
        <item>
             What is the output of the following code?
\nLocalDate date = LocalDate.of(2018, Month.APRIL, 30);
\ndate.plusDays(2);
\ndate.plusYears(3);
\nSystem.out.println(date.getYear() + " " + date.getMonth() + " "
\n+ date.getDayOfMonth());
        </item>
        <!--        17-->
        <item>
             What is the output of the following code?
\nLocalDateTime d = LocalDateTime.of(2015, 5, 10, 11, 22, 33);
\nPeriod p = Period.of(1, 2, 3);
\nd = d.minus(p);
\nDateTimeFormatter f = DateTimeFormatter.ofLocalizedTime(FormatStyle.SHORT);
\nSystem.out.println(d.format(f));
        </item>
        <!--        18-->
        <item>
             What is the output of the following code?
\nLocalDateTime d = LocalDateTime.of(2015, 5, 10, 11, 22, 33);
\nPeriod p = Period.ofDays(1).ofYears(2);
\nd = d.minus(p);
\nDateTimeFormatter f = DateTimeFormatter.ofLocalizedDateTime(FormatStyle
\n.SHORT);
\nSystem.out.println(f.format(d));
        </item>

        <!--        1-->
        <item>  What is the output of the following code?
\n1: package rope;
\n2: public class Rope {
\n3: public static int LENGTH = 5;
\n4: static {
\n5: LENGTH = 10;
\n6: }
\n7: public static void swing() {
\n8: System.out.print("swing ");
\n9: }
\n1n0: }\n
            \n1: import rope.*;
\n2: import static rope.Rope.*;
\n3: public class Chimp {
\n4: public static void main(String[] args) {
\n5: Rope.swing();
\n6: new Rope().swing();
\n7: System.out.println(LENGTH);
\n8: }
\n9: }
        </item>
        <!--        2-->
        <item>
              What is the output of the following code?
\nimport rope.*;
\nimport static rope.Rope.*;
\npublic class RopeSwing {
 \nprivate static Rope rope1 = new Rope();
 \nprivate static Rope rope2 = new Rope();
 \n{
 \nSystem.out.println(rope1.length);
 \n}
 \npublic static void main(String[] args) {
 \nrope1.length = 2;
 \nrope2.length = 8;
 \nSystem.out.println(rope1.length);
 \n}
\n}
\npackage rope;
\npublic class Rope {
 \npublic static int length = 0;
            \n}
        </item>
        <!--        3-->
        <item>
             How many compiler errors are in the following code?
\n1: public class RopeSwing {
\n2: private static final String leftRope;
\n3: private static final String rightRope;
\n4: private static final String bench;
\n5: private static final String name = "name";
\n6: static {
\n7: leftRope = "left";
\n8: rightRope = "right";
\n9: }
\n10: static {
\n11: name = "name";
\n12: rightRope = "right";
\n13: }
\n14: public static void main(String[] args) {
\n15: bench = "bench";
\n16: }
\n17: }
        </item>
        <!--        4-->
        <item>
             What is the result of the following statements?
\n1: public class Test {
\n2: public void print(byte x) {
\n3: System.out.print("byte");
\n4: }
\n5: public void print(int x) {
\n6: System.out.print("int");
\n7: }
\n8: public void print(float x) {
\n9: System.out.print("float");
\n10: }
\n11: public void print(Object x) {
\n12: System.out.print("Object");
\n13: }
\n14: public static void main(String[] args) {
\n15: Test t = new Test();
\n16: short s = 123;
\n17: t.print(s);
\n18: t.print(true);
\n19: t.print(6.789);
\n20: }
\n21: }
        </item>
        <!--        5-->
        <item>
             What is the result of the following program?
\n1: public class Squares {
\n2: public static long square(int x) {
\n3: long y = x * (long) x;
\n4: x = -1;
\n5: return y;
\n6: }
\n7: public static void main(String[] args) {
\n8: int value = 9;
\n9: long result = square(value);
\n10: System.out.println(value);
\n11: } }
        </item>
        <!--        6-->
        <item>
              Which code can be inserted to have the code print 2?
\npublic class BirdSeed {
 \nprivate int numberBags;
 \nboolean call;
 \npublic BirdSeed() {
 \n// LINE 1
 \ncall = false;
 \n// LINE 2
 \n}
 \npublic BirdSeed(int numberBags) {
 \nthis.numberBags = numberBags;
 \n}
 \npublic static void main(String[] args) {
 \nBirdSeed seed = new BirdSeed();
 \nSystem.out.println(seed.numberBags);
 \n} }
        </item>
        <!--        7-->
        <item>
            What is the result of the following?
\n1: public class Order {
\n2: static String result = "";
\n3: { result += "c"; }
\n4: static
\n5: { result += "u"; }
\n6: { result += "r"; }
\n7: }
            \n
\n1: public class OrderDriver {
\n2: public static void main(String[] args) {
\n3: System.out.print(Order.result + " ");
\n4: System.out.print(Order.result + " ");
\n5: new Order();
\n6: new Order();
\n7: System.out.print(Order.result + " ");
\n8: }
\n9: }
        </item>
        <!--        8-->
        <item>
             What is the result of the following?
\n1: public class Order {
\n2: String value = "t";
\n3: { value += "a"; }
\n4: { value += "c"; }
\n5: public Order() {
\n6: value += "b";
\n7: }
\n8: public Order(String s) {
\n9: value += s;
\n10: }
\n11: public static void main(String[] args) {
\n12: Order order = new Order("f");
\n13: order = new Order();
\n14: System.out.println(order.value);
\n15: } }
        </item>
        <!--        9-->
        <item>
             What is the result of the following class?
\n1: import java.util.function.*;
\n2:
\n3: public class Panda {
\n4: int age;
\n5: public static void main(String[] args) {
\n6: Panda p1 = new Panda();
\n7: p1.age = 1;
\n8: check(p1, p -> p.age &#60; 5);
\n9: }
\n10: private static void check(Panda panda, Predicate&#60;Panda> pred) {
\n11: String result = pred.test(panda) ? "match" : "not match";
\n12: System.out.print(result);
\n13: } }
        </item>
        <!--        10-->
        <item>
             What is the result of the following code?
\n1: interface Climb {
\n2: boolean isTooHigh(int height, int limit);
\n3: }
\n4:
\n5: public class Climber {
\n6: public static void main(String[] args) {
\n7: check((h, l) -> h.append(l).isEmpty(), 5);
\n8: }
\n9: private static void check(Climb climb, int height) {
\n10: if (climb.isTooHigh(height, 10))
\n11: System.out.println("too high");
\n12: else
\n13: System.out.println("ok");
\n14: }
\n15: }
        </item>

        <!--        1-->
        <item>
             What is the output of the following code?
\n1: class Mammal {
\n2: public Mammal(int age) {
\n3: System.out.print("Mammal");
\n4: }
\n5: }
\n6: public class Platypus extends Mammal {
\n7: public Platypus() {
\n8: System.out.print("Platypus");
\n9: }
\n10: public static void main(String[] args) {
\n11: new Mammal(5);
\n12: }
\n13: }
        </item>
        <!--        2-->
        <item>
             Choose the correct statement about the following code:
\n1: interface HasExoskeleton {
\n2: abstract int getNumberOfSections();
\n3: }
\n4: abstract class Insect implements HasExoskeleton {
\n5: abstract int getNumberOfLegs();
\n6: }
\n7: public class Beetle extends Insect {
\n8: int getNumberOfLegs() { return 6; }
\n9: }
        </item>
        <!--        3-->
        <item>
             Choose the correct statement about the following code:
\n1: public interface Herbivore {
\n2: int amount = 10;
\n3: public static void eatGrass();
\n4: public int chew() {
\n5: return 13;
\n6: }
\n7: }
        </item>
        <!--        4-->
        <item>
            Choose the correct statement about the following code:
\n1: public interface CanFly {
\n2: void fly();
\n3: }
\n4: interface HasWings {
\n5: public abstract Object getWindSpan();
\n6: }
\n7: abstract class Falcon implements CanFly, HasWings {
\n8: }
        </item>
        <!--        5-->
        <item>
             What is the output of the following code?
\n1: interface Nocturnal {
\n2: default boolean isBlind() { return true; }
\n3: }
\n4: public class Owl implements Nocturnal {
\n5: public boolean isBlind() { return false; }
\n6: public static void main(String[] args) {
\n7: Nocturnal nocturnal = (Nocturnal)new Owl();
\n8: System.out.println(nocturnal.isBlind());
\n9: }
\n10: }
        </item>
        <!--        6-->
        <item>
            What is the output of the following code?
\n1: class Arthropod
\n2: public void printName(double input) { System.out
 .print("Arthropod"); }
\n3: }
\n4: public class Spider extends Arthropod {
\n5: public void printName(int input) { System.out.print("Spider"); }
\n6: public static void main(String[] args) {
\n7: Spider spider = new Spider();
\n8: spider.printName(4);
\n9: spider.printName(9.0);
\n10: }
\n11: }
        </item>
        <!--        7-->
        <item>
             What is the output of the following code?
\n1: abstract class Reptile {
\n2: public final void layEggs() { System.out.println("Reptile laying eggs");
 \n}
\n3: public static void main(String[] args) {
\n4: Reptile reptile = new Lizard();
\n5: reptile.layEggs();
\n6: }
\n7: }
\n8: public class Lizard extends Reptile {
\n9: public void layEggs() { System.out.println("Lizard laying eggs"); }
\n10: }
        </item>
        <!--        8-->
        <item>
             What is the output of the following code?
\n1: public abstract class Whale {
\n2: public abstract void dive() {};
\n3: public static void main(String[] args) {
\n4: Whale whale = new Orca();
\n5: whale.dive();
\n6: }
\n7: }
\n8: class Orca extends Whale {
\n9: public void dive(int depth) { System.out.println("Orca diving"); }
\n10: }
        </item>
        <!--        9-->
        <item>
              What is the result of the following code?
\n1: public abstract class Bird {
\n2: private void fly() { System.out.println("Bird is flying"); }
\n3: public static void main(String[] args) {
\n4: Bird bird = new Pelican();
\n5: bird.fly();
\n6: }
\n7: }
\n8: class Pelican extends Bird {
\n9: protected void fly() { System.out.println("Pelican is flying"); }
\n10: }
        </item>


        <!--        1-->
        <item>
            When are you required to use a finally block in a regular try statement (not a try-with-resources)?
        </item>
        <!--        2-->
        <item>
              Which exception will the following throw?
\nObject obj = new Integer(3);
\nString str = (String) obj;
\nSystem.out.println(str);
        </item>
        <!--        3-->
        <item>
             What will happen if you add the statement System.out.println(5 / 0); to a working
main() method?
        </item>
        <!--        4-->
        <item>
             What is printed besides the stack trace caused by the NullPointerException from line 16?
            \n\n1: public class DoSomething {
\n2: public void go() {
\n3: System.out.print("A");
\n4: try {
\n5: stop();
\n6: } catch (ArithmeticException e) {
\n7: System.out.print("B");
\n8: } finally {
\n9: System.out.print("C");
\n10: }
\n11: System.out.print("D");
\n12: }
\n13: public void stop() {
\n14: System.out.print("E");
\n15: Object x = null;
\n16: x.toString();
\n17: System.out.print("F");
\n18: }
\n19: public static void main(String[] args) {
\n20: new DoSomething().go();
\n21: }
\n22: }
        </item>
        <!--        5-->
        <item>
            What is the output of the following snippet, assuming a and b are both 0?
\n3: try {
\n4: return a / b;
\n5: } catch (RuntimeException e) {
\n6: return -1;
\n7: } catch (ArithmeticException e) {
\n8: return 0;
\n9: } finally {
\n10: System.out.print("done");
\n11: }
        </item>
        <!--        6-->
        <item>
            What is the output of the following program?
\n1: public class Laptop {
\n2: public void start() {
\n3: try {
\n4: System.out.print("Starting up ");
\n5: throw new Exception();
\n6: } catch (Exception e) {
\n7: System.out.print("Problem ");
\n8: System.exit(0);
\n9: } finally {
\n10: System.out.print("Shutting down ");
\n11: }
\n12: }
\n13: public static void main(String[] args) {
\n14: new Laptop().start();
\n15: } }
        </item>
        <!--        7-->
        <item>
             What is the output of the following program?
\n1: public class Dog {
\n2: public String name;
\n3: public void parseName() {
\n4: System.out.print("1");
\n5: try {
\n6: System.out.print("2");
\n7: int x = Integer.parseInt(name);
\n8: System.out.print("3");
\n9: } catch (NumberFormatException e) {
\n10: System.out.print("4");
\n11: }
\n12: }
\n13: public static void main(String[] args) {
\n14: Dog leroy = new Dog();
\n15: leroy.name = "Leroy";
\n16: leroy.parseName();
\n17: System.out.print("5");
\n18: } }
        </item>
        <!--        8-->
        <item>
            What is the output of the following program?
\n1: public class Cat {
\n2: public String name;
\n3: public void parseName() {
\n4: System.out.print("1");
\n5: try {
\n6: System.out.print("2");
\n7: int x = Integer.parseInt(name);
\n8: System.out.print("3");
\n9: } catch (NullPointerException e) {
\n10: System.out.print("4");
\n11: }
\n12: System.out.print("5");
\n13: }
\n14: public static void main(String[] args) {
\n15: Cat leo = new Cat();
\n16: leo.name = "Leo";
\n17: leo.parseName();
\n18: System.out.print("6");
\n19: }
\n20: }
        </item>
        <!--        9-->
        <item>
             Which scenario is the best use of an exception?
        </item>


        <!--        1-->
        <item>
             What is the result of the following program?
\n\n1: public abstract class Message {
\n2: public String recipient;
\n3: public abstract final void sendMessage();
\n4: public static void main(String[] args) {
\n5: Message m = new TextMessage();
\n6: m.recipient = "1234567890";
\n7: m.sendMessage();
\n8: }
\n9: static class TextMessage extends Message {
\n10: public final void sendMessage() {
\n11: System.out.println("Text message to " + recipient);
\n12: } } }
        </item>
        <!--        2-->
        <item>
             What is the result of the following class?
\n\n1: public class Box&#60;T> {
\n2: T value;
\n3:
\n4: public Box(T value) {
\n5: this.value = value;
\n6: }
\n7: public T getValue() {
\n8: return value;
\n9: }
\n10: public static void main(String[] args) {
\n11: Box&#60;String> one = new Box&#60;String>("a string");
\n12: Box&#60;Integer> two = new Box&#60;>(123);
\n13: System.out.print(one.getValue());
\n14: System.out.print(two.getValue());
\n15: } }
        </item>
        <!--        3-->
        <item>
             What is the result of executing the following code snippet?
\n\nList&#60;Integer> source = new ArrayList&#60;>(Arrays.asList(1,2,3,4));
\nList&#60;Integer> fish = new CopyOnWriteArrayList&#60;>(source);
\nList&#60;Integer> mammals = Collections.synchronizedList(source);
\nSet&#60;Integer> birds = new ConcurrentSkipListSet&#60;>();
\nbirds.addAll(source);
\nsynchronized(new Integer(10)) {
 \nfor(Integer f: fish) fish.add(4); // c1
\nfor(Integer m: mammals) mammals.add(4); // c2
 \nfor(Integer b: birds) birds.add(5); // c3
 \nSystem.out.println(fish.size()+" "+mammals.size()+" "+birds.size());
\n}
        </item>
        <!--        4-->
        <item>
            Assuming the current directory /bats/day and all of the files and directories referenced
here exist and are available within the file system, what is the result of executing the following code?
\n\nPath path1 = Paths.get("/bats/night","../").resolve(Paths.get(
"./sleep.txt")).normalize();
\n\nPath path2 = new File("../sleep.txt").toPath().toRealPath();
\n\nSystem.out.print(Files.isSameFile(path1,path2));
\nSystem.out.print(" "+path1.equals(path2));
        </item>
        <!--        5-->
        <item>
             Which of the following statements is true when the code is run with java AssertDemo?
\n\n1: public class AssertDemo {
\n2: public static void main(String [] args) {
\n3: Integer x = 10;
\n4: x++;
\n5: assert x == null &amp;&amp; x >= 0;
\n6: System.out.println(x);
\n7: }
\n8: }
        </item>
        <!--        6-->
        <item>
             Suppose that we have the following property files and code. Which bundle is used on lines 7 and 8, respectively?
\n\nDolphins.properties
\nname=The Dolphin
\nage=0
\nDolphins_fr.properties
\nname=Dolly
\nDolphins_fr_CA.properties
\nname=Dolly
\nage=4
\n\n5: Locale fr = new Locale("fr");
\n6: ResourceBundle b = ResourceBundle.getBundle("Dolphins", fr);
\n7: b.getString("name");
\n8: b.getString("age");
        </item>
        <!--        7-->
        <item>
            How many compilation issues are in the following code?
\n\n1: public class Compiles {
\n2: class RainException extends Exception {}
\n3:
\n4: public static void main(String[] args) {
\n5: try(Scanner s = new Scanner("rain"); String line = "";) {
\n6: if (s.nextLine().equals("rain"))
\n7: throw new RainException();
\n8: } finally {
\n9: s.close();
\n10: } } }
        </item>
        <!--        8-->
        <item>
             What is the result of the following code?
\n\n1: public class VisitPark {
\n2: enum AnimalsInPark {
\n3: SQUIRREL, CHIPMUNK, SPARROW;
\n4: }
\n5: public static void main(String[] args) {
\n6: AnimalsInPark[] animals = AnimalsInPark.values();
\n7: System.out.println(animals[1]);
\n8: } }
        </item>
        <!--        9-->
        <item>
             Which of the answer choices is printed out by the following code?
\n\nString d = Duration.ofDays(1).toString();
\nString p = Period.ofDays(1).toString();
\nboolean b1 = d == p;
\nboolean b2 = d.equals(p);
\nSystem.out.println(b1 + " " + b2);
        </item>
        <!--        10-->
        <item>
             Assume that today is June 1, 2016. What is the result of the following?
\n\nStream&#60;LocalDate> s = Stream.of(LocalDate.now());
\nUnaryOperator&#60;LocalDate> u = l -> l;
\ns.filter(l -> l != null).map(u).peek(System.out::println);
        </item>


        <!--        1-->
        <item>
             What is the result of the following code?
\n1: public class Employee {
\n2: public int employeeId;
\n3: public String firstName, lastName;
\n4: public int yearStarted;
\n5: @Override public int hashCode() {
\n6: return employeeId;
\n7: }
\n8: public boolean equals(Employee e) {
\n9: return this.employeeId == e.employeeId;
\n10: }
\n11: public static void main(String[] args) {
\n12: Employee one = new Employee();
\n13: one.employeeId = 101;
\n14: Employee two = new Employee();
\n15: two.employeeId = 101;
\n16: if (one.equals(two)) System.out.println("Success");
\n17: else System.out.println("Failure");
\n18: } }
        </item>
        <!--        2-->
        <item>
            What is the result of compiling the following class?
\n\npublic class Book {
 \nprivate int ISBN;
 \nprivate String title, author;
 \nprivate int pageCount;
 \npublic int hashCode() {
 \nreturn ISBN;
 \n}
 \n@Override public boolean equals(Object obj) {
 \nif ( !(obj instanceof Book)) {
\nreturn false;
 \n}
 \nBook other = (Book) obj;
 \nreturn this.ISBN == other.ISBN;
 \n}
\n// imagine getters and setters are here
\n}
        </item>
        <!--        3-->
        <item>
             What is the result of the following code?
\n\nString s1 = "Canada";
\nString s2 = new String(s1);
\nif(s1 == s2) System.out.println("s1 == s2");
\nif(s1.equals(s2)) System.out.println("s1.equals(s2)");
        </item>
        <!--        4-->
        <item>
             What is true about the following code? You may assume city and mascot are never null.
\n\npublic class BaseballTeam {
 \nprivate String city, mascot;
 \nprivate int numberOfPlayers;
 \npublic boolean equals(Object obj) {
 \nif ( !(obj instanceof BaseballTeam))
 \nreturn false;
 \nBaseballTeam other = (BaseballTeam) obj;
 \nreturn (city.equals(other.city) &amp;&amp; mascot.equals(other.mascot));
 \n}
\npublic int hashCode() {
 \nreturn numberOfPlayers;
 \n}
\n// imagine getters and setters are here
\n}
        </item>
        <!--        5-->
        <item>
             What is the result of the following code?
\n\npublic class FlavorsEnum {
 \nenum Flavors {
 \nVANILLA, CHOCOLATE, STRAWBERRY
 \n}
 \npublic static void main(String[] args) {
 \nSystem.out.println(Flavors.CHOCOLATE.ordinal());
 \n}
\n}
        </item>
        <!--        6-->
        <item>
             What is the result of the following code?
\n\n1: public class Outer {
\n2: private int x = 5;
\n3: protected class Inner {
\n4: public static int x = 10;
\n5: public void go() { System.out.println(x); }
\n6: }
\n7: public static void main(String[] args) {
\n8: Outer out = new Outer();
\n9: Outer.Inner in = out.new Inner();
\n10: in.go();
\n11: } }
        </item>
        <!--        7-->
        <item>
            What is the result of the following code?
\n\n1: public class Outer {
\n2: private int x = 24;
\n3: public int getX() {
\n4: String message = "x is ";
\n5: class Inner {
\n6: private int x = Outer.this.x;
\n7: public void printX() {
\n8: System.out.println(message + x);
\n9: }
\n10: }
\n11: Inner in = new Inner();
\n12: in.printX();
\n13: return x;
\n14: }
\n15: public static void main(String[] args) {
\n16: new Outer().getX();
\n17: } }
        </item>
        <!--        8-->
        <item>
            The following code appears in a file named Book.java. What is the result of compiling the
source file?
\n\n1: public class Book {
\n2: private int pageNumber;
\n3: private class BookReader {
\n4: public int getPage() {
\n5: return pageNumber;
\n6: } } }
        </item>
        <!--        9-->
        <item>
             Which of the following statements can be inserted to make FootballGame compile?
\n\npackage my.sports;
\npublic class Football {
\n             public static final int TEAM_SIZE = 11;
\n}
\npackage my.apps;
\n// INSERT CODE HERE
\npublic class FootballGame {
 \npublic int getTeamSize() { return TEAM_SIZE; }
\n}
        </item>
        <!--        10-->
        <item>
             What is the result of the following code?
\n\npublic class Browsers {
 \nstatic class Browser {
 \npublic void go() {
 \nSystem.out.println("Inside Browser");
 \n}
 \n}
 \nstatic class Firefox extends Browser {
 \npublic void go() {
 \nSystem.out.println("Inside Firefox");
 \n}
 \n}
 \nstatic class IE extends Browser {
 \n@Override public void go() {
 \nSystem.out.println("Inside IE");
 \n}
 \n}
 \npublic static void main(String[] args) {
 \nBrowser b = new Firefox();
 \nIE e = (IE) b;
 \ne.go();
 \n}
\n}
        </item>
        <!--        11-->
        <item>
             Which is a true statement about the following code?
\n\npublic class IsItFurry {
 \nstatic interface Mammal { }
 \nstatic class Furry implements Mammal { }
 \nstatic class Chipmunk extends Furry { }
 \npublic static void main(String[] args) {
 \nChipmunk c = new Chipmunk();
 \nMammal m = c;
 \nFurry f = c;
 \nint result = 0;
 \nif (c instanceof Mammal) result += 1;
 \nif (c instanceof Furry) result += 2;
 \nif (null instanceof Chipmunk) result += 4;
 \nSystem.out.println(result);
 \n} }
        </item>
        <!--        12-->
        <item>
            Which of the following can be inserted in main?
\n\npublic class Outer {
 \nclass Inner { }
\n
 \npublic static void main(String[] args) {
 \n// INSERT CODE HERE
 \n} }
        </item>
        <!--        13-->
        <item>
            What is the result of the following code?
\n\npublic class FourLegged {
 \nString walk = "walk,";
 \nstatic class BabyRhino extends FourLegged {
 \nString walk = "toddle,";
 \n}
 \npublic static void main(String[] args) {
 \nFourLegged f = new BabyRhino();
 \nBabyRhino b = new BabyRhino();
 \nSystem.out.println(f.walk);
 \nSystem.out.println(b.walk);
 \n} }
        </item>


        <!--        1-->
        <item>
             What is the result of the following code?
\n\n1: public interface CanClimb {
\n2: public abstract void climb();
\n3: }
\n4: public interface CanClimbTrees extends CanClimb {}
\n5: public abstract class Chipmunk implements CanClimbTrees {
\n6: public abstract void chew();
\n7: }
\n8: public class EasternChipmunk extends Chipmunk {
\n9: public void chew() { System.out.println("Eastern Chipmunk is Chewing"); }
\n10: }
        </item>
        <!--        2-->
        <item>
            What is the result of the following class?
\n\nimport java.util.function.*;
\npublic class Panda {
 \nint age;
 \npublic static void main(String[] args) {
 \nPanda p1 = new Panda();
 \np1.age = 1;
 \ncheck(p1, p -> p.age &#60; 5); // h1
 \n}
 \nprivate static void check(Panda panda, Predicate&#60;Panda> pred) { // h2
 \nString result = pred.test(panda) ? "match": "not match"; // h3
 \nSystem.out.print(result);
\n} }
        </item>
        <!--        3-->
        <item>
            What is the result of the following code?
\n\n1: public interface CanWalk {
\n2: default void walk() { System.out.println("Walking"); }
\n3: }
\n4: public interface CanRun {
\n5: public default void walk() { System.out.println("Walking"); }
\n6: public abstract void run();
\n7: }
\n8: public interface CanSprint extends CanWalk, CanRun {
\n9: void sprint();
\n10: }
        </item>
        <!--        4-->
        <item>
             What is the result of the following code?
\n\npublic interface Climb {
 \nboolean isTooHigh(int height, int limit);
\n}
\npublic class Climber {
 \npublic static void main(String[] args) {
 \ncheck((h, l) -> h.toString(), 5); // x1
 \n}
 \nprivate static void check(Climb climb, int height) {
 \nif (climb.isTooHigh(height, 10)) // x2
 \nSystem.out.println("too high");
 \nelse System.out.println("ok");
\n} }
        </item>
        <!--        5-->
        <item>
             Choose the correct statement about the following code:
\n\n1: public interface Herbivore {
\n2: int amount = 10;
\n3: public static void eatGrass();
\n4: public int chew() {
\n5: return 13;
\n6: }
\n7: }
        </item>
        <!--        6-->
        <item>
             Choose the correct statement about the following code:
\n\n1: public interface CanFly {
\n2: void fly();
\n3: }
\n4: interface HasWings {
\n5: public abstract Object getWingSpan();
\n6: }
\n7: abstract class Falcon implements CanFly, HasWings {
\n8: }
        </item>

        <!--        1-->
        <item>
             Suppose that you have a collection of products for sale in a database and you need to
display those products. The products are not unique. Which of the following collections
classes in the java.util package best suit your needs for this scenario?
        </item>
        <!--        2-->
        <item>
             Suppose that you need to work with a collection of elements that need to be sorted in their
natural order, and each element has a unique string associated with its value. Which of the
following collections classes in the java.util package best suit your needs for this scenario?
        </item>
        <!--        3-->
        <item>
             What is the result of the following statements?
            \n\n3: List list = new ArrayList();
\n4: list.add("one");
\n5: list.add("two");
\n6: list.add(7);
\n7: for (String s: list)
\n8: System.out.print(s);
        </item>
        <!--        4-->
        <item>
             What is the result of the following statements?
\n\n3: ArrayDeque&#60;String> greetings = new ArrayDeque&#60;String>();
\n4: greetings.push("hello");
\n5: greetings.push("hi");
\n6: greetings.push("ola");
\n7: greetings.pop();
\n8: greetings.peek();
\n9: while (greetings.peek() != null)
\n10: System.out.print(greetings.pop());
        </item>
        <!--        5-->
        <item>
             What is the result of the following code?
\n\n1: public class Hello&#60;T> {
\n2: T t;
\n3: public Hello(T t) { this.t = t; }
\n4: public String toString() { return t.toString(); }
\n5: public static void main(String[] args) {
\n6: System.out.print(new Hello&#60;String>("hi"));
\n7: System.out.print(new Hello("there"));
\n8: } }
        </item>
        <!--        6-->
        <item>
             What is the result of the following code?
\n\nTreeSet&#60;String> tree = new TreeSet&#60;String>();
\ntree.add("one");
\ntree.add("One");
\ntree.add("ONE");
\nSystem.out.println(tree.ceiling("On"));
        </item>
        <!--        7-->
        <item>
             Which of the answer choices are valid given the following declaration?
\n\nMap&#60;String, Double> map = new HashMap&#60;>();
        </item>
        <!--        8-->
        <item>
             What is the result of the following program?
\n\nimport java.util.*;
\npublic class MyComparator implements Comparator&#60;String> {
 \npublic int compare(String a, String b) {
 \nreturn b.toLowerCase().compareTo(a.toLowerCase());
 \n}
 \npublic static void main(String[] args) {
 \nString[] values = { "123", "Abb", "aab" };
 \nArrays.sort(values, new MyComparator());
 \nfor (String s: values)
 \nSystem.out.print(s + " ");
 \n}
\n}
        </item>
        <!--        9-->
        <item>
             What is the result of the following code?
3: Map&#60;Integer, Integer> map = new HashMap&#60;w>(10);
4: for (int i = 1; i &#60;= 10; i++) {
5: map.put(i, i * i);
6: }
7: System.out.println(map.get(4));
        </item>
        <!--        10-->
        <item>
             What is the result of the following program?
\n\nimport java.util.*;
\npublic class Sorted implements Comparable&#60;Sorted>, Comparator&#60;Sorted> {
 \nprivate int num;
 \nprivate String text;
 \nSorted(int n, String t) {
 \nthis.num = n;
 \nthis.text = t;
 \n}
 \npublic String toString() { return "" + num; }
 \npublic int compareTo(Sorted s) { return text.compareTo(s.text); }
 \npublic int compare(Sorted s1, Sorted s2) { return s1.num – s2.num; }
\n\npublic static void main(String[] args) {
 \nSorted s1 = new Sorted(88, "a");
 \nSorted s2 = new Sorted(55, "b");
 \nTreeSet&#60;Sorted> t1 = new TreeSet&#60;>();
 \nt1.add(s1); t1.add(s2);
 \nTreeSet&#60;Sorted> t2 = new TreeSet&#60;>(s1);
 \nt2.add(s1); t2.add(s2);
 \nSystem.out.println(t1 + " " + t2);
 \n} }
        </item>
        <!--        11-->
        <item>
             What is the result of the following code?
\n\nComparator&#60;Integer> c = (o1, o2) -> o2—o1;
\nList&#60;Integer> list = Arrays.asList(5, 4, 7, 1);
\nCollections.sort(list, c);
\nSystem.out.println(Collections.binarySearch(list, 1));
        </item>
        <!--        12-->
        <item>
             What is the result of the following code?
\n\n4: Map m = new HashMap();
\n5: m.put(123, "456");
\n6: m.put("abc", "def");
\n7: System.out.println(m.contains("123"));
        </item>
        <!--        13-->
        <item>
             What code change is needed to make the method compile?
\n\npublic static T identity(T t) {
 \nreturn t;
\n}
        </item>
        <!--        14-->
        <item>
             What is the result of the following?
\n\nMap&#60;Integer, Integer> map = new HashMap&#60;>();
\nmap.put(1, 10);
\nmap.put(2, 20);
\nmap.put(3, null);
\n\nmap.merge(1, 3, (a,b) -> a + b);
\nmap.merge(3, 3, (a,b) -> a + b);
\n\nSystem.out.println(map);
        </item>


        <!--       1-->
        <item>
              What is the output of the following?
        \n\nStream&#60;String> stream = Stream.iterate("", (s) -> s + "1");
        System.out.println(stream.limit(2).map(x -> x + "2"));
        </item>
        <!--        2-->
        <item>
             What is the output of the following?
\n\nPredicate&#60;? super String> predicate = s -> s.startsWith("g");
\nStream&#60;String> stream1 = Stream.generate(() -> "growl! ");
\nStream&#60;String> stream2 = Stream.generate(() -> "growl! ");
\nboolean b1 = stream1.anyMatch(predicate);
\nboolean b2 = stream2.allMatch(predicate);
\nSystem.out.println(b1 + " " + b2);
        </item>
        <!--        3-->
        <item>
             What is the output of the following?
\n\nPredicate&#60;? super String> predicate = s -> s.length() > 3;
\nStream&#60;String> stream = Stream.iterate("-", (s) -> s + s);
\nboolean b1 = stream.noneMatch(predicate);
\nboolean b2 = stream.anyMatch(predicate);
\nSystem.out.println(b1 + " " + b2);
        </item>
        <!--        4-->
        <item>
              Select from the following statements and indicate the order in which they would appear to
output 10 lines:
            \n\n
            Stream.generate(() -> "1")
\nL: .filter(x -> x.length() > 1)
\nM: .forEach(System.out::println)
\nN: .limit(10)
\nO: .peek(System.out::println)
\n;
        </item>
        <!--        5-->
        <item>
             Which of the following is true?
\n\nList&#60;Integer> l1 = Arrays.asList(1, 2, 3);
\nList&#60;Integer> l2 = Arrays.asList(4, 5, 6);
\nList&#60;Integer> l3 = Arrays.asList();
\nStream.of(l1, l2, l3).map(x -> x + 1)
 \n.flatMap(x -> x.stream()).forEach(System.out::print);
        </item>
        <!--        6-->
        <item>
            Which of the following is true?
\n\n\t4: Stream&#60;Integer> s = Stream.of(1);
\n\t5: IntStream is = s.mapToInt(x -> x);
\n\t6: DoubleStream ds = s.mapToDouble(x -> x);
\n\t7: Stream&#60;Integer> s2 = ds.mapToInt(x -> x);
\n\t8: s2.forEach(System.out::print);
        </item>
        <!--        7-->
        <item>
             What is the output of the following?
\n\nStream&#60;String> s = Stream.empty();
\nStream&#60;String> s2 = Stream.empty();
\nMap&#60;Boolean, List&#60;String>> p = s.collect(
 \nCollectors.partitioningBy(b -> b.startsWith("c")));
\nMap&#60;Boolean, List&#60;String>> g = s2.collect(
 \nCollectors.groupingBy(b -> b.startsWith("c")));
\nSystem.out.println(p + " " + g);
        </item>
        <!--        8-->
        <item>
             Which of the following is equivalent to this code?
\n\n\tUnaryOperator&#60;Integer> u = x -> x * x;
        </item>
        <!--        9-->
        <item>
            What is the result of the following?
DoubleStream s = DoubleStream.of(1.2, 2.4);
s.peek(System.out::println).filter(x -> x > 2).count();
        </item>

        <!--        1-->
        <item>
            Assume that all bundles mentioned in the answers exist and define the same keys. Which
one will be used to find the key in line 8?
\n\n\t6: Locale.setDefault(new Locale("en", "US"));
\n\t7: ResourceBundle b = ResourceBundle.getBundle("Dolphins");
\n\t8: b.getString("name");
        </item>
        <!--        2-->
        <item>
             Suppose that we have the following property files and code. Which bundles are used on lines 8 and 9 respectively?
\n\nDolphins.properties
\nname=The Dolphin
\nage=0
\n\nDolphins_en.properties
\nname=Dolly
\nage=4
\n\nDolphins_fr.properties
\nname=Dolly
\n\n\n5: Locale fr = new Locale("fr");
\n6: Locale.setDefault(new Locale("en", "US"));
\n7: ResourceBundle b = ResourceBundle.getBundle("Dolphins", fr);
\n8: b.getString("name");
\n9: b.getString("age");
        </item>
        <!--        3-->
        <item>
             What is the output of the following code?
\n\nLocalDate date = LocalDate.parse(
\n"2018–04–30", DateTimeFormatter.ISO_LOCAL_DATE);
\ndate.plusDays(2);
\ndate.plusHours(3);
\nSystem.out.println(date.getYear() + " "
 \n+ date.getMonth() + " "+ date.getDayOfMonth());
        </item>
        <!--        4-->
        <item>
             What is the output of the following code?
\n\nLocalDate date = LocalDate.of(2018, Month.APRIL, 40);
\nSystem.out.println(date.getYear() + " " + date.getMonth()
 \n+ " "+ date.getDayOfMonth());
        </item>
        <!--        5-->
        <item>
            What is the output of the following code?
\n\nLocalDate date = LocalDate.of(2018, Month.APRIL, 30);
\ndate.plusDays(2);
\ndate.plusYears(3);
\nSystem.out.println(date.getYear() + " "
 \n+ date.getMonth() + " "+ date.getDayOfMonth());
        </item>
        <!--        6-->
        <item>
             What is the output of the following code?
\n\nLocalDateTime d = LocalDateTime.of(2015, 5, 10, 11, 22, 33);
\nPeriod p = Period.of(1, 2, 3);
\nd = d.minus(p);
\nDateTimeFormatter f = DateTimeFormatter.
 \nofLocalizedTime(FormatStyle.SHORT);
\nSystem.out.println(d.format(f));
        </item>
        <!--        7-->
        <item>
             What is the output of the following code?
\n\nLocalDateTime d = LocalDateTime.of(2015, 5, 10, 11, 22, 33);
\nPeriod p = Period.ofDays(1).ofYears(2);
\nd = d.minus(p);
\nDateTimeFormatter f = DateTimeFormatter.
 \nofLocalizedDateTime(FormatStyle.SHORT);
\nSystem.out.println(f.format(d));
        </item>
        <!--        8-->
        <item>
            8. Note that March 13, 2016, is the weekend that clocks spring ahead for daylight savings time. What is the output of the following?
\n\nLocalDate date = LocalDate.of(2016, Month.MARCH, 13);
\nLocalTime time = LocalTime.of(1, 30);
\nZoneId zone = ZoneId.of("US/Eastern");
\nZonedDateTime dateTime1 = ZonedDateTime.of(date, time, zone);
\nZonedDateTime dateTime2 = dateTime1.plus(1, ChronoUnit.HOURS);
\n\nlong hours = ChronoUnit.HOURS.between(dateTime1, dateTime2);
\nint clock1 = dateTime1.getHour();
\nint clock2 = dateTime2.getHour();
\nSystem.out.println(hours + "," + clock1 + "," + clock2);
        </item>
        <!--        9-->
        <item>
            What is the output of the following method if props contains {veggies=brontosaurus,
meat=velociraptor}?
\n\n\nprivate static void print(Properties props) {
 \nSystem.out.println(props.get("veggies", "none")
 \n+ " " + props.get("omni", "none"));
\n}
        </item>

    </string-array>










    <string-array name="AnswerDefinitionForOCAOCP">
        <item>\nAnswer C. \nString literals are used from the string pool. This means that s1 and s2 refer to the
same object and are equal. Therefore, the first two print statements print true. The
third print statement prints false because toString() uses a method to compute the
value and it is not from the string pool. The final print statement again prints true
because equals() looks at the values of String objects.
        </item>
        <!--        ******************-->
        <item>
             \nAnswer C. \nThe code compiles and runs without issue; therefore, option F is incorrect. This type
of problem is best examined one loop iteration at a time:
 \n\n1. The loop continues as count loop expression evaluates to 0 &#60; 3, which is true,
\nwith y taking a new value of 1. The value of y is set to:
\ny = (1 + 2 * 1) % 3
 \n= (1 + 2) % 3
 \n= 3 % 3
 \n= 0
\n\n2. The first case block is called and the value of x is then set to:
\nx = 3 - 1 = 2
\n\n3. The loop continues as count loop expression evaluates to 1 &#60; 3, which is true,
\nwith y taking a new value of 2. The value of y is set to:
\ny = (1 + 2 * 2) % 3
 \n= (1 + 4) % 3
 \n= 4 % 3
 \n= 2
\n\n4. The default block is called and the value of x is set to:
\nx = 2 - 1 = 1
 \n\n5. The loop continues as the count loop expression evaluates to 2 &#60; 3, which is true,
\nwith y taking a new value of 3. The value of y is set to:
\ny = (1 + 2 * 3) % 3
 \n= (1 + 6) % 3
 \n= 7 % 3
 \n= 1
 \n\n6. The second case block is called and the value of x is then set to:
\nx = 1 + 5 = 6
 \n\n7. The loop ends as the count loop expression evaluates to 3 &#60; 3, with y also taking a
\nnew value of 4. The most recent value of x, 6, is output, so the answer is option C.
        </item>
        <!--        **************-->
        <item>
            \nAnswer D. The code starts running and prints a and b on lines 13 and 15. Line 16 throws an
exception, which is caught on line 17. After line 18 prints c, the finally block is run
and d is printed. Then the try statement ends and e is printed on line 22.
        </item>
        <!--        ****************-->
        <item>
             \nAnswer B. The code compiles successfully, so options D and E are incorrect. The value of a
        cannot be changed by the addToInt method, no matter what the method does, because
        only a copy of the variable is passed into the parameter x. Therefore, a does not change
        and the output on line 9 is 15.
        </item>

        <item>
            \nnAnswerB. The array is allowed to use an anonymous initializer because it is in the same line as
the declaration. The ArrayList uses the diamond operator allowed since Java 7. This
specifies the type matches the one on the left without having to re-type it. After adding
the two elements, list contains [6, 8]. We then replace the element at index 1 with 9,
resulting in [6, 9]. Finally, we remove the element at index 0, leaving [9]. Option C
is incorrect because arrays output something like that rather than an ArrayList.
        </item>

        <item>
            \nnAnswer A.First, the Reindeer object is instantiated using the constructor that takes an int value. Since
there is no explicit call to the parent constructor, the default no-argument super()
is inserted as the first line of the constructor. The output is then Deer, followed by
Reindeer in the child constructor, so only options A and B can be correct. Next,
the method hasHorns() looks like an overridden method, but it is actually a hidden
method since it is declared private in the parent class. Because the hidden method is
referenced in the parent class, the parent version is used, so the code outputs false,
and option A is the correct answer.
        </item>

        <item>
            \nnAnswer B. The code compiles and runs without issue; therefore, options E and F are incorrect.
This type of problem is best examined one loop iteration at a time:
\t On the first iteration of the outer loop i is 0, so the loop continues.
\t On the first iteration of the inner loop, i is updated to 1 and x to 6. The if-then
statement branch is not executed, and x is increased to 10 and j to 1.
\t On the second iteration of the inner loop (since j = 1 and 1 &#60;= 2), i is updated
to 2 and x to 11. At this point, the if-then branch will evaluate to true for the
remainder of the program run, which causes the flow to break out of the inner
loop each time it is reached.
\t On the second iteration of the outer loop (since i = 2), i is updated to 3 and x to
12. As before, the inner loop is broken since x is still greater than 10.
\t On the third iteration of the outer loop, the outer loop is broken, as i is already
not less than 3. The most recent value of x, 12, is output, so the answer is option B.
        </item>
        <!--        **********-->
        <item>
             \nnAnswer B. Line 10 calls the constructor on lines 3–5. That constructor calls the other constructor. However, the constructor on lines 6–8 assigns the method parameter to itself,
which leaves the color instance variable on line 2 set to its default value of null.
        </item>
        <!--        ************-->
        <item>
            \nnAnswer C. The code compiles and runs without issue, so options D and E are correct. Remember that only one of the right-hand ternary expressions will be evaluated at runtime.
Since luck is not less than 10, the second expression, -\-luck, will be evaluated, and
since the pre-increment operator was used, the value returned will be 9, which is less
than 10. So the first if-then statement will be visited and Bear will be output. Notice
there is no else statement on line 6. Since luck is still less than 10, the second if-then
statement will also be reached and Shark will be output; therefore, the correct answer
is option C.
        </item>
        <!--        ****************-->
        <item>
            \nnAnswer C. Files with the .java extension contain the Java source code and are compiled to
files with the .class extension that contain the bytecode.
        </item>

        <!--       1-->
        <item>
            \n\tAnswer F. In this example, the ternary operator has two expressions, one of them a String and
the other a boolean value. The ternary operator is permitted to have expressions that
don’t have matching types, but the key here is the assignment to the String reference.
The compiler knows how to assign the first expression value as a String, but the second boolean expression cannot be set as a String; therefore, this line will not compile.
        </item>
        <!--2-->
        <item>
            \n\tAnswer C. This code does not contain any compilation errors or an infinite loop, so options D,
E, and F are incorrect. The break statement on line 8 causes the loop to execute once
and finish, so option C is the correct answer.
        </item>
        <!--3-->
        <item>
            \n\tAnswer F. The code does not compile because two else statements cannot be chained together
without additional if-then statements, so the correct answer is option F. Option E is
incorrect as Line 6 by itself does not cause a problem, only when it is paired with Line
7. One way to fix this code so it compiles would be to add an if-then statement on
line 6. The other solution would be to remove line 7.
        </item>
        <!--4-->
        <item>
            \n\tAnswer D. As you learned in the section “Ternary Operator,” although parentheses are not
required, they do greatly increase code readability, such as the following equivalent
statement:
System.out.println((x > 2) ? ((x &#60; 4) ? 10 : 8) : 7)
We apply the outside ternary operator fi rst, as it is possible the inner ternary expression
may never be evaluated. Since (x>2) is true, this reduces the problem to:
System.out.println((x &#60; 4) ? 10 : 8)
Since x is greater than 2, the answer is 8, or option D in this case.
        </item>
        <!--5-->
        <item>
            \n\tAnswer B. This example is tricky because of the second assignment operator embedded in line
5. The expression (z=false) assigns the value false to z and returns false for the
entire expression. Since y does not equal 10, the left-hand side returns true; therefore,
the exclusive or (^) of the entire expression assigned to x is true. The output reflects
these assignments, with no change to y, so option B is the only correct answer. The
code compiles and runs without issue, so option F is not correct.
        </item>
        <!--6-->
        <item>
            \n\tAnswer F. In this example, the update statement of the for loop is missing, which is fine as the
statement is optional, so option D is incorrect. The expression inside the loop increments i but then assigns i the old value. Therefore, i ends the loop with the same value that it starts with: 0. The loop will repeat infinitely, outputting the same statement over
and over again because i remains 0 after every iteration of the loop.
        </item>
        <!--7-->
        <item>
             \n\t Answer D. Line 4 generates a possible loss of precision compiler error. The cast operator has
the highest precedence, so it is evaluated first, casting a to a byte. Then, the addition is
evaluated, causing both a and b to be promoted to int values. The value 90 is an int
and cannot be assigned to the byte sum without an explicit cast, so the code does not
compile. The code could be corrected with parentheses around (a + b), in which case
option C would be the correct answer.
        </item>
        <!--8-->
        <item>
             \n\tAnswer A. The * and % have the same operator precedence, so the expression is evaluated
from left-to-right. The result of 5 * 4 is 20, and 20 % 3 is 2 (20 divided by 3 is 18, the
remainder is 2). The output is 2 and option A is the correct answer.
        </item>
        <!--9-->
        <item>
             \n\tAnswer D. The variable x is an int and s is a reference to a String object. The two data types
are incomparable because neither variable can be converted to the other variable’s type.
The compiler error occurs on line 5 when the comparison is attempted, so the answer
is option D.
        </item>
        <!--10-->
        <item>
             \n\tAnswer A. The code compiles successfully, so options C and D are incorrect. The value of b
after line 4 is false. However, the if-then statement on line 5 contains an assignment,
not a comparison. The variable b is assigned true on line 3, and the assignment operator returns true, so line 5 executes and displays Success, so the answer is option A.
        </item>
        <!--11-->
        <item>
             \n\tAnswer C. The code compiles successfully, so option F is incorrect. On line 5, the pre-increment operator is used, so c is incremented to 4 and the new value is returned to the
expression. The value of result is computed by adding 4 to the original value of 8,
resulting in a new value of 12, which is output on line 6. Therefore, option C is the
correct answer
        </item>
        <!--12-->
        <item>
            \n\tAnswer E. This is actually a much simpler problem than it appears to be. The while statement
on line 4 is missing parentheses, so the code will not compile, and option E is the correct answer. If the parentheses were added, though, option F would be the correct
answer since the loop does not use curly braces to include x++ and the boolean expression never changes. Finally, if curly braces were added around both expressions, the
output would be 10, 6 and option B would be correct.
        </item>
        <!--13-->
        <item>\n\tAnswer D. The variable y is declared within the body of the do-while statement, so it is out of
scope on line 6. Line 6 generates a compiler error, so option D is the correct answer.
        </item>
        <!--14-->
        <item>
            \n\tAnswer D. The code compiles without issue, so option F is incorrect. After the first execution of the loop, i is decremented to 9 and result to 13. Since i is not 8, keepGoing is
false, and the loop continues. On the next iteration, i is decremented to 8 and result
to 11. On the second execution, i does equal 8, so keepGoing is set to false. At the
conclusion of the loop, the loop terminates since keepGoing is no longer true. The
value of result is 11, and the correct answer is option D.
        </item>
        <!--15-->
        <item>
            \n\tAnswer A. The expression on line 5 is true when row * col is an even number. On the first
iteration, row = 1 and col = 1, so the expression on line 6 is false, the continue is
skipped, and count is incremented to 1. On the second iteration, row = 1 and col = 2, so the expression on line 6 is true and the continue ends the outer loop with
count still at 1. On the third iteration, row = 2 and col = 1, so the expression on line
6 is true and the continue ends the outer loop with count still at 1. On the fourth
iteration, row = 3 and col = 1, so the expression on line 6 is false, the continue is
skipped, and count is incremented to 2. Finally, on the fifth and final iteration, row
= 3 and col = 2, so the expression on line 6 is true and the continue ends the outer
loop with count still at 2. The result of 2 is displayed, so the answer is option B.
        </item>
        <!--16-->
        <item>
            \n\tAnswer D. Prior to the first iteration, m = 9, n = 1, and x = 0. After the iteration of the first
loop, m is updated to 8, n to 3, and x to the sum of the new values for m + n, 0 + 11 =
11. After the iteration of the second loop, m is updated to 7, n to 5, and x to the sum
of the new values for m + n, 11 + 12 = 23. After the iteration of the third loop, m is
updated to 6, n to 7, and x to the sum of the new values for m + n, 23 + 13 = 36. On
the fourth iteration of the loop, m > n evaluates to false, as 6 &#60; 7 is not true. The
loop ends and the most recent value of x, 36, is output, so the correct answer is option
D.
        </item>
        <!--17-->
        <item>
             \n\tAnswer B. The code compiles and runs without issue, so options C, D, and E are not correct. The
value of grade is \'B\' and there is a matching case statement that will cause "great" to
be printed. There is no break statement after the case, though, so the next case statement will be reached, and "good" will be printed. There is a break after this case statement, though, so the switch statement will end. The correct answer is thus option B.
        </item>
        <!--18-->
        <item>
            \n\tAnswer D. Boolean fields initialize to false and references initialize to null, so empty is false
and brand is null. Brand = null is output.
        </item>
        <!--19-->
        <item>
            \n\tAnswer E. The first two imports can be removed because java.lang is automatically imported.
The second two imports can be removed because Tank and Water are in the same package, making the correct answer E. If Tank and Water were in different packages, one of
these two imports could be removed. In that case, the answer would be option D.
        </item>
        <!--20-->
        <item>
            \n\tAnswer A. While the code on line 3 does compile, it is not a constructor because it has a return
type. It is a method that happens to have the same name as the class. When the code
runs, the default constructor is called and count has the default value (0) for an int.
        </item>

        <!--        1-->
        <item>
            \n\tAnswer B. This example uses method chaining. After the call to append(), sb contains "aaa".
That result is passed to the first insert() call, which inserts at index 1. At this point
sb contains abbbaa. That result is passed to the final insert(), which inserts at index
4, resulting in abbaccca.
        </item>
        <!--        2-->
        <item>
            \n\tAnswer F. The question is trying to distract you into paying attention to logical equality versus
object reference equality. It is hoping you will miss the fact that line 4 does not compile. Java does not allow you to compare String and StringBuilder using ==
        </item>
        <!--        3-->
        <item>
            \n\tAnswer B. A String is immutable. Calling concat() returns a new String but does not change
the original. A StringBuilder is mutable. Calling append() adds characters to the
existing character sequence along with returning a reference to the same object.
        </item>
        <!--        4-->
        <item>
             \n\tAnswer C. This question is trying to see if you know that String objects are immutable. Line
4 returns "PURR" but the result is ignored and not stored in s. Line 5 returns "purr"
since there is no whitespace present but the result is again ignored. Line 6 returns "ur"
because it starts with index 1 and ends before index 3 using zero-based indexes. The
result is ignored again. Finally, on line 6 something happens. We concatenate four new
characters to s and now have a String of length 8.
        </item>
        <!--        5-->
        <item>
             \n\tAnswer E. Line 6 adds 1 to total because substring() includes the starting index but not
the ending index. Line 7 adds 0 to total. Line 8 is a problem: Java does not allow the
indexes to be specified in reverse order and the code throws a StringIndexOutOfBoundsException
        </item>
        <!--        6-->
        <item>
            \n\tAnswer F. This is a trick question. The first line does not compile because you cannot
assign a String to a StringBuilder. If that line were StringBuilder b = new
StringBuilder("rumble"), the code would compile and print rum4. Watch out for this
sort of trick on the exam. You could easily spend a minute working out the character
positions for no reason at all.
        </item>
        <!--        7-->
        <item>
             \n\tAnswer D. The code does not compile because list is instantiated using generics. Only String
objects can be added to list and 7 is an int.
        </item>
        <!--        8-->
        <item>
            \n\tAnswer C. After line 4, values has one element (4). After line 5, values has two elements (4,
5). After line 6, values has two elements (4, 6) because set() does a replace. After line
7, values has only one element (6).
        </item>
        <!--        9-->
        <item>
             \n\tAnswer D. The code compiles and runs fine. However, an array must be sorted for binarySearch() to return a meaningful result.
        </item>
        <!--        10-->
        <item>
             \n\tAnswer A. Line 4 creates a fixed size array of size 4. Line 5 sorts it. Line 6 converts it back to
an array. The brackets are not in the traditional place, but they are still legal. Line 7
prints the first element, which is now –1.
        </item>
        <!--        11-->
        <item>
            \n\tAnswer C. Converting from an array to an ArrayList uses Arrays.asList(names). There is
no asList() method on an array instance. If this code were corrected to compile, the
answer would be option A.
        </item>
        <!--        12-->
        <item>
            \n\tAnswer D. After sorting, hex contains [30, 3A, 8, FF]. Remember that numbers sort before
letters and strings sort alphabetically. This makes 30 come before 8. A binary search
correctly finds 8 at index 2 and 3A at index 1. It cannot find 4F but notices it should
be at index 2. The rule when an item isn’t found is to negate that index and subtract 1.
Therefore, we get –2–1, which is –3.
        </item>
        <!--        13-->
        <item>
            \n\tAnswer B. The first if statement is false because the variables do not point to the same object.
The second if statement is true because ArrayList implements equality to mean the
same elements in the same order.
        </item>
        <!--        14-->
        <item>
             \n\tAnswer D. A LocalDate does not have a time element. Therefore, it has no method to add
hours and the code does not compile.
        </item>
        <!--        15-->
        <item>
            \n\tAnswer F. Java throws an exception if invalid date values are passed. There is no 40th day in
April—or any other month for that matter.
        </item>
        <!--        16-->
        <item>
             \n\tAnswer B. The date starts out as April 30, 2018. Since dates are immutable and the plus methods have their return values ignored, the result is unchanged. Therefore, option B is
correct.
        </item>
        <!--        17-->
        <item>
            \n\tAnswer E. Even though d has both date and time, the formatter only outputs time.
        </item>
        <!--        18-->
        <item>
             \n\tAnswer B. Period does not allow chaining. Only the last Period method called counts, so only
the two years are subtracted.
        </item>


        <!--        1-->
        <item>
            \n\tAnswer B. Rope runs line 3, setting LENGTH to 5, then immediately after runs the static initializer, which sets it to 10. Line 5 calls the static method normally and prints swing.
Line 6 also calls the static method. Java allows calling a static method through an
instance variable. Line 7 uses the static import on line 2 to reference LENGTH.
        </item>
        <!--        2-->
        <item>
            \n\tAnswer D. There are two details to notice in this code. First, note that RopeSwing has an
instance initializer and not a static initializer. Since RopeSwing is never constructed,
the instance initializer does not run. The other detail is that length is static. Changes
from one object update this common static variable.
        </item>
        <!--        3-->
        <item>
             \n\tAnswer E. static final variables must be set exactly once, and it must be in the declaration
line or in a static initialization block. Line 4 doesn’t compile because bench is not set
in either of these locations. Line 15 doesn’t compile because final variables are not
allowed to be set after that point. Line 11 doesn’t compile because name is set twice:
once in the declaration and again in the static block. Line 12 doesn’t compile because
rightRope is set twice as well. Both are in static initialization blocks.
        </item>
        <!--        4-->
        <item>
             \n\tAnswer E. The argument on line 17 is a short. It can be promoted to an int, so print() on
line 5 is invoked. The argument on line 18 is a boolean. It can be autoboxed to a boolean, so print() on line 11 is invoked. The argument on line 19 is a double. It can
be autoboxed to a double, so print() on line 11 is invoked. Therefore, the output is
intObjectObject and the correct answer is option E.
        </item>
        <!--        5-->
        <item>
            \n\tAnswer B. Since Java is pass-by-value and the variable on line 8 never gets reassigned, it stays
as 9. In the method square, x starts as 9. y becomes 81 and then x gets set to –1. Line 9
does set result to 81. However, we are printing out value and that is still 9.
        </item>
        <!--        6-->
        <item>
            \n\tAnswer E. Options A and B will not compile because constructors cannot be called without
new. Options C and D will compile but will create a new object rather than setting the
fields in this one. Option F will not compile because this() must be the first line of a
constructor. Option E is correct.
        </item>
        <!--        7-->
        <item>
            \n\tAnswer  E. On line 3 of OrderDriver, we refer to Order for the first time. At this point the statics in Order get initialized. In this case, the statics are the static declaration of result
and the static initializer. result is u at this point. On line 4, result is the same
because the static initialization is only run once. On line 5, we create a new Order,
which triggers the instance initializers in the order they appear in the file. Now result
is ucr. Line 6 creates another Order, triggering another set of initializers. Now result
is ucrcr. Notice how the static is on a different line than the initialization code in
lines 4–5 of Order. The exam may try to trick you by formatting the code like this to
confuse you.
        </item>
        <!--        8-->
        <item>
            \n\tAnswer A. Line 4 instantiates an Order. Java runs the declarations and instance initializers first
in the order they appear. This sets value to tacf. Line 5 creates another Order and
initializes value to tacb. The object on line 5 is stored in the same variable line 4 used.
This makes the object created on line 4 unreachable. When value is printed, it is the
instance variable in the object created on line 5.
        </item>
        <!--        9-->
        <item>
             \n\tAnswer A. This code is correct. Line 8 creates a lambda expression that checks if the age is less
than 5. Since there is only one parameter and it does not specify a type, the parentheses
around the type parameter are optional. Line 10 uses the Predicate interface, which
declares a test() method.
        </item>
        <!--        10-->
        <item>
            \n\tAnswer C. The interface takes two int parameters. The code on line 7 attempts to use them as
if one is a StringBuilder. It is tricky to use types in a lambda when they are implicitly
specified. Remember to check the interface for the real type.
        </item>


        <!--        1-->
        <item>
            \n\tAnswer  E. The code will not compile because the parent class Mammal doesn’t define a no-argument constructor, so the first line of a Platypus constructor should be an explicit call
to super(int age). If there was such a call, then the output would be MammalPlatypus,
since the super constructor is executed before the child constructor.
        </item>
        <!--        2-->
        <item>
            \n\tAnswer D. The code fails to compile because Beetle, the first concrete subclass, doesn’t implement getNumberOfSections(), which is inherited as an abstract method; therefore,
option D is correct. Option B is incorrect because there is nothing wrong with this
interface method definition. Option C is incorrect because an abstract class is not
required to implement any abstract methods, including those inherited from an interface. Option E is incorrect because the code fails at compilation-time.
        </item>
        <!--        3-->
        <item>
            \n\tAnswer F. The interface variable amount is correctly declared, with public and static being
assumed and automatically inserted by the compiler, so option B is incorrect. The
method declaration for eatGrass() on line 3 is incorrect because the method has been
marked as static but no method body has been provided. The method declaration for
chew() on line 4 is also incorrect, since an interface method that provides a body must
be marked as default or static explicitly. Therefore, option F is the correct answer
since this code contains two compile-time errors.
        </item>
        <!--        4-->
        <item>
            \n\tAnswer A. Although the definition of methods on lines 2 and 5 vary, both will be converted to
public abstract by the compiler. Line 4 is fine, because an interface can have public or default access. Finally, the class Falcon doesn’t need to implement the interface
methods because it is marked as abstract. Therefore, the code will compile without
issue.
        </item>
        <!--        5-->
        <item>
            \n\tAnswer B. This code compiles and runs without issue, outputting false, so option B is the
correct answer. The first declaration of isBlind() is as a default interface method,
assumed public. The second declaration of isBlind() correctly overrides the default
interface method. Finally, the newly created Owl instance may be automatically cast to
a Nocturnal reference without an explicit cast, although adding it doesn’t break the
code.
        </item>
        <!--        6-->
        <item>
             \n\tAnswer A. The code compiles and runs without issue, so options E and F are incorrect. The
printName() method is an overload in Spider, not an override, so both methods may
be called. The call on line 8 references the version that takes an int as input defined
in the Spider class, and the call on line 9 references the version in the Arthropod class
that takes a double. Therefore, SpiderArthropod is output and option A is the correct
answer.
        </item>
        <!--        7-->
        <item>
             \n\tAnswer E. The code does not compile, so options A and B are incorrect. The issue with line 9 is
that layEggs() is marked as final in the superclass Reptile, which means it cannot be
overridden. There are no errors on any other lines, so options C and D are incorrect.
        </item>
        <!--        8-->
        <item>
            \n\tAnswer B. This may look like a complex question, but it is actually quite easy. Line 2 contains
an invalid definition of an abstract method. Abstract methods cannot contain a body,
so the code will not compile and option B is the correct answer. If the body {} was
removed from line 2, the code would still not compile, although it would be line 8 that
would throw the compilation error. Since dive() in Whale is abstract and Orca extends
Whale, then it must implement an overridden version of dive(). The method on line
9 is an overloaded version of dive(), not an overridden version, so Orca is an invalid
subclass and will not compile.
        </item>
        <!--        9-->
        <item>
            \n\tAnswer A. The code compiles and runs without issue, so options C, D, and E are incorrect.
The trick here is that the method fly() is marked as private in the parent class Bird,
which means it may only be hidden, not overridden. With hidden methods, the specific
method used depends on where it is referenced. Since it is referenced within the Bird
class, the method declared on line 2 was used, and option A is correct. Alternatively,
if the method was referenced within the Pelican class, or if the method in the parent
class was marked as protected and overridden in the subclass, then the method on line
9 would have been used.
        </item>


        <!--        1-->
        <item>
            \n\tAnswer C. A try statement is required to have a catch clause and/or finally clause. If it goes
the catch route, it is allowed to have multiple catch clauses.
        </item>
        <!--        2-->
        <item>
            \n\tAnswer B. The second line tries to cast an Integer to a String. Since String does not extend
Integer, this is not allowed and a ClassCastException is thrown.
        </item>
        <!--        3-->
        <item>
            \n\tAnswer C. The compiler tests the operation for a valid type but not a valid result, so the code
will still compile and run. At runtime, evaluation of the parameter takes place before
passing it to the print() method, so an ArithmeticException object is raised.
        </item>
        <!--        4-->
        <item>
            \n\tAnswer C. The main() method invokes go and A is printed on line 3. The stop method is
invoked and E is printed on line 14. Line 16 throws a NullPointerException, so stop
immediately ends and line 17 doesn’t execute. The exception isn’t caught in go, so the
go method ends as well, but not before its finally block executes and C is printed on
line 9. Because main() doesn’t catch the exception, the stack trace displays and no further output occurs, so AEC was the output printed before the stack trace.
        </item>
        <!--        5-->
        <item>
            \n\tAnswer E. The order of catch blocks is important because they’re checked in the order they
appear after the try block. Because ArithmeticException is a child class of RuntimeException, the catch block on line 7 is unreachable. (If an ArithmeticException is
thrown in try try block, it will be caught on line 5.) Line 7 generates a compiler error
because it is unreachable code.
        </item>
        <!--        6-->
        <item>
            \n\tAnswer B. The main() method invokes start on a new Laptop object. Line 4 prints Starting
up; then line 5 throws an Exception. Line 6 catches the exception, line 7 prints
Problem, and then line 8 calls System.exit, which terminates the JVM. The finally
block does not execute because the JVM is no longer running.
        </item>
        <!--        7-->
        <item>
            \n\tAnswer E. The parseName method is invoked within main() on a new Dog object. Line 4 prints
1. The try block executes and 2 is printed. Line 7 throws a NumberFormatException, so
line 8 does not execute. The exception is caught on line 9, and line 10 prints 4. Because the
exception is handled, execution resumes normally. parseName runs to completion, and
line 17 executes, printing 5. That’s the end of the program, so the output is 1245.
        </item>
        <!--        8-->
        <item>
            \n\tAnswer A. The parseName method is invoked on a new Cat object. Line 4 prints 1. The try
block is entered, and line 6 prints 2. Line 7 throws a NumberFormatException. It isn’t
caught, so parseName ends. main() doesn’t catch the exception either, so the program
terminates and the stack trace for the NumberFormatException is printed.
        </item>
        <!--        9-->
        <item>
             \n\tAnswer B. IllegalArgumentException is used when an unexpected parameter is passed into a
method. Option A is incorrect because returning null or -1 is a common return value
for this scenario. Option D is incorrect because a for loop is typically used for this
scenario. Option E is incorrect because you should find out how to code the method
and not leave it for the unsuspecting programmer who calls your method. Option C is
incorrect because you should run!
        </item>


        <!--        1-->
        <item>
            \n\tAnswer D. The code does not compile because a method is not allowed to be both abstract and
final. If final were removed, the answer would be B. An abstract class may contain an
abstract method. A static nested class may extend other classes.
        </item>
        <!--        2-->
        <item>
            2. E. This class is a proper use of generics. Box uses a generic type named T. On line 11, the
generic type is String. On line 12 the generic type is Integer. Line 12 also uses the diamond operator.
        </item>
        <!--        3-->
        <item>
            \n\tAnswer F. The code compiles without issue, so D is incorrect. The code throws a
ConcurrentModificationException at runtime on line c2, because mammals is a synchronized list and not a concurrent one. Therefore, it is not safe to be used inside an iterator,
and F is the correct answer. Note that if line c2 were removed, the rest of the code would
run without throwing an exception, outputting 8 4 5.
        </item>
        <!--        4-->
        <item>
            \n\tAnswer A. The code compiles and runs without issue, so E and F are incorrect. For this question,
it helps if you resolve each path to a simplified form component before answering it. The
path1 variable simplifies to /bats/sleep.txt after the Path operations have been applied.
The path2 variable using the current directory of /bats/day is assigned a path value of /
bats/sleep.txt. Since the file Path objects represent the same path within the file system,
they will return true for both equals() and isSameFile(), so A is the correct answer and
B, C, and D are incorrect.
        </item>
        <!--        5-->
        <item>
            \n\tAnswer F. The code compiles due to autoboxing. The command line does not enable assertions, so
D cannot happen. Line 6 executes and prints out 11, so the answer is F.
        </item>
        <!--        6-->
        <item>
            \n\tAnswer D. Java will use Dolphins_fr.properties as the matching resource bundle on line 6
because it is an exact match on the language. Line 7 finds a matching key in this file. Line 8
does not find a match in that file, and therefore it has to look higher up in the hierarchy.
        </item>
        <!--        7-->
        <item>
           \n\tAnswer D. Line 5 is incorrect because String does not implement AutoCloseable. Not all
objects can be declared in a try-with-resources try clause. Line 7 is incorrect because
RainException is a checked exception and is not declared or handled. Line 9 is incorrect
because s is declared in the try clause and is therefore out of scope for the finally block.
        </item>
        <!--        8-->
        <item>
            \n\tAnswer A. The code compiles. An enum may be an inner class. The values() method returns an
array with the enum values in the order in which they were declared in the code. Since Java
uses 0-based indexes, the answer is A.
        </item>
        <!--        9-->
        <item>
            \n\tAnswer A. d is the String P1D and p is the String PT24H. They are neither the same object nor the same value. Remember that Duration uses hours/minutes/seconds and Period uses
years/months/days for measures.
        </item>
        <!--        10-->
        <item>
            \n\tAnswer C. There is no terminal operation. Since the intermediate operations use lazy evaluation,
they wait for a terminal operation to run. Since there is no terminal operation, peek()
never runs.
        </item>


        <!--       1-->
        <item>
            \n\tAnswer A. Based on the equals() method in the code, objects are equal if they have the same
employeeId. The hashCode() method correctly overrides the one from Object. The
equals() method is an overload of the one from Object and not an override. It would be
better to pass Object since an override would be better to use here. It is odd to override
hashCode() and not equals().
        </item>
        <!--        2-->
        <item>
            \n\tAnswer A. hashCode() is correct and perfectly reasonable given that equals() also checks that
field. ClassCastException is a runtime exception and therefore does not need to be handled or declared. The override in equals() is correct. It is common for equals() to refer
to a private instance variable. This is legal because it is within the same class, even if it is
referring to a different object of the same class.
        </item>
        <!--        3-->
        <item>
            \n\tAnswer C. s1 points to the string pool. s2 points to an object on the heap, since it is created
at runtime. == checks for reference equality. These are different references, making
B incorrect. String overrides equals() so the actual values are the same, making C
correct. And yes, this question could have appeared on the OCA. Remember that the
OCP is cumulative. A question may appear to be about one thing and actually be about a
simpler concept.
        </item>
        <!--        4-->
        <item>
            \n\tAnswer C. The equals() method is correct. You are allowed to use any business logic that you
want in determining equality. The hashCode() method is not correct. It violates the rule
that two objects that return true for equals() must return the same hashCode(). It is also
a bad idea for the hash code to contain values that could change.
        </item>
        <!--        5-->
        <item>
            \n\tAnswer B. The ordinal() method of an enum returns its corresponding int value. Like arrays,
enums are zero based. Remember that the index of an enum may change when you recompile
the code and should not be used for comparison.
        </item>
        <!--        6-->
        <item>
            \n\tAnswer C. Inner is a member inner class. Inner classes are not allowed to contain static methods
or static variables. Only nested static classes are permitted to contain statics.
        </item>
        <!--        7-->
        <item>
            \n\tAnswer B. Outer.this.x is the correct way to refer to x in the Outer class. In Java 7, the answer
would have been D because you used to have to declare variables as final to use them in a
local inner class. In Java 8, this requirement was dropped and the variables only need to be
effectively final, which means that the code would still compile if final were added.
        </item>
        <!--        8-->
        <item>
            \n\tAnswer C. The code compiles fine. A member inner class is allowed to be private, and it is
allowed to refer to instance variables from the outer class. Two .class files are generated.
Book.class matches the name of the outer class. The inner class does not compile
to BookReader.class. That would introduce the possibility of a naming conflict.
Book$BookReader.class is correct because it shows the scope of the class is limited to
Book. You don’t need to know that $ is the syntax, but you do need to know the number of
classes and that BookReader is not a top-level class.
        </item>
        <!--        9-->
        <item>
            \n\tAnswer D. FootballGame is trying to refer to a static variable in another class. It needs a static
import to do so. The correct syntax is import static and not static import. B is incorrect
because * does not import classes in a package. C is incorrect because it does not refer to a
static member.
        </item>
        <!--        10-->
        <item>
            \n\tAnswer E. The main method tries to cast a Firefox instance to IE. Since IE is not a subclass of
Firefox, this throws a ClassCastException.
        </item>
        <!--        11-->
        <item>
            \n\tAnswer B. c is an instance of Chipmunk. It is an instance of any superclasses or interfaces it implements. In this case, those are Furry, Mammal, and Object. null is not an instance of any
type. Therefore, the first two if statements execute and result is 3.
        </item>
        <!--        12-->
        <item>
            \n\tAnswer E. This is a member inner class. It needs to be created using an instance of the outer class.
The syntax looks weird, but it creates an object of the outer class and then an object of the
inner class from it.
        </item>
        <!--        13-->
        <item>
            \n\tAnswer C. Both objects are BabyRhino objects. Virtual method invocation says that the subclass
method gets called at runtime rather than the type in the variable reference. However, we are not calling methods here. We are referring to instance variables. With instance variables, the reference type does matter.
        </item>

        <!--        1-->
        <item>
            \n\tAnswer E. The code does not compile because EasternChipmunk inherits the abstract method
climb() but does not implement it, therefore the correct answer is E. B, C, and D are
incorrect as they compile for various reasons. Line 2 compiles, as non-static and nondefault interface methods are assumed to have the abstract modifier. Line 4 compiles
without issue as an interface can extend another interface. Line 5 compiles without issue as
an abstract class can implement an interface without implementing any of the abstract
methods. F is incorrect, as Line 8 does not compile.
        </item>
        <!--        2-->
        <item>
            \n\tAnswer A. This code compiles and runs without issue so C, D, E, and F are incorrect. Line h1 creates a lambda expression that checks if the age is less than 5. Since there is only one parameter and it does not specify a type, the parentheses around the type parameter are optional.
Line h2 uses the Predicate interface, which declares a test() method. Since test()
returns true on the expression, match is output and A is correct.
        </item>
        <!--        3-->
        <item>
            \n\tAnswer D. While Java supports multiple inheritance through interfaces, it does not support method
overriding in interfaces, since it’s not clear which parent method should be used. In this
example, CanWalk and CanRun both implement a default walk() method. The definition of
CanSprint extends these two interfaces and therefore won’t compile as two default methods with the same signature from parent classes are detected, therefore the answer is D. None
of the other lines of code cause problems, so the rest of the answers are not correct.
        </item>
        <!--        4-->
        <item>
            \n\tAnswer C. The functional interface takes two int parameters. The code on line x1 attempts to use
them as if one is an Object, resulting in a compiler error making C the correct answer. It
also tries to return String even though the data type for the functional interface method is
boolean. It is tricky to use types in a lambda when they are implicitly specified. Remember
to check the interface for the real type.
        </item>
        <!--        5-->
        <item>
            \n\tAnswer F. The interface variable amount is correctly declared, with public, static, and final
being assumed and automatically inserted by the compiler, so B is incorrect. The method
declaration for eatGrass() on line 3 is incorrect because the method has been marked as
static but no method body has been provided. The method declaration for chew() on
line 4 is also incorrect, since an interface method that provides a body must be marked as
default or static explicitly. Therefore, F is the correct answer since this code contains
two compile-time errors.
        </item>
        <!--        6-->
        <item>
            6. A. Although the definition of methods on lines 2 and 5 vary, both will be converted to
public abstract by the compiler. Line 4 is fine, because an interface can have public or
default access. Finally, the class Falcon doesn’t need to implement the interface methods
because it is marked as abstract. Therefore, the code will compile without issue.
        </item>


        <!--        1-->
        <item>
            \n\tAnswer B. The answer needs to implement List because the scenario allows duplicates. Since you
need a List, you can eliminate C, D, and E immediately. HashMap is a Map and HashSet is a
Set. LinkedList is both a List and a Queue. You want a regular List. Option A, Arrays,
is trying to distract you. It is a utility class rather than a Collection. An array is not a collection. By process of elimination, the answer is B.
        </item>
        <!--        2-->
        <item>
            \n\tAnswer D. The answer needs to implement Map because you are dealing with key/value pairs per the
unique string text. You can eliminate A, C, E, and F immediately. ArrayList and Vector
are Lists. HashSet and TreeSet are Sets. Now it is between HashMap and TreeMap. Since
the question talks about ordering, you need the TreeMap. Therefore, the answer is E.
        </item>
        <!--        3-->
        <item>.
            \n\tAnswer E. The code does not compile. It attempts to mix generics and legacy code. Lines 3 through
7 create an ArrayList without generics. This means that we can put any objects in it.
Line 7 should be looping through a list of Objects rather than Strings since we didn’t use
generics.
        </item>
        <!--        4-->
        <item>
            \n\tAnswer E. Since we call push() rather than offer(), we are treating the ArrayDeque as a LIFO
(last-in, first-out) stack. On line 7, we remove the last element added, which is "ola". On
line 8, we look at the new last element ("hi"), but don’t remove it. Lines 9 and 10, we
remove each element in turn until none are left. Note that we don’t use an Iterator to loop
through the ArrayDeque. The order in which the elements are stored internally is not part
of the API contract.
        </item>
        <!--        5-->
        <item>
            \n\tAnswer C. Line 7 gives a compiler warning for not using generics but not a compiler error. Line 4
compiles fine because toString() is defined on the Object class and is therefore always
available to call. Line 6 creates the Hello class with the generic type String. Line 7 creates
the Hello class with the generic type Object since no type is specified
        </item>
        <!--        6-->
        <item>
            \n\tAnswer C. TreeSet sorts the elements. Since uppercase letters sort before lowercase letters, the
ordering is "ONE", "One", "one". The ceiling() method returns the smallest element
greater than the specified one. "On" appears between "ONE" and "One". Therefore, the
smallest element that is larger than the specified value is "One".
        </item>
        <!--        7-->
        <item>
            \n\tAnswer E. Trick question! The Map interface uses put() rather than add() to add elements to the
map. If these examples used put(), the answer would be A and C. B is no good because a
long cannot be shoved into a Double. D is no good because a char is not the same thing as
a String.
        </item>
        <!--        8-->
        <item>
            \n\tAnswer A. The array is sorted using MyComparator, which sorts the elements in reverse alphabetical order in a case-insensitive fashion. Normally, numbers sort before letters. This code
reverses that by calling the compareTo() method on b instead of a.
        </item>
        <!--        9-->
        <item>
            \n\tAnswer A. Line 3 uses the diamond operator to create the map. Lines 5 and 7 use autoboxing to
convert between the int primitive and the Integer wrapper class. The keys map to their
squared value. 1 maps to 1, 2 maps to 4, 3 maps to 9, 4 maps to 16, and so on.
        </item>
        <!--        10-->
        <item>
            \n\tAnswer C. This question is hard because it defines both Comparable and Comparator on the same
object. t1 doesn’t specify a Comparator so it uses the Comparable object’s compareTo()
method. This sorts by the text instance variable. t2 did specify a Comparator when calling
the constructor, so it uses the compare() method, which sorts by the int.
        </item>
        <!--        11-->
        <item>
            \n\tAnswer D. The list is sorted in descending order. However, it is searched using the default order,
which is sorted in ascending order. binarySearch() requires both to use the same sort
order. Therefore, the precondition for binarySearch() is not met and the result is undefined.
        </item>
        <!--        12-->
        <item>
            \n\tAnswer E. This question looks like it is about generics, but it’s not. It is trying to see if
you noticed that Map does not have a contains() method. It has containsKey() and
containsValue() instead. If containsKey() was called, the answer would be false
because the 123 in the list is an Integer rather than a String.
        </item>
        <!--        13-->
        <item>
            \n\tAnswer B. When using generic types in a static method, the generic specification goes before the return type.
        </item>
        <!--        14-->
        <item>
            \n\tAnswer F. The first call to merge() calls the mapping function and adds the two numbers to get 13.
It then updates the map. The second call to merge() sees that the map currently has a null
value for that key. It does not call the mapping function but instead replaces it with the new
value of 3. Therefore choice F is correct.
        </item>


        <!--        1-->
        <item>
            \n\tAnswer D. No terminal operation is called, so the stream never executes. The methods chain to
create a stream that would contain “2” and “12.” The first line creates an infinite stream.
The second line would get the first two elements from that infinite stream and map each
element to add an extra character.
        </item>
        <!--        2-->
        <item>
            \n\tAnswer F. b1 is set to true since anyMatch() terminates. Even though the stream is infinite, Java
finds a match on the first element and stops looking. However, when allMatch() runs,
it needs to keep going until the end of the stream since it keeps finding matches. Since all
elements continue to match, the program hangs.
        </item>
        <!--        3-->
        <item>
            \n\tAnswer E. An infinite stream is generated where each element is twice as long as the previous
one. b1 is set to false because Java finds an element that doesn’t match when it gets to
the element of length 4. However, the next line tries to operate on the same stream. Since
streams can be used only once, this throws an exception that the “stream has already been
operated upon or closed.” If two different streams were used, the result would be option A.
        </item>
        <!--        4-->
        <item>
            \n\tAnswer F. The terminal operation must be right before the semicolon, which is line M. Remember
that forEach() is a terminal operation while peek() is an intermediate operation. This
eliminates all but choices C, E, and F. Choice E is incorrect because there is no limit()
operation, which means that the code would run infinitely. Choice C is incorrect because
filter() is called before limit(). No elements make it through the filter, so the code also
runs infinitely. Choice F is correct.
        </item>
        <!--        5-->
        <item>
            \n\tAnswer F. If the map() and flatMap() calls were reversed, choice B would be correct. In this case,
the Stream created from the source is of type Stream&#60;List&#60;Integer>>. The Function in
map expects an Integer rather than a List&#60;Integer>, so the code does not compile.
        </item>
        <!--        6-->
        <item>
            \n\tAnswer D. Line 4 should obviously look OK. It creates a Stream and uses autoboxing to put the
Integer 1 inside. Line 5 converts to a primitive, again using autoboxing. Line 6 converts
to a double primitive, which works since double d = 1; would work. Line 7 is where it
all falls apart. Converting from a double to an int would require a cast inside the lambda.
        </item>
        <!--        7-->
        <item>
            \n\tAnswer C. The partitioningBy() operation always returns a map with two Boolean keys, even
if there are no corresponding values. By contrast, groupingBy() returns only keys that are
actually needed.
        </item>
        <!--        8-->
        <item>
            \n\tAnswer E. A UnaryOperator is a special type of function where the parameter and return type
are the same. Therefore, option E is correct. Notice that other options don’t even compile
because they have the wrong number of generic types for the functional interface provided.
        </item>
        <!--        9-->
        <item>
            \n\tAnswer D. The terminal operation is count(). Since there is a terminal operation, the intermediate
operations run. The peek() operation comes before the filter, so both numbers are printed.
The count happens to be 1 since the other number is filtered. However, the result of the
stream pipeline isn’t stored in a variable, and that result is ignored.
        </item>


        <!--        1-->
        <item>
            \n\tAnswer B. Java will first look for the most specific matches it can find, starting with Dolphins_en_
US.java and then Dolphins_en_US.properties. Since neither is found, it drops the country and looks for Dolphins_en.java. Since a match is found, there is no reason to go on to
the next one, which is Dolphins_en.properties.
        </item>
        <!--        2-->
        <item>
            \n\tAnswer D. Java will use Dolphins_fr.properties as the matching resource bundle on line 7
because it is an exact match on the language of the requested locale. Line 8 finds a matching key in this file. Line 9 does not find a match in that file, and therefore it has to look
higher up in the hierarchy. Once a bundle is chosen, only resources in that hierarchy are
allowed.
        </item>
        <!--        3-->
        <item>
            \n\tAnswer D. A LocalDate does not have a time element. Therefore, it has no method to add hours,
and the code does not compile.
        </item>
        <!--        4-->
        <item>
            \n\tAnswer F. Java throws an exception if invalid date values are passed. There is no 40th day in
April—or any other month for that matter.
        </item>
        <!--        5-->
        <item>
            \n\tAnswer B. The date starts out as April 30, 2018. Since dates are immutable and the plus methods
have their return values ignored, the result is unchanged. Therefore, Option B is correct.
        </item>
        <!--        6-->
        <item>
            \n\tAnswer E. Even though d has both date and time, the formatter only outputs time.
        </item>
        <!--        7-->
        <item>
            \n\tAnswer B. Period does not allow chaining. Only the last Period method called counts, so only the
two years are subtracted.
        </item>
        <!--        8-->
        <item>
            \n\tAnswer B. dateTime1 is 2016–03–13T01:30–05:00[US/Eastern] and dateTime2 is
2016–03–13T03:30–04:00[US/Eastern]. While the values are two hours apart, the time
zone offset changes as well, making it only change from 6:30 GMT to 7:30 GMT.
        </item>
        <!--        9-->
        <item>
            \n\tAnswer E. The Properties class defines a get() method that does not allow for a default value.
It also has a getProperty() method, which returns the default value if the key is not provided.
        </item>


    </string-array>



    <string-array name="correctAnswersForOCAOCP">
        <!--1--><item>C. true is printed out exactly three times.</item>
        <!--2--><item>C. 6</item>
        <!--3--><item>D. abcde</item>
        <!--4--><item>B. 15</item>
        <!--5--><item>B. [9]</item>
        <!--6--><item>A. DeerReindeer,false</item>
        <!--7--><item>B. 12</item>
        <!--8--><item>B. Color:null</item>
        <!--9--><item>C. BearShark</item>
        <!--10--><item>C. .class</item>
        <!--    1--><item>F. The code will not compile because of line 5.</item>
        <!--    2--><item>C. 10,</item>
        <!--    3--><item>F. The code will not compile because of line 7</item>
        <!--    4--><item>D. 8</item>
        <!--    5--><item>B. true, 20, false</item>
        <!--    6--><item>F. The code contains an infinite loop and does not terminate.</item>
        <!--    7--><item>D. The code will not compile because of line 4.</item>
        <!--    8--><item>A. 2</item>
        <!--    9--><item>D. The code will not compile because of line 5.</item>
        <!--    10--><item>A. Success</item>
        <!--    11--><item>C. 12</item>
        <!--    12--><item>E. The code will not compile because of line 4.</item>
        <!--    13--><item>D. The code will not compile because of line 6.</item>
        <!--    14--><item>D. 11</item>
        <!--    15--><item>A. 1</item>
        <!--    16--><item>D. 36</item>
        <!--    17--><item>B. greatgood </item>
        <item>D. Empty = false, Brand = null</item>
        <item>E. 4</item>
        <item>A. 0</item>

        <!--    1--><item>B. abbaccca</item>
        <!--    2--><item>F. The code does not compile.</item>
        <!--    3--><item>B. roar roar!!!</item>
        <!--    4--><item>C. 8</item>
        <!--    5--><item>E. An exception is thrown.</item>
        <!--    6--><item>F. The code does not compile.</item>
        <!--    7--><item>D. Compiler error on line 9.</item>
        <!--    8--><item>C. 6</item>
        <!--    9--><item>D. The result is undefined.</item>
        <!--    10--><item>A. –1</item>
        <!--    11--><item>C. Compiler error on line 7.</item>
        <!--    12--><item>D. 2 1 –3</item>
        <!--    13--><item>B. B</item>
        <!--    14--><item>D. The code does not compile.</item>
        <!--    15--><item>F. A runtime exception is thrown.</item>
        <!--    16--><item>B. 2018 APRIL 30</item>
        <!--    17--><item>E. 11:22 AM</item>
        <!--    18--><item>B. 5/10/13 11:22 AM</item>

        <item>B. swing swing 10</item>
        <item>D. 8</item>
        <item>E. 4</item>
        <item>E. intObjectObject</item>
        <item>B. 9</item>
        <item>E. Replace line 1 with this(2);</item>
        <item>E. u u ucrcr</item>
        <item>A. tacb</item>
        <item>A. match</item>
        <item>C. Compiler error on line 7.</item>


        <item>E. The code will not compile because of line 8.</item>
        <item>D. The code will not compile because of line 7.</item>
        <item>F. The code will not compile because of lines 3 and 4.</item>
        <item>A. It compiles without issue.</item>
        <item>B. false</item>
        <item>A. SpiderArthropod</item>
        <item>E. The code will not compile because of line 9.</item>
        <item>B. The code will not compile because of line 2.</item>
        <item>A. Bird is flying</item>


        <!--1--> <item>C. When there are no catch blocks in a try statement.</item>
        <!--2--> <item>B. ClassCastException</item>
        <!--3--> <item>C. It will run and throw an ArithmeticException.</item>
        <!--4--> <item>C. AEC</item>
        <!--5--> <item>E. The code does not compile.</item>
        <!--6--> <item>B. Starting up Problem</item>
        <!--7--> <item>E. 1245</item>
        <!--8--> <item>A. 12, followed by a stack trace for a NumberFormatException</item>
        <!--9--> <item>B. An unexpected parameter is passed into a method.</item>

        <item>D. A compiler error occurs on line 3.</item>
        <item>E. a string123</item>
        <item>F. It compiles but throws an exception at runtime on line c2</item>
        <item>A. true true</item>
        <item>F. The output is 11.</item>
        <item>D. Dolphins_fr.properties and Dolphins.properties</item>
        <item>D. 3</item>
        <item>A. CHIPMUNK</item>
        <item>A. false false</item>
        <item>C. There is no output</item>


        <!--        1--><item>A. Success</item>
        <!--        2--><item>A. The code compiles.</item>
        <!--        3--><item>C. s1.equals(s2)</item>
        <!--        4--><item>C. The class compiles but has an improper hashCode() method.</item>
        <!--        5--><item>B. 1</item>
        <!--        6--><item>C. Line 4 generates a compiler error</item>
        <!--        7--><item>B. x is 24.</item>
        <!--        8--><item>C. The code compiles successfully, and two bytecode files are generated: Book.class and Book$BookReader.class.</item>
        <!--        9--><item>D. import static my.sports.Football.*;</item>
        <!--        10--><item>E. A runtime exception is thrown.</item>
        <!--        11--><item>B. The output is 3.</item>
        <!--        12--><item>E. Outer.Inner in = new Outer().new Inner();</item>
        <!--        13--><item>C. walk,toddle,</item>

        <!--        1--><item>E. The code will not compile because of line 8.</item>
        <!--        2--><item>A. match</item>
        <!--        3--><item>D. The code will not compile because of line 8.</item>
        <!--        4--><item>C. Compiler error on line x1.</item>
        <!--        5--><item>F. The code will not compile because of lines 3 and 4.</item>
        <!--        6--><item>A. It compiles without issue</item>


        <!--        1--><item>B. ArrayList</item>
        <!--        2--><item>D. TreeMap</item>
        <!--        3--><item>E. Compiler error on line 7</item>
        <!--        4--><item>E. hihello</item>
        <!--        5--><item>C. hithere</item>
        <!--        6--><item>C. One</item>
        <!--        7--><item>E. None of the above</item>
        <!--        8--><item>A. Abb aab 123</item>
        <!--        9--><item>A. 16</item>
        <!--        10--><item>C. [88. 55] [55, 88]</item>
        <!--        11--><item>D. The result is undefined.</item>
        <!--        12--><item>E. Compiler error on line 7.</item>
        <!--        13--><item>B. Add &#60;T> after the static keyword.</item>
        <!--        14--><item>F. {1=13, 2=20, 3=3}</item>

        <!--        1--><item>D. java.util.stream.ReferencePipeline$3@4517d9a3</item>
        <!--        2--><item>B. true true</item>
        <!--        3--><item>E. An exception is thrown.</item>
        <!--        4--><item>F. N, M</item>
        <!--        5--><item>F. The code does not compile</item>
        <!--        6--><item>D. Line 7 does not compile.</item>
        <!--        7--><item>C. {false=[], true=[]} {}</item>
        <!--        8--><item>E. Function&#60;Integer, Integer> f = x -> x*x;</item>
        <!--        9--><item>D. 1.2 and 2.4</item>

        <!--        1--><item>B. Dolphins_en.java</item>
        <!--        2--><item>D. Dolphins_fr.properties and Dolphins.properties</item>
        <!--        3--><item>D. The code does not compile.</item>
        <!--        4--><item>F. A runtime exception is thrown</item>
        <!--        5--><item>B. 2018 APRIL 30</item>
        <!--        6--><item>E. 11:22 AM</item>
        <!--        7--><item>B. 5/10/13 11:22 AM</item>
        <!--        8--><item>B. 1,1,3</item>
        <!--        9--><item>E. The code does not compile</item>

    </string-array>


    <string-array name="keysAForOCAOCP">
        <item>A. true is printed out exactly once</item>
        <item>A. 4</item>
        <item>A. abe</item>
        <item>A. 10</item>
        <item>A. [8]</item>
        <item>A. DeerReindeer,false</item>
        <item>A. 10</item>
        <item>A. Color:</item>
        <item>A. Bear</item>
        <item>A. .bytecode</item>

        <item>A. Greater than,10</item>
        <item>A. 10, 14,</item>
        <item>A. Too Low</item>
        <item>A. 5</item>
        <item>A. true, 10, true</item>
        <item>A. 9</item>
        <item>A. 40</item>
        <item>A. 2</item>
        <item>A. Success</item>
        <item>A. Success</item>
        <item>A. 8</item>
        <item>A. 10, 5</item>
        <item>A. 1 2 3 4 5 6 7 8 9</item>
        <item>A. 7</item>
        <item>A. 1</item>
        <item>A. 11</item>
        <item>A. great</item>
        <item>A. Line 6 generates a compiler error. </item>
        <item>A. 0</item>
        <item>A. 0</item>

        <item>A. abbaaccc</item>
        <item>A. 1</item>
        <item>A. roar roar</item>
        <item>A. 2</item>
        <item>A. 1</item>
        <item>A. rum</item>
        <item>A. onetwo</item>
        <item>A. 4</item>
        <item>A. 2</item>
        <item>A. –1</item>
        <item>A. Sue</item>
        <item>A 0 1 –2</item>
        <item>A. A</item>
        <item>A. 2018 APRIL 2</item>
        <item>A. 2018 APRIL 4</item>
        <item>A. 2018 APRIL 2</item>
        <item>A. 3/7/14 11:22 AM</item>
        <item>A. 5/9/13 11:22 AM</item>

        <item>A. swing swing 5</item>
        <item>A. 02</item>
        <item>A. 0</item>
        <item>A. bytefloatObject</item>
        <item>A. -1</item>
        <item>A. Replace line 1 with BirdSeed(2);</item>
        <item>A. curur</item>
        <item>A. tacb</item>
        <item>A. match</item>
        <item>A. ok</item>


        <item>A. Platypus</item>
        <item>A. It compiles and runs without issue.</item>
        <item>A. It compiles and runs without issue.</item>
        <item>A. It compiles without issue.</item>
        <item>A. true</item>
        <item>A. SpiderArthropod</item>
        <item>A. Reptile laying eggs</item>
        <item>A. Orca diving</item>
        <item>A. Bird is flying</item>


        <item>A. Never</item>
        <item>A. ArrayIndexOutOfBoundsException</item>
        <item>A. It will not compile</item>
        <item>A. AE</item>
        <item>A. -1</item>
        <item>A. Starting up</item>
        <item>A. 12</item>
        <item>A. 12, followed by a stack trace for a NumberFormatException</item>
        <item>A. An element is not found when searching a list.</item>


        <item>A. Text message to null.</item>
        <item>A. Compiler error on line 1.</item>
        <item>A. It outputs 4 8 5.</item>
        <item>A. true true</item>
        <item>A. Line 3 generates a compiler error.</item>
        <item>A. Dolphins.properties and Dolphins.properties</item>
        <item>A. 0</item>
        <item>A. CHIPMUNK</item>
        <item>A. false false</item>
        <item>A. 2016–05–01</item>


        <item>A. Success</item>
        <item>A. The code compiles.</item>
        <item>A. There is no output.</item>
        <item>A. The class does not compile</item>
        <item>A. 0</item>
        <item>A. The output is 5.</item>
        <item>A. x is 0.</item>
        <item>A. The code compiles successfully, and one bytecode file is generated: Book.class</item>
        <item>A. import my.sports.Football;</item>
        <item>A. Inside Browser</item>
        <item>A. The output is 0.</item>
        <item>A. Inner in = new Inner();</item>
        <item>A. toddle,toddle,</item>


        <item>A. It compiles and runs without issue</item>
        <item>A. match</item>
        <item>A. The code compiles without issue.</item>
        <item>A. ok</item>
        <item>A. It compiles and runs without issue.</item>
        <item>A. It compiles without issue</item>


        <item>A. Arrays</item>
        <item>A. ArrayList</item>
        <item>A. onetwo</item>
        <item>A. hello</item>
        <item>A. hi</item>
        <item>A. On</item>
        <item>A. map.add("pi", 3.14159);</item>
        <item>A. Abb aab 123</item>
        <item>A. 16</item>
        <item>A. [55. 88] [55, 88]</item>
        <item>A. 0</item>
        <item>A. false</item>
        <item>A. Add &#60;T> after the public keyword</item>
        <item>A. {1=10, 2=20}</item>


        <item>A. 12112</item>
        <item>A. true false</item>
        <item>A. false true</item>
        <item>A. L, N</item>
        <item>A. The code compiles and prints 123456.</item>
        <item>A. Line 4 does not compile.</item>
        <item>A. {} {}</item>
        <item>A. BiFunction&#60;Integer> f = x -> x*x;</item>
        <item>A. 1</item>


        <item>A. Dolphins.properties</item>
        <item>A. Dolphins.properties and Dolphins.properties</item>
        <item>A. 2018 APRIL 2</item>
        <item>A. 2018 APRIL 4</item>
        <item>A. 2018 APRIL 2</item>
        <item>A. 3/7/14 11:22 AM</item>
        <item>A. 5/9/13 11:22 AM</item>
        <item>A. 1,1,2</item>
        <item>A. brontosaurus none</item>


    </string-array>


    <string-array name="keysBForOCAOCP">
        <item>B. true is printed out exactly twice.</item>
        <item>B. 5</item>
        <item>B. abce</item>
        <item>B. 15</item>
        <item>B. [9]</item>
        <item>B. DeerReindeer,true</item>
        <item>B. 12</item>
        <item>B. Color:null</item>
        <item>B. Shark</item>
        <item>B. .bytes</item>

        <item>B. false,10</item>
        <item>B. 10, 14</item>
        <item>B. Just Right</item>
        <item>B. 4</item>
        <item>B. true, 20, false</item>
        <item>B. 10</item>
        <item>B. 50</item>
        <item>B. 3</item>
        <item>B. Failure</item>
        <item>B. Failure</item>
        <item>B. 11</item>
        <item>B. 10, 6</item>
        <item>B. 1 2 3 4 5 6 7 8 9 10</item>
        <item>B. 9</item>
        <item>B. 2</item>
        <item>B. 13</item>
        <item>B. greatgood </item>
        <item>B. Line 7 generates a compiler error.</item>
        <item>B. 1</item>
        <item>B. 4</item>

        <item>B. abbaccca</item>
        <item>B. 2</item>
        <item>B. roar roar!!!</item>
        <item>B. 4</item>
        <item>B. 2</item>
        <item>B. rum4</item>
        <item>B. onetwo7</item>
        <item>B. 5</item>
        <item>B. 4</item>
        <item>B. 10</item>
        <item>B. Tom</item>
        <item>B. 0 1 –3</item>
        <item>B. B</item>
        <item>B. 2018 APRIL 30</item>
        <item>B. 2018 APRIL 30</item>
        <item>B. 2018 APRIL 30</item>
        <item>B. 5/10/15 11:22 AM</item>
        <item>B. 5/10/13 11:22 AM</item>


        <item>B. swing swing 10</item>
        <item>B. 08</item>
        <item>B. 1</item>
        <item>B. intfloatObject</item>
        <item>B. 9</item>
        <item>B. Replace line 2 with BirdSeed(2);</item>
        <item>B. ucrcr</item>
        <item>B. tacf</item>
        <item>B. not match</item>
        <item>B. too high</item>


        <item>B. Mammal</item>
        <item>B. The code will not compile because of line 2.</item>
        <item>B. The code will not compile because of line 2.</item>
        <item>B. The code will not compile because of line 2.</item>
        <item>B. false</item>
        <item>B. ArthropodSpider</item>
        <item>B. Lizard laying eggs</item>
        <item>B. The code will not compile because of line 2.</item>
        <item>B. Pelican is flying </item>


        <item>B. When the program code does not terminate on its own.</item>
        <item>B. ClassCastException</item>
        <item>B. It will not run.</item>
        <item>B. AEBCD</item>
        <item>B. 0</item>
        <item>B. Starting up Problem</item>
        <item>B. 1234</item>
        <item>B. 124, followed by a stack trace for a NumberFormatException</item>
        <item>B. An unexpected parameter is passed into a method.</item>


        <item>B. Text message to 1234567890.</item>
        <item>B. Compiler error on line 2.</item>
        <item>B. It outputs 8 4 5.</item>
        <item>B. false false</item>
        <item>B. Line 4 generates a compiler error</item>
        <item>B. Dolphins.properties and Dolphins_fr.properties</item>
        <item>B. 1</item>
        <item>B. SQUIRREL</item>
        <item>B. false true</item>
        <item>B. B. 2016–06–01</item>


        <item>B. Failure</item>
        <item>B. The code does not compile because hashCode() is incorrect.</item>
        <item>B. s1 == s2</item>
        <item>B. The class compiles but has an improper equals() method.</item>
        <item>B. 1</item>
        <item>B. The output is 10.</item>
        <item>B. x is 24.</item>
        <item>B. The code compiles successfully, and two bytecode files are generated: Book.class and BookReader.class</item>
        <item>B. import static my.sports.*;</item>
        <item>B. Inside Firefox</item>
        <item>B. The output is 3.</item>
        <item>B. Inner in = Outer.new Inner();</item>
        <item>B. toddle,walk,</item>


        <item>B. The code will not compile because of line 2.</item>
        <item>B. not match</item>
        <item>B. The code will not compile because of line 5.</item>
        <item>B. too high</item>
        <item>B. The code will not compile because of line 2.</item>
        <item>B. The code will not compile because of line 2.</item>


        <item>B. ArrayList</item>
        <item>B. HashMap</item>
        <item>B. onetwo7</item>
        <item>B. hellohi</item>
        <item>B. hi followed by a runtime exception</item>
        <item>B. one</item>
        <item>B. map.add("e", 2L);</item>
        <item>B. aab Abb 123</item>
        <item>B. 25</item>
        <item>B. [55. 88] [88, 55]</item>
        <item>B. 1</item>
        <item>B. true</item>
        <item>B. Add &#60;T> after the static keyword.</item>
        <item>B. {1=10, 2=20, 3=null}</item>


        <item>B. 212</item>
        <item>B. true true</item>
        <item>B. false false</item>
        <item>B. L, N, O</item>
        <item>B. The code compiles and prints 234567.</item>
        <item>B. Line 5 does not compile</item>
        <item>B. {} {false=[], true=[]}</item>
        <item>B. BiFunction&#60;Integer, Integer> f = x -> x*x;</item>
        <item>B. 2</item>


        <item>B. Dolphins_en.java</item>
        <item>B. Dolphins.properties and Dolphins_en.properties</item>
        <item>B. 2018 APRIL 30</item>
        <item>B. 2018 APRIL 30</item>
        <item>B. 2018 APRIL 30</item>
        <item>B. 5/10/15 11:22 AM</item>
        <item>B. 5/10/13 11:22 AM</item>
        <item>B. 1,1,3</item>
        <item>B. brontosaurus null</item>

    </string-array>


    <string-array name="keysCForOCAOCP">
        <item>C. true is printed out exactly three times.</item>
        <item>C. 6</item>
        <item>C. abde</item>
        <item>C. 25</item>
        <item>C. Something like [Ljava.lang.String;@160bc7c0</item>
        <item>C. ReindeerDeer,false</item>
        <item>C. 13</item>
        <item>C. Color:White</item>
        <item>C. BearShark</item>
        <item>C. .class</item>

        <item>C. Greater than,11</item>
        <item>C. 10,</item>
        <item>C. Too High</item>
        <item>C. 10</item>
        <item>C. false, 20, true</item>
        <item>C. 11</item>
        <item>C. 90</item>
        <item>C. 5</item>
        <item>C. The code will not compile because of line 4.</item>
        <item>C. The code will not compile because of line 4.</item>
        <item>C. 12</item>
        <item>C. 11, 5</item>
        <item>C. 1 2 3 4 5 6 7 8 9 10 11</item>
        <item>C. 10</item>
        <item>C. 3</item>
        <item>C. 23</item>
        <item>C. The code will not compile because of line 3.</item>
        <item>C. There is no output.</item>
        <item>C. 2</item>
        <item>C. Compilation fails on line 3.</item>


        <item>C. bbaaaccc</item>
        <item>C. 12</item>
        <item>C. roar!!! roar</item>
        <item>C. 8</item>
        <item>C. 3</item>
        <item>C. rumb4</item>
        <item>C. onetwo followed by an exception</item>
        <item>C. 6</item>
        <item>C. 6</item>
        <item>C. Compiler error on line 4.</item>
        <item>C. Compiler error on line 7.</item>
        <item>C. 2 1 –2</item>
        <item>C. C</item>
        <item>C. 2018 MAY 2</item>
        <item>C. 2018 MAY 10</item>
        <item>C. 2018 MAY 2</item>
        <item>C. 3/7/14</item>
        <item>C. 5/9/14</item>

        <item>C. Compiler error on line 2 of Chimp.</item>
        <item>C. 2</item>
        <item>C. 2</item>
        <item>C. byteObjectfloat</item>
        <item>C. 81</item>
        <item>C. Replace line 1 with new BirdSeed(2);</item>
        <item>C. u ucrcr</item>
        <item>C. tacbf</item>
        <item>C. Compiler error on line 8.</item>
        <item>C. Compiler error on line 7.</item>


        <item>C. PlatypusMammal</item>
        <item>C. The code will not compile because of line 4.</item>
        <item>C. The code will not compile because of line 3.</item>
        <item>C. The code will not compile because of line 4.</item>
        <item>C. The code will not compile because of line 2.</item>
        <item>C. SpiderSpider</item>
        <item>C. The code will not compile because of line 4.</item>
        <item>C. The code will not compile because of line 8.</item>
        <item>C. The code will not compile because of line 4.</item>


        <item>C. When there are no catch blocks in a try statement.</item>
        <item>C. IllegalArgumentException</item>
        <item>C. It will run and throw an ArithmeticException.</item>
        <item>C. AEC</item>
        <item>C. done-1</item>
        <item>C. Starting up Problem Shutting down</item>
        <item>C. 1235</item>
        <item>C. 12456</item>
        <item>C. The computer caught fire.</item>


        <item>C. A compiler error occurs on line 1.</item>
        <item>C. Compiler error on line 11.</item>
        <item>C. It outputs 8 8 8</item>
        <item>C. true false</item>
        <item>C. Line 5 generates a compiler error.</item>
        <item>C. Dolphins_fr.properties and Dolphins_fr.properties</item>
        <item>C. 2</item>
        <item>C. The code compiles, but the output is indeterminate.</item>
        <item>C. true false</item>
        <item>C. There is no output</item>



        <item>C. The hashCode() method fails to compile.</item>
        <item>C. The code does not compile because equals() does not override the parent method correctly.</item>
        <item>C. s1.equals(s2)</item>
        <item>C. The class compiles but has an improper hashCode() method.</item>
        <item>C. 9</item>
        <item>C. Line 4 generates a compiler error.</item>
        <item>C. Line 6 generates a compiler error</item>
        <item>C. The code compiles successfully, and two bytecode files are generated: Book.class and Book$BookReader.class.</item>
        <item>C. import static my.sports.Football;</item>
        <item>C. Inside IE</item>
        <item>C. The output is 7.</item>
        <item>C. Outer.Inner in = new Outer.Inner();</item>
        <item>C. walk,toddle,</item>


        <item>C. The code will not compile because of line 4.</item>
        <item>C. Compiler error on line h1.</item>
        <item>C. The code will not compile because of line 6.</item>
        <item>C. Compiler error on line x1.</item>
        <item>C. The code will not compile because of line 3</item>
        <item>C. The code will not compile because of line 4.</item>


        <item>C. HashMap</item>
        <item>C. HashSet</item>
        <item>C. onetwo followed by an exception</item>
        <item>C. hellohiola</item>
        <item>C. hithere</item>
        <item>C. One</item>
        <item>C. map.add("log(1)", new Double(0.0));</item>
        <item>C. 123 Abb aab</item>
        <item>C. Compiler error on line 3.</item>
        <item>C. [88. 55] [55, 88]</item>
        <item>C. 2</item>
        <item>C. Compiler error on line 4</item>
        <item>C. Add &#60;T> after T.</item>
        <item>C. {1=10, 2=20, 3=3}</item>


        <item>C. 212112</item>
        <item>C. java.util.stream.ReferencePipeline$3@4517d9a3</item>
        <item>C. java.util.stream.ReferencePipeline$3@4517d9a3</item>
        <item>C. L, N, M</item>
        <item>C. The code compiles but does not print anything</item>
        <item>C. Line 6 does not compile.</item>
        <item>C. {false=[], true=[]} {}</item>
        <item>C. BinaryOperator&#60;Integer, Integer> f = x -> x*x;</item>
        <item>C. 2.4</item>


        <item>C. Dolphins_en.properties</item>
        <item>C. Dolphins_en.properties and Dolphins_en.properties</item>
        <item>C. 2018 MAY 2</item>
        <item>C. 2018 MAY 10</item>
        <item>C. 2018 MAY 2</item>
        <item>C. 3/7/14</item>
        <item>C. 5/9/14</item>
        <item>C. 2,1,2</item>
        <item>C. none none</item>



    </string-array>


    <string-array name="keysDForOCAOCP">
        <item>D. true is printed out exactly four times.</item>
        <item>B. 7</item>
        <item>D. abcde</item>
        <item>D. Compiler error on line 3</item>
        <item>D. An exception is thrown</item>
        <item>D. ReindeerDeer,true</item>
        <item>D. 17</item>
        <item>D. Compiler error on line 4.</item>
        <item>D. The code will not compile because of line 4.</item>
        <item>D. .exe</item>

        <item>D. false,11</item>
        <item>D. The code will not compile because of line 7</item>
        <item>D. Compiles but throws a NullPointerException.</item>
        <item>D. 8</item>
        <item>D. false, 20, false</item>
        <item>D. The code will not compile because of line 3.</item>
        <item>D. The code will not compile because of line 4.</item>
        <item>D. 6</item>
        <item>D. The code will not compile because of line 5.</item>
        <item>D. The code will not compile because of line 5.</item>
        <item>D. 15</item>
        <item>D. The code will not compile because of line 3.</item>
        <item>D. The code will not compile because of line 6.</item>
        <item>D. 11</item>
        <item>D. 4</item>
        <item>D. 36</item>
        <item>D. The code will not compile because of line 6.</item>
        <item>D. Empty = false, Brand = null</item>
        <item>D. 3</item>
        <item>D. Compilation fails on line 4.</item>


        <item>D. bbaaccca</item>
        <item>D. No output is printed.</item>
        <item>D. roar!!! roar!!!</item>
        <item>D. 10</item>
        <item>D. 7</item>
        <item>D. rumble4</item>
        <item>D. Compiler error on line 9.</item>
        <item>D. 46</item>
        <item>D. The result is undefined.</item>
        <item>D. Compiler error on line 5.</item>
        <item>D. Compiler error on line 8.</item>
        <item>D. 2 1 –3</item>
        <item>D. An exception is thrown.</item>
        <item>D. The code does not compile.</item>
        <item>D. Another date.</item>
        <item>D. 2021 APRIL 2</item>
        <item>D. 5/10/15</item>
        <item>D. 5/10/14</item>


        <item>D. Compiler error on line 5 of Chimp.</item>
        <item>D. 8</item>
        <item>D. 3</item>
        <item>D. intObjectfloat</item>
        <item>D. Compiler error on line 9.</item>
        <item>D. Replace line 2 with new BirdSeed(2);</item>
        <item>D. u u curcur</item>
        <item>D. tacfb</item>
        <item>D. Compiler error on line 10.</item>
        <item>D. Compiler error on line 10.</item>


        <item>D. MammalPlatypus</item>
        <item>D. The code will not compile because of line 7.</item>
        <item>D. The code will not compile because of line 4.</item>
        <item>D. The code will not compile because of line 5.</item>
        <item>D. The code will not compile because of line 5.</item>
        <item>D. ArthropodArthropod</item>
        <item>D. The code will not compile because of line 5.</item>
        <item>D. The code will not compile because of line 9.</item>
        <item>D. The code will not compile because of line 5.</item>


        <item>D. When there is exactly one catch block in a try statement.</item>
        <item>D. NumberFormatException</item>
        <item>D. It will run and throw an IllegalArgumentException.</item>
        <item>D. AECD</item>
        <item>D. done0</item>
        <item>D. Starting up Shutting down.</item>
        <item>D. 124</item>
        <item>D. An uncaught exception is thrown.</item>
        <item>D. You want to loop through a list</item>


        <item>D. A compiler error occurs on line 3.</item>
        <item>D. Compiler error on line 12.</item>
        <item>D. The code does not compile.</item>
        <item>D. false true</item>
        <item>D. Line 5 throws an AssertionError at runtime.</item>
        <item>D. Dolphins_fr.properties and Dolphins.properties</item>
        <item>D. 3</item>
        <item>D. A compiler error occurs on line 2.</item>
        <item>D. true true</item>
        <item>D. The output is something other than 2016–05–01 or 2016–06–01.</item>


        <item>D. The equals() method fails to compile.</item>
        <item>D. The code does not compile because equals() tries to refer to a private field</item>
        <item>D. Both B and C.</item>
        <item>D. The class compiles and has proper equals() and hashCode() methods.</item>
        <item>D. CHOCOLATE</item>
        <item>D. Line 8 generates a compiler error.</item>
        <item>D. Line 8 generates a compiler error</item>
        <item>D. A compiler error occurs on line 3.</item>
        <item>D. import static my.sports.Football.*;</item>
        <item>D. The code does not compile.</item>
        <item>D. c instanceof Mammal does not compile</item>
        <item>D. Outer.Inner in = new Outer().Inner();</item>
        <item>D. walk,walk,</item>


        <item>D. The code will not compile because of line 5.</item>
        <item>D. Compiler error on line h2.</item>
        <item>D. The code will not compile because of line 8.</item>
        <item>D. Compiler error on line x2.</item>
        <item>D. The code will not compile because of line 4.</item>
        <item>D. The code will not compile because of line 5.</item>


        <item>D. HashSet</item>
        <item>D. TreeMap</item>
        <item>D. Compiler error on line 6</item>
        <item>D. hi</item>
        <item>D. Compiler error on line 4</item>
        <item>D. ONE</item>
        <item>D. map.add(\'x\', new Double(123.4));</item>
        <item>D. 123 aab Abb</item>
        <item>D. Compiler error on line 5.</item>
        <item>D. [88. 55] [88, 55]</item>
        <item>D. The result is undefined.</item>
        <item>D. Compiler error on line 5.</item>
        <item>D. Add &#60;?> after the public keyword</item>
        <item>D. {1=13, 2=20}</item>


        <item>D. java.util.stream.ReferencePipeline$3@4517d9a3</item>
        <item>D. The code does not compile.</item>
        <item>D. The code does not compile.</item>
        <item>D. L, N, M, O</item>
        <item>D. The code compiles but prints stream references.</item>
        <item>D. Line 7 does not compile.</item>
        <item>D. {false=[], true=[]} {false=[], true=[]}</item>
        <item>D. Function&#60;Integer> f = x -> x*x;</item>
        <item>D. 1.2 and 2.4</item>


        <item>D. Whales.properties</item>
        <item>D. Dolphins_fr.properties and Dolphins.properties</item>
        <item>D. The code does not compile.</item>
        <item>D. Another date</item>
        <item>D. 2021 APRIL 2</item>
        <item>D. 5/10/15</item>
        <item>D. 5/10/14</item>
        <item>D. 2,1,3</item>
        <item>D. none null</item>


    </string-array>



    <string-array name="keysEForOCAOCP">
        <item>E. The code does not compile.</item>
        <item>E. 13</item>
        <item>E. The code does not compile</item>
        <item>E. Compiler error on line 8</item>
        <item>E. The code does not compile.</item>
        <item>E. DeerAgeReindeer,false</item>
        <item>E. The code will not compile because of line 4.</item>
        <item>E. Compiler error on line 10.</item>
        <item>E. The code will not compile because of line 6.</item>
        <item>E. .javac</item>

        <item>E. The code will not compile because of line 4.</item>
        <item>E. The code will not compile because of line 8.</item>
        <item>E. The code will not compile because of line 6.</item>
        <item>E. 7</item>
        <item>E. false, 20, true</item>
        <item>E. The code will not compile because of line 5.</item>
        <item>E. An undefined value</item>
        <item>E. The code will not compile because of line 3.</item>
        <item>E. The code will not compile because of line 3.</item>
        <item>E. The code will not compile because of line 3.</item>
        <item>E. 16</item>
        <item>E. The code will not compile because of line 4.</item>
        <item>E. The code contains an infinite loop and does not terminate.</item>
        <item>E. 15</item>
        <item>E. 6</item>
        <item>E. 50</item>
        <item>E. The code will not compile because of lines 6 and 9. </item>
        <item>E. Empty = false, Brand =</item>
        <item>E. 4</item>
        <item>E. Compilation fails on line 7.</item>


        <item>E. An exception is thrown.</item>
        <item>E. An exception is thrown.</item>
        <item>E. An exception is thrown.</item>
        <item>E. An exception is thrown.</item>
        <item>E. An exception is thrown.</item>
        <item>E. An exception is thrown.</item>
        <item>E. Compiler error on line 10.</item>
        <item>E. 45</item>
        <item>E. An exception is thrown.</item>
        <item>E. Compiler error on line 6.</item>
        <item>E. An exception is thrown.</item>
        <item>E. None of the above.</item>
        <item>E. The code does not compile.</item>
        <item>E. A runtime exception is thrown.</item>
        <item>E. The code does not compile.</item>
        <item>E. 2021 APRIL 30</item>
        <item>E. 11:22 AM</item>
        <item>E. The code does not compile</item>


        <item>E. Compiler error on line 6 of Chimp.</item>
        <item>E. The code does not compile.</item>
        <item>E. 4</item>
        <item>E. intObjectObject</item>
        <item>E. Compiler error on a different line.</item>
        <item>E. Replace line 1 with this(2);</item>
        <item>E. u u ucrcr</item>
        <item>E. tacftacb</item>
        <item>E. Compiler error on line 11.</item>
        <item>E. Compiler error on a different line.</item>


        <item>E. The code will not compile because of line 8.</item>
        <item>E. It compiles but throws an exception at runtime.</item>
        <item>E. The code will not compile because of lines 2 and 3.</item>
        <item>E. The code will not compile because of lines 2 and 5.</item>
        <item>E. The code will not compile because of line 7.</item>
        <item>E. The code will not compile because of line 5.</item>
        <item>E. The code will not compile because of line 9.</item>
        <item>E. The output cannot be determined from the code provided.</item>
        <item>E. The code will not compile because of line 9. </item>


        <item>E. When there are two or more catch blocks in a try statement.</item>
        <item>E. None of the above.</item>
        <item>E. None of the above.</item>
        <item>E. No output appears other than the stack trace</item>
        <item>E. The code does not compile.</item>
        <item>E. The code does not compile</item>
        <item>E. 1245</item>
        <item>E. 1256, followed by a stack trace for a NumberFormatException</item>
        <item>E. You don’t know how to code a method.</item>


        <item>E. A compiler error occurs on line 7.</item>
        <item>E. a string123</item>
        <item>E. It compiles but throws an exception at runtime on line c1.</item>
        <item>E. The code does not compile</item>
        <item>E. The output is 10.</item>
        <item>E. Dolphins_fr.properties and Dolphins_fr_CA.properties</item>
        <item>E. 4</item>
        <item>E. A compiler error occurs on line 6.</item>
        <item>E. The code does not compile.</item>
        <item>E. The code does not compile.</item>


        <item>E. Another line of code fails to compile.</item>
        <item>E. The code does not compile because the ClassCastException is not handled or declared.</item>
        <item>E. The code does not compile</item>
        <item>E. ~ ~</item>
        <item>E. The code does not compile due to a missing semicolon</item>
        <item>E. Line 9 generates a compiler error</item>
        <item>E. Line 11 generates a compiler error</item>
        <item>E. A compiler error occurs on line 5.</item>
        <item>E. static import my.sports.*;</item>
        <item>E. A runtime exception is thrown.</item>
        <item>E. c instanceof Furry does not compile.</item>
        <item>E. Outer.Inner in = new Outer().new Inner();</item>
        <item>E. The code does not compile.</item>


        <item>E. The code will not compile because of line 8.</item>
        <item>E. Compile error on line h3.</item>
        <item>E. The code will not compile because of line 9.</item>
        <item>E. Compiler error on a different line.</item>
        <item>E. The code will not compile because of lines 2 and 3.</item>
        <item>E. The code will not compile because of lines 2 and 5.</item>


        <item>E. LinkedList</item>
        <item>E. TreeSet </item>
        <item>E. Compiler error on line 7</item>
        <item>E. hihello</item>
        <item>E. Compiler error on line 6</item>
        <item>E. The code does not compile.</item>
        <item>E. None of the above</item>
        <item>E. The code does not compile.</item>
        <item>E. Compiler error on line 7.</item>
        <item>E. The code does not compile.</item>
        <item>E. The code does not compile.</item>
        <item>E. Compiler error on line 7.</item>
        <item>E. Add &#60;?> after the static keyword.</item>
        <item>E. {1=13, 2=20, 3=null}</item>


        <item>E. The code does not compile.</item>
        <item>E. An exception is thrown.</item>
        <item>E. An exception is thrown.</item>
        <item>E. L, O, M</item>
        <item>E. The code runs infinitely.</item>
        <item>E. Line 8 does not compile.</item>
        <item>E. The code does not compile.</item>
        <item>E. Function&#60;Integer, Integer> f = x -> x*x;</item>
        <item>E. There is no output.</item>


        <item>E. Whales_en_US.properties</item>
        <item>E. Dolphins_fr.properties and Dolphins_en.properties</item>
        <item>E. A runtime exception is thrown</item>
        <item>E. The code does not compile.</item>
        <item>E. 2021 APRIL 30</item>
        <item>E. 11:22 AM</item>
        <item>E. The code does not compile.</item>
        <item>E. The code does not compile.</item>
        <item>E. The code does not compile</item>

    </string-array>


    <string-array name="keysFForOCAOCP">
        <item>F. Runtime error</item>
        <item>F. The code will not compile because of line 7</item>
        <item>F. An uncaught exception is thrown.</item>
        <item>F. None of the above.</item>
        <item>F. None of the above.</item>
        <item>F. The code will not compile because of line 7.</item>
        <item>F. The code will not compile because of line 6.</item>
        <item>F. Compiler error on line 11.</item>
        <item>F. The code compiles without issue but does not produce any output.</item>
        <item>F. .java</item>

        <item>F. The code will not compile because of line 5.</item>
        <item>F. The code contains an infinite loop and does not terminate</item>
        <item>F. The code will not compile because of line 7</item>
        <item>F. The code will not compile because of line 4</item>
        <item>F. The code will not compile because of line 5.</item>
        <item>F. The code contains an infinite loop and does not terminate.</item>
        <item>F. 100</item>
        <item>F. 10</item>
        <item>F. The code will not compile because of line 6.</item>
        <item>F. The code will not compile because of line 6.</item>
        <item>F. The code will not compile because of line 5</item>
        <item>F. The code contains an infinite loop and does not terminate.</item>
        <item>F. The code will not compile because of line 4.</item>
        <item>F. The code will not compile because of line 8.</item>
        <item>F. The code will not compile because of line 6.</item>
        <item>F. The code will not compile because of line 7.</item>
        <item>F. The code will not compile because of lines 9. </item>
        <item>F. Empty = null, Brand = null</item>
        <item>F. Does not compile</item>
        <item>F. Compilation fails on line 8.</item>


        <item>F. The code does not compile.</item>
        <item>F. The code does not compile.</item>
        <item>F. The code does not compile.</item>
        <item>F. The code does not compile.</item>
        <item>F. The code does not compile.</item>
        <item>F. The code does not compile.</item>
        <item>F. The code does not compile.</item>
        <item>F. An exception is thrown.</item>
        <item>F. The code does not compile.</item>
        <item>F. An exception is thrown.</item>
        <item>F. Compiler error on line 6.</item>
        <item>F. The code doesn’t compile.</item>
        <item>F. ABC </item>
        <item>F. 2018 MAY 30</item>
        <item>F. A runtime exception is thrown.</item>
        <item>F. 2021 MAY 2</item>
        <item>F. The code does not compile.</item>
        <item>F. A runtime exception is thrown.</item>

        <item>F. Compiler error on line 7 of Chimp.</item>
        <item>F. An exception is thrown.</item>
        <item>F. 5</item>
        <item>F. byteObjectObject</item>
        <item>F. does not compile</item>
        <item>F. Replace line 2 with this(2);</item>
        <item>F. ur ur urc</item>
        <item>F. The code does not compile.</item>
        <item>F. A runtime exception is thrown.</item>
        <item>F. A runtime exception is thrown.</item>


        <item>F. The code will not compile because of line 11</item>
        <item>F. The code will not compile because of line 8</item>
        <item>F. The code will not compile because of lines 3 and 4.</item>
        <item>F. The code will not compile because of lines 7.</item>
        <item>F. The code will not compile because of line 8.</item>
        <item>F. The code will not compile because of line 9.</item>
        <item>F. The code will not compile because of line 2.</item>
        <item>F. The code will not compile because of line 4.</item>
        <item>F. The code will not compile because of line 2.</item>


        <item>F. ~ ~</item>
        <item>F. ~ ~</item>
        <item>F. ~ ~</item>
        <item>F. ~ ~</item>
        <item>F. An uncaught exception is thrown.</item>
        <item>F. An uncaught exception is thrown.</item>
        <item>F. The code does not compile.</item>
        <item>F. The code does not compile.</item>
        <item>F. ~ ~</item>

        <item>F. A compiler error occurs on another line.</item>
        <item>F. An exception is thrown.</item>
        <item>F. It compiles but throws an exception at runtime on line c2</item>
        <item>F. The code compiles but throws an exception at runtime.</item>
        <item>F. The output is 11.</item>
        <item>F. Dolphins_fr_CA.properties and Dolphins_fr.properties</item>
        <item>F. 5</item>
        <item>F. A compiler error occurs on line 7.</item>
        <item>F. A runtime exception is thrown.</item>
        <item>F. An exception is thrown.</item>


        <item>F. A runtime exception is thrown</item>
        <item>F. The code does not compile for another reason.</item>
        <item>F. The code throws a runtime exception.</item>
        <item>F. ~ ~</item>
        <item>F. The code does not compile for a different reason</item>
        <item>F. An exception is thrown.</item>
        <item>F. An exception is thrown</item>
        <item>F. ~ ~</item>
        <item>F. static import my.sports.Football;</item>
        <item>F. ~ ~</item>
        <item>F. null instanceof Chipmunk does not compile.</item>
        <item>F. Outer.Inner in = Outer.new Inner();</item>
        <item>F. A runtime exception is thrown.</item>


        <item>F. It compiles but throws an exception at runtime.</item>
        <item>F. A runtime exception is thrown.</item>
        <item>F. ~~</item>
        <item>F. A runtime exception is thrown.</item>
        <item>F. The code will not compile because of lines 3 and 4.</item>
        <item>F. The code will not compile because the class Falcon doesn’t implement the interface methods.</item>


        <item>F. ~</item>
        <item>F. Vector</item>
        <item>F. ~</item>
        <item>F. The code does not compile</item>
        <item>F. Compiler error on line 7</item>
        <item>F. An exception is thrown</item>
        <item>F. ~</item>
        <item>F. A runtime exception is thrown.</item>
        <item>F. A runtime exception is thrown.</item>
        <item>F. A runtime exception is thrown.</item>
        <item>F. A runtime exception is thrown.</item>
        <item>F. A runtime exception is thrown.</item>
        <item>F. No change required. The code already compiles.</item>
        <item>F. {1=13, 2=20, 3=3}</item>


        <item>F. An exception is thrown.</item>
        <item>F. The code hangs.</item>
        <item>F. The code hangs.</item>
        <item>F. N, M</item>
        <item>F. The code does not compile</item>
        <item>F. The code throws an exception.</item>
        <item>F. An exception is thrown.</item>
        <item>F. None of the above</item>
        <item>F. The code does not compile.</item>

        <item>F. The code does not compile.</item>
        <item>F. The code does not compile.</item>
        <item>F. ~</item>
        <item>F. A runtime exception is thrown</item>
        <item>F. 2021 MAY 2</item>
        <item>F. The code does not compile.</item>
        <item>G. A runtime exception is thrown</item>
        <item>F. A runtime exception is thrown.</item>
        <item>F. A runtime exception is thrown.</item>

    </string-array>


<!--qwertyuio-->


    <string name="StudyTips">
        \t\t\t\t\tStudying for the Test
\n\nBefore you even sign up and take the test, you need to study the material. Studying includes
the following tasks:
\n■ Create a study plan.
\n■ Read the Study Guide material.
\n■ Create and run sample applications.
\n■ Solve the Review Questions at the end of each chapter.
\n■ Create flashcards and/or use the ones we’ve provided.
\n■ Take the three practice exams.
\n\tThe book is divided into chapters with corresponding exam objectives, to make it easier
to assimilate. The earlier chapters on syntax and operators are especially important since
they are used throughout the code samples on the exam. Unless we explicitly stated something was out of scope for the exam, you will be required to have a strong understanding of
all the information in this book.

        \n\n\n\t\tCreating a Study Plan
\n\n\t\tRome wasn’t built in a day, so you shouldn’t attempt to study for only one day. Even if you
have been certifi ed with a previous version of Java, the new test includes features and components unique to Java 8 that are covered in this text.
\t\tOnce you have decided to take the test, which we assume you have already since you’re
reading this book, you should construct a study plan that fi ts with your schedule. We recommend you set aside some amount of time each day, even if it’s just a few minutes during
lunch, to read or practice for the exam. The idea is to keep your momentum going throughout the exam preparation process. The more consistent you are in how you study, the better
prepared you will be for the exam. Try to avoid taking a few days or weeks off from studying, or you’re likely to spend a lot of time relearning existing material instead of moving on
to new material.

        \n\n\tYour own study plan will vary based on your familiarity with Java, your personal and
work schedule, and your learning abilities. The idea is to create a plan early on that has
self-imposed deadlines that you can follow throughout the studying process. When someone asks how you’re doing preparing for the exam, you should have a strong sense of what
you’ve learned so far, what you’re currently studying, and how many weeks you need to be
prepared to the take the exam.
        \n\n\tCreating and Running Sample Applications
\n\nAlthough some people can learn Java just by reading a textbook, that’s not how we recommend you study for a certification exam. We want you to be writing your own Java sample applications throughout this book so that you don’t just learn the material but you also
understand the material. For example, it may not be obvious why the following line of code
does not compile, but if you try to compile it yourself, the Java compiler will tell you the
problem.
        \n\nfloat value = 102.0; // DOES NOT COMPILE

        \n\n\nIn this section, we will discuss how to test Java code and the tools available to assist you
in this process.
        \n\n\tNOTE\nA lot of people post on the CodeRanch.com forum asking, “Why does this
code not compile?” and we encourage you to post the compiler error message anytime you need help. We recommend you also read the compiler
message when posting, since it may provide meaningful information about
why the code failed to compile.
In the previous example, the compiler failed to compile with the message
Type mismatch: cannot convert from double to float. This message indicates that we are trying to convert a double value, 102.0, to a
float variable reference using an implicit cast. If we add an explicit cast
to (float) or change the value to 102.0f, the code will compile without
issue.
        \n\nSample Test Class
\n\nThroughout this book, we present numerous code snippets and ask you whether they’ll
compile and what their output will be. These snippets are designed to be placed inside
a simple Java application that starts, executes the code, and terminates. As described in
Chapter 1, “Java Building Blocks,” you can accomplish this by compiling and running a
public class containing a public static void main(String[] args) method, such as the
following:
        \n\npublic class TestClass {
 \npublic static void main(String[] args) {
 \n// Add test code here
 \n// Add any print statements here
 \nSystem.out.println("Hello World!");
 \n}
        \n\n\tThis application isn’t particularly interesting—it just outputs “Hello World” and exits.
That said, we can insert many of the code snippets present in this book in the main()
method to determine if the code compiles, as well as what the code outputs when it does
compile. We strongly recommend you become familiar with this sample application, so
much so that you could write it from memory, without the comments.
        \n\n\tWe recommend that while reading this book you make note of any sections that you
do not fully understand and revisit them when in front of a computer screen with a Java
compiler and Java runtime. You should start by copying the code snippet into your test
class, and then try experimenting with the code as much as possible. For example, we indicated the previous sample line of code would not compile, but would any of the following
compile?
        \n\nfloat value1 = 102;
\nfloat value2 = (int)102.0;
\nfloat value3 = 1f * 0.0;
\nfloat value4 = 1f * (short)0.0;
\nfloat value5 = 1f * (boolean)0;
        \n\n\tTry out these samples on your computer and see if the result matches your expectation.
Here’s a hint: Two of these fi ves lines will not compile.

        \n\n\n\tIDE Software
\n\n\tWhile studying for the exam, you should develop code using a text editor and commandline Java compiler. Some of you may have existing experience with Integrated Development Environments (IDEs) such as Eclipse or IntelliJ. An IDE is a software application that
facilitates software development for computer programmers.
Although such tools are extremely valuable in developing software, they can interfere
with your ability to readily spot problems on the exam. For example, when a line code
does not compile, the IDE will often underline it in red, whereas on the exam, you’ll have
to fi nd the line that does not compile, if there is one, on your own.
If you do choose to study with an IDE, make sure you understand everything it is doing in
the background for you. For the exam, you’ll need to know how to manually compile code
from the command line, and this experience is rarely learned using an IDE. You’ll also
need to understand why the code does not compile without relying on the tips and suggestions provided by the IDE.
        \n\n\n\t\t\tIdentifying Your Weakest Link
\n\n\tThe best advice we can give you to do well on the exam is to practice writing sample applications that push the limits of what you already know, as much and as often as possible.
For example, if the previous samples with float values were too diffi cult for you, then you
should spend even more time studying numeric promotion and casting expressions.
Prior to taking the OCA exam, you may already be an experienced Java developer,
but there is a difference between being able to write Java code and being a certified Java developer. For example, you might go years without writing a ternary expression or using
an abstract class, but that does not mean they are not important features of the Java language. You may also be unaware of some of the more complex features that exist within
the Java language. On top of that, there are new features to Java 8, such as lambda expressions and default interface methods, which as of this writing very few professional software
developers are using.
        \n\tThe Review Questions in each chapter are designed to help you hone in on those features of the Java language that you may be weak in and that are required knowledge for the
exam. For each chapter, you should note which questions you got wrong, understand why
you got them wrong, and study those areas even more.
\n\tOften, the reason you got a question wrong on the exam is that you did not fully understand the concept. Many topics in Java have subtle rules that you often need to see for
yourself to truly understand. For example, you cannot write a class that implements two
interfaces that define the same default method unless you override the default method in the
class. Writing and attempting to compile your own sample interfaces and classes that reference the default method may illuminate this concept far better than we could ever explain it.
\n\tFinally, we fi nd developers who practice writing code while studying for the Java certifi cation tend to write better Java code in their professional career. Anyone can write a Java
class that can compile, but just because a class compiles does not mean it is well designed.
For example, imagine a class where all class methods and variables were declared public,
simply because the developer did not understand the other access modifi ers, such as protected and private. Studying for the certifi cation helps you to learn those features that
may be applicable in your daily coding experience but that you never knew existed within
the Java language.


        \n\n\n\t\t\t\t“Overstudying” Practice Exams
\n\n\tAlthough we recommend reading this book and writing your own sample applications
multiple times, redoing practice exams over and over can have a negative impact in the
long run. For example, some individuals study the practice exam questions so much that
they end up memorizing them. In this scenario, they can easily become overconfi dent—
they can achieve perfect scores on the practice exams but may fail on the actual exam.
\n\n\tIf you get a practice exam question correct, you should move on, and if you get it incorrect you should review the part of the chapter that covers it until you can answer it correctly. Remember that for legal reasons the practice exam questions are not real exam
questions, so it is important you learn the material the questions are based on.
\n\n\tOn the other hand, we recommend you repeat Review Questions as often as you like to
master a chapter. Review Questions are designed to teach you important concepts in the
chapter, and you should understand them completely before leaving a section. Furthermore, they help improve your ability to recognize certain types of problems present in
many code snippets.

        \n\n\n\t\t\tTaking the Test
\n\n\n\tStudying how to take a test can be just as important as the studying the material itself. For
example, you could answer every question correctly, but only make it halfway through the
exam, resulting in a failing score! If you’re not historically a good test taker, or you’ve never
taken a certification exam before, we recommend you read this section because it contains
notes that are relevant to many software certifi cation exams.
        \n\n\n\t\t\tUnderstanding the Question
\n\n\n\tThe majority of questions on the exam will contain code snippets and ask you to answer
questions about them. For those containing code snippets, the number one question we recommend you answer before attempting to solve the question is:
\n\n\tDoes the code compile?
\n\n\tIt sounds simple but many people dive into answering the question without checking
whether or not the code actually compiles. If you can determine whether or not a particular
set of code compiles, and what line or lines cause it to not compile, answering the question
often becomes easy.
}
        \n\n\n\t\t\tChecking the Answers
\n\n\n\tTo determine whether the code will compile, you should briefly review the answer choices
to see what options are available. If there are no choices of the form “Code does not compile,” then you can be reasonably assured all the lines of the code will compile and you do
not need to spend time checking syntax. These questions are often, but not always, among
the easiest questions because you can skip determining whether the code compiles and
instead focus on what it does.
\n\n\n\tIf the answer choices do include some answers of the form “Does not compile due to line
5,” you should immediately focus on those lines and determine whether they compile. For
example, take a look at the answer choices for the following question:

        \n\n\n\t18. What is the output of the following code?
\n\n\t\t- Code Omitted -
\n\nA. Monday
\n\nB. Tuesday
\n\nC. Friday
\n\nD. The code does not compile due to line 4.
\n\nE. The code does not compile due to line 6.

        \n\n\n\t\tThe answer choices act as a guide instructing you to focus on line 4 or 6 for compilation errors. If the question indicates only one answer choice is allowed, it also tells you at
most only one line of code contains a compilation problem and the other line is correct.
Although the reason line 4 or 6 may not compile could be related to other lines of code, the key is that those other lines do not throw compiler errors themselves. By quickly browsing
the list of answers, you can save time by focusing only on those lines of code that are possible candidates for not compiling.
\n\n\tIf you are able to identify a line of code that does not compile, you will be able to fi nish
the question a lot quicker. Often, the most diffi cult questions are the ones where the code
does in fact compile, but one of the answer choices is “Does not compile” without indicating any line numbers. In these situations, you will have to spend extra time verifying that
each and every line compiles. If they are taking too much time, we recommend marking
these for “Review” and coming back to them later.

        \n\n\n\t\t\tDetermining What the Question Is Asking
\n\n\n\t\tA lot of times, a question may appear to be asking one thing but will actually be asking
another. For example, the following question may appear to be asking about method overloading and abstract classes:
\n\n12. What is the output of the following code?
\n\t1: abstract class Mammal {
\n\t2: protected boolean hasFur() { return false; }
\n\t3: }
\n\t4: class Capybara implements Mammal {
\n\t5: public boolean hasFur() { return true; }
\n\t6: public static void main(String[] args) {
\n\t7: System.out.println(new Capybara().hasFur());
\n\t8: }
\n\t9: }
\n\n\t\tIt turns out this question is a lot simpler than it looks. A class cannot implement another
class—it can only extend another class—so line 4 will cause the code to fail to compile.
If you notice this compiler problem early on, you’ll likely be able to answer this question
quickly and easily.
        \n\n\n\t\t\tTaking Advantage of Context Clues
\n\n\n\t\tLet’s face it—there will be things you’re likely to forget on the day of the exam. Between
being nervous about taking the test and being a bit overtired when you read a particular chapter, you’re likely to encounter at least one question where you do not have a high
degree of confidence. Luckily, you do not need to score a perfect 100% to pass.
\n\n\tOne advanced test-taking skill that can come in handy is to use information from one
question to help answer another. For example, we mentioned in an earlier section that
you can assume a question’s code block will compile and run if “Does not compile” and
“Throw an exception at runtime” are not available in the list of answers. If you have a
piece of code that you know compiles and a related piece of code that you’re not so sure
about, you can use information from the former question to help solve the latter question.
        \n\n\t\tUse a similar strategy when a question asks which single line will not compile. If you’re
able to determine the line that does not compile with some degree of confi dence, you
can use the remaining code that you know does compile as a guide to help answer other
questions.
\n\n\tBy using context clues of other questions on the exam, you may be able to more easily
solve questions that you are unsure about.
        \n\n\n\t\t\t\tReviewing Common Compiler Issues
\n\n\n\t\tThe following is a brief list of common things to look for when trying to determine whether
code compiles. Bear in mind that this is only a partial list. We recommend you review each
chapter for a comprehensive list of reasons that code will not compile. Also, if you have not
finished reading the book, you should set aside this list and return to it when you are preparing to take the exam.
        \n\n\n\t\t\tApplying Process of Elimination
\n\n\n\tAlthough you might not immediately know the correct answer to a question, if you can
reduce the question from fi ve answers down to three, your odds of guessing the correct
answer will be markedly improved. For example, if you can reduce a question from four
answers to two answers, you double your chances of guessing the correct answer. In this
section, we will discuss how to apply the process of elimination to help improve your score.
        \n\n\n\t\t\tUsing the Provided Writing Material
\n\n\n\tDepending on your particular testing center, you may be provided with a stack of blank
paper or a whiteboard to use to help you answer questions. If you sit down and are not provided with anything, please make sure to ask for such materials.
After determining whether a question compiles and what it is asking for, you should
then jot down a list of all the answers. You should then proceed to cross out the ones you
know are not correct.
        \n\tIf you’re using paper and you decide to come back to this question, be sure to write
down the question number and save it for later. If you’re using a whiteboard and decide to
come back to a question later, you may have to redo some of the work, given the limited
space on a whiteboard. For those questions you want to come back to later, we suggest jotting down the remaining answer choices on the side of the whiteboard. Some test-taking software allows you to mark and save which answer choices you’ve eliminated, although in
our experience this does not always work reliably in practice.

        \n\n\n\t\t\t\tNOTE
        \n\n\n\t\t\tAlthough you are not allowed to bring any written notes with you into the
exam, you’re allowed to write things down you remember at the start of
the exam on the provided writing material. If there’s a particular facet of
the Java language that you have difficulty remembering, try memorizing
it before the exam and write it down as soon as the exam starts. You can
then use it as a guide for the rest of the exam. Of course, this strategy only
works for a handful of topics, since there’s a limit to what you’re likely to
remember in a short time.
\n\ntFor example, you may have trouble remembering the list of acceptable
data types in switch statements. If so, we recommend you memorize that
information before the exam and write it down as soon as the exam starts
for use in various questions.

        \n\n\n\t\t\tUnderstanding Relationships Between Answers
\n\n\n\t\t\tThe exam writers, as well as the writers of this book, are fond of answers that are related
to each other. We can apply the process of elimination to remove entire sets of answers
from selection, not just a single answer. For example, take a look at the following question:
\n\n22. What is the output of the following application?
\n3: int x = 0;
\n4: while(++x &#60; 5) { x+=1; }
\n5: String message = x > 5 ? "Greater than" : "Less Than";
\n6: System.out.println(message+","+x);
\nA. Greater than,5
\nB. Greater than,6
\nC. Greater than,7
\nD. Less than,5
\nE. Less than,6
\nF. Less than,7
\n\n\n\t\tIn this question, notice that half of the answers output Greater than, whereas the other
half output Less than. Based on the code, as well as the answers available, the question
cannot output both values. That means if you can determine what the ternary expression
on line 5 evaluates to, you can eliminate half the answers!
\n\n\t\tYou might also notice that this particular question does not include any “Does not compile” or “Code throws an exception at runtime” answers, meaning you can be assured this
snippet of code does compile and run without issue. If you have a question similar to this,
you can compare the syntax and use this as a guide for solving other related questions.
        \n\n\n\t\t\tGuessing the Correct Answer
\n\n\n\t\tUnlike with some other standardized tests, there’s no penalty for answering a question
incorrectly versus leaving it blank. If you’re nearly out of time, or you just can’t decide on
an answer, select a random answer and move on. If you’ve been able to eliminate even one
answer, then your guess will be better than blind luck.
        \n\n\n\t\t\tAnswer All Questions!
\n\n\n\t\tYou should set a hard stop of 5 minutes of time remaining on the exam to ensure that
you’ve answered each and every question. Remember, if you fail to answer a question
you’ll definitely get it wrong and lose points, but if you guess, there’s at least a chance
you’ll be correct. There’s no harm in guessing!
\n\n\t\tWhen in doubt, we generally recommend picking a random answer that includes “Does
not compile” if available, although which choice you select is not nearly as important as
making sure to not leave any unanswered questions on the exam!
        \n\n\n\t\t\tOptimizing Your Time
\n\n\n\t\tOne of the most difficult test-taking skills to master is balancing your time on the exam.
Although Oracle often varies the precise number of questions on the exam and the amount
of time you have to answer them, the general rule of thumb is that you have about one and
half minutes per question.
\n\n\t\tOf course, it can be stressful to frequently look at the time remaining while taking the
exam, so the key is pacing yourself. Some questions will take you longer than two minutes
to solve, but hopefully others will only take less than a minute. The more time you save on
the easier questions, the more time you’ll have for the harder questions.

        \n\n\n\t\t\tChecking the Time Remaining
\n\n\n\t\tThe exam software includes a clock that tells you the amount of time you have left on
the exam. We don’t recommend checking the clock after each and every question to determine your pace. After all, doing such a calculation will waste time and probably make you
nervous and stressed out. We do recommend you check the time remaining at certain points
while taking the exam to determine whether you should try to increase your pace.
\n\n\t\tFor example, if the exam lasts two hours and is 90 questions long, the following would
be a good pace to try to keep.
\n\t■ 120 Minutes Remaining: Start exam.
\n\t■ 90 Minutes Remaining: One third of the exam finished.
\n\t■ 60 Minutes Remaining: Two thirds of the exam finished.
\n\t■ 30 Minutes Remaining: First pass of all questions complete.
\n\t■ 5 Minutes Remaining: Finished reviewing all questions marked for “Review.” Select
answers to all questions left blank.
        \n\n\t\tAs you’re taking the exam you may realize you’re falling behind. In this scenario, you
need to start allotting less time per question, which may involve more guessing, or you’ll
end up with some questions that you never even answered. As discussed in the previous section, guessing an answer to a question is better than not answering the question at all.
        \n\n\n\t\t\tSkipping Hard Questions
\n\n\t\tIf you do fi nd you are having difficulty with a particular set of questions, just skip them.
The exam provides a feature to mark questions for “Review” that you can later come back
to. Remember that all questions on the exam, easy or difficult, are weighted the same. It is
a far better use of your time to spend fi ve minutes answering ten easy questions than the
same amount of time answering one difficult question.
\n\n\t\tYou might come to a question that looks difficult and immediately realize it is going to
take a lot of time. In this case, skip it before even starting on it. You can save the most difficult problems for the end so that you can get all the easy ones solved early on. Of course,
you should not mark every question for “Review,” so use that sparingly. For example, if you
only need 30 more seconds to solve a specific question, it is better to finish it so you do not
have to come back to it later. The trick is to not get stuck on a difficult question for a long
period of time.
        \n\n\n\t\t\tImproving Your Test-Taking Speed
\n\n\t\tAnswering certification exam questions quickly does not come naturally to most people.
It takes a bit of practice and skill to look at a question, a code sample, and 4–6 answers,
and be able to answer it within a minute or two. The best way to practice is to keep solving
the review questions at the end of each chapter until you can read, understand, and answer
them in under a minute.
\n\n\t\tOnce you’ve completed all of the material and practiced with the review questions
enough that you can answer them quickly and correctly, you should try one of the three
60-question practice exams that come with this Study Guide. You should treat it like the
real exam, setting aside two hours and fi nishing it in one sitting.
\n\n\t\tAlthough we recommend you try to avoid taking the practice exams so much that you
memorize the questions and answers, we do recommend you keep taking them until you
can fi nish each practice exam in under two hours. Remember not to move on to the next
one until you can pass the previous exam in the allotted time. If not, study more and go
back to drilling on the Review Questions. The idea is that you want to be good at quickly
reading through the question, honing in on the key concept the question is asking, and
being able to select the answer that best represents it.
        \n\n\n\t\t\tGetting a Good Night’s Rest
\n\n\t\tAlthough a lot of people are inclined to cram as much material as they can in the hours
leading up to the exam, most studies have shown that this is a poor test-taking strategy.
The best thing we can recommend you do before the exam is to get a good night’s rest!
\n\n\t\tGiven the length of the exam and number of questions, the exam can be quite draining,
especially if this is your fi rst time taking a certifi cation exam. You might come in expecting to be done 30 minutes early, only to discover you are only a quarter of the way through
the exam with half the time remaining. At some point, you may begin to panic, and it is
in these moments that these test-taking skills are most important. Just remember to take
a deep breath, stay calm, eliminate as many wrong answers as you can, and make sure to
answer each and every question. It is for stressful moments like these that being well rested
with a good night’s sleep will be most benefi cial!

    </string>


</resources>